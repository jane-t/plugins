--[[
@Title:			Search and Replace
@Author:			Mike Tate
@Version:			2.1
@LastUpdated:	21 Dec 2013
@Description:	Searches for and replaces any given text or date within the current project, with an option to ask for confirmation for each change.
					At the end, lists all changed fields with links back to the record (double-click on an item to view it in the Property Box).
@Version 2.1:	iup_gui update, comments removed, Attribute values & other dropdown lists, %t & %n for tab & newline, inhibit Whole Words for spaces/punctuation, allow repeated words, etc.
@Version 2.0:	Better Item Details, Attribute values, more field search options, Search Only mode, updated GUI, Help & Advice, Sticky Settings, Libraries, etc.
@Version 1.7:	Add the Date and specific Tag related field search & replace capability (see lines marked with -- V1.7) plus major code tidy.
@Version 1.6:	Add more details to the replace prompt for the context of the field being changed.
@Version 1.5:	General code tidy (not published).
@Version 1.4:	Add options for whole word search only and prevent wild card patterns being used automatically 
@Version 1.3:	Add Case insensitive searching and cancel or close the window will abort the replaces, while still listing the changes made.
@Version 1.2:	Change to Provide a Skip Button, to cancel click the close button on the window.
@Version 1.1:	Add Skip tick box to replace prompt.
--]]

---[==[

-- Initial +fh+ functions below should eventually become library modules --

--[[
@Title:			+fh+stringx_v1
@Author:			Mike Tate
@LastUpdated:	22 Oct 2013
@Version:			1.2
@Description:	Extended string functions to supplement LUA string library.
@V1.0:				Initial version.
]]

local function stringx_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}									-- Local environment table
package.seeall(fh)								-- Enable all globals
module(...,package.seeall)					-- Create matching module name
setfenv(1,fh)									-- All public names are added to local fh table

function ReportVersion()
	local strMessage = "This is +fh+stringx_v1"
	print(strMessage)
	return strMessage
end

-- Split a string using "," or chosen separator --
function split(strTxt,strSep)
	local strSep = strSep or ","
	local tblFields = {}
	local strPattern = string.format("([^%s]+)", strSep)
	strTxt = strTxt or ""
	strTxt:gsub(strPattern, function(strField) tblFields[#tblFields+1] = strField end)
	return tblFields
end -- function split

-- Split a string into numbers using " " or "," or "x" separators	-- Any non-number remains as a string
function splitnumbers(strTxt)
	local tblNum = {}
	strTxt = strTxt or ""
	strTxt:gsub("([^ ,x]+)", function(strNum) tblNum[#tblNum+1] = tonumber(strNum) or strNum end)
	return tblNum
end -- function splitnumbers

-- Hide magic pattern symbols	^ $ ( ) % . [ ] * + - ?
function plain(strTxt)
	-- Prefix every non-alphanumeric character (%W) with a % escape character,
	-- where %% is the % escape, and %1 is the original character capture.
	strTxt = (strTxt or ""):gsub("(%W)","%%%1")
	return strTxt
end -- function plain

-- matches is plain text version of string.match()
function matches(strTxt,strFind,intInit)
	strFind = (strFind or ""):gsub("(%W)","%%%1")						-- Hide magic pattern symbols
	return strTxt:match(strFind,intInit)
end -- function matches

-- replace is plain text version of string.gsub()
function replace(strTxt,strOld,strNew,intNum)
	strOld = (strOld or ""):gsub("(%W)","%%%1")							-- Hide magic pattern symbols
	return strTxt:gsub(strOld,function() return strNew end,intNum)	-- Hide % capture symbols
end -- function replace

-- convert is pattern without captures version of string.gsub()
function convert(strTxt,strOld,strNew,intNum)
	return strTxt:gsub(strOld,function() return strNew end,intNum)	-- Hide % capture symbols
end -- function convert

-- import overloads fh functions into string table
function import()
	for strIndex, anyValue in pairs(fh) do
		if type(anyValue) == 'function' and strIndex ~= "import" then
			string[strIndex] = anyValue
		end
	end
end -- function import

return fh

end -- local function stringx_v1

--[[
@Module:			fh.tablex_v1
@Author:			Mike Tate
@Version:			1.1
@LastUpdated:	19 Oct 2013
@Description:	A Table Load Save Module.
@V1.0:				Initial version 0.94 is Lua 5.1 compatible.
]]

local function tablex_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

------------------------------------------------------ Start Table Load Save
-- require "_tableloadsave"
--[[
   Save Table to File/Stringtable
   Load Table from File/Stringtable
   v 0.94
   
   Lua 5.1 compatible
   
   Userdata and indices of these are not saved
   Functions are saved via string.dump, so make sure it has no upvalues
   References are saved
   ----------------------------------------------------
   table.save( table [, filename] )
   
   Saves a table so it can be called via the table.load function again
   table must a object of type 'table'
   filename is optional, and may be a string representing a filename or true/1
   
   table.save( table )
      on success: returns a string representing the table (stringtable)
      (uses a string as buffer, ideal for smaller tables)
   table.save( table, true or 1 )
      on success: returns a string representing the table (stringtable)
      (uses io.tmpfile() as buffer, ideal for bigger tables)
   table.save( table, "filename" )
      on success: returns 1
      (saves the table to file "filename")
   on failure: returns as second argument an error msg
   ----------------------------------------------------
   table.load( filename or stringtable )
   
   Loads a table that has been saved via the table.save function
   
   on success: returns a previously saved table
   on failure: returns as second argument an error msg
   ----------------------------------------------------
   
   chillcode, http://lua-users.org/wiki/SaveTableToFile
   Licensed under the same terms as Lua itself.
]]--

   -- declare local variables
   --// exportstring( string )
   --// returns a "Lua" portable version of the string
   local function exportstring( s )
      s = string.format( "%q",s )
      -- to replace
      s = string.gsub( s,"\\\n","\\n" )
      s = string.gsub( s,"\r","\\r" )
      s = string.gsub( s,string.char(26),"\"..string.char(26)..\"" )
      return s
   end
--// The Save Function
function save(  tbl,filename )
   local charS,charE = "   ","\n"
   local file,err
   -- create a pseudo file that writes to a string and return the string
   if not filename then
      file =  { write = function( self,newstr ) self.str = self.str..newstr end, str = "" }
      charS,charE = "",""
   -- write table to tmpfile
   elseif filename == true or filename == 1 then
      charS,charE,file = "","",io.tmpfile()
   -- write table to file
   -- use io.open here rather than io.output, since in windows when clicking on a file opened with io.output will create an error
   else
      file,err = io.open( filename, "w" )
      if err then return _,err end
   end
   -- initiate variables for save procedure
   local tables,lookup = { tbl },{ [tbl] = 1 }
   file:write( "return {"..charE )
   for idx,t in ipairs( tables ) do
      if filename and filename ~= true and filename ~= 1 then
         file:write( "-- Table: {"..idx.."}"..charE )
      end
      file:write( "{"..charE )
      local thandled = {}
      for i,v in ipairs( t ) do
         thandled[i] = true
         -- escape functions and userdata
         if type( v ) ~= "userdata" then
            -- only handle value
            if type( v ) == "table" then
               if not lookup[v] then
                  table.insert( tables, v )
                  lookup[v] = #tables
               end
               file:write( charS.."{"..lookup[v].."},"..charE )
            elseif type( v ) == "function" then
               file:write( charS.."loadstring("..exportstring(string.dump( v )).."),"..charE )
            else
               local value =  ( type( v ) == "string" and exportstring( v ) ) or tostring( v )
               file:write(  charS..value..","..charE )
            end
         end
      end
      for i,v in pairs( t ) do
         -- escape functions and userdata
         if (not thandled[i]) and type( v ) ~= "userdata" then
            -- handle index
            if type( i ) == "table" then
               if not lookup[i] then
                  table.insert( tables,i )
                  lookup[i] = #tables
               end
               file:write( charS.."[{"..lookup[i].."}]=" )
            else
               local index = ( type( i ) == "string" and "["..exportstring( i ).."]" ) or string.format( "[%d]",i )
               file:write( charS..index.."=" )
            end
            -- handle value
            if type( v ) == "table" then
               if not lookup[v] then
                  table.insert( tables,v )
                  lookup[v] = #tables
               end
               file:write( "{"..lookup[v].."},"..charE )
            elseif type( v ) == "function" then
               file:write( "loadstring("..exportstring(string.dump( v )).."),"..charE )
            else
               local value =  ( type( v ) == "string" and exportstring( v ) ) or tostring( v )
               file:write( value..","..charE )
            end
         end
      end
      file:write( "},"..charE )
   end
   file:write( "}" )
   -- Return Values
   -- return stringtable from string
   if not filename then
      -- set marker for stringtable
      return file.str.."--|"
   -- return stringttable from file
   elseif filename == true or filename == 1 then
      file:seek ( "set" )
      -- no need to close file, it gets closed and removed automatically
      -- set marker for stringtable
      return file:read( "*a" ).."--|"
   -- close file and return 1
   else
      file:close()
      return 1
   end
end

--// The Load Function
function load( sfile )
   local tables,err
   -- catch marker for stringtable
   if string.sub( sfile,-3,-1 ) == "--|" then
      tables,err = loadstring( sfile )
   else
      tables,err = loadfile( sfile )
   end
   if err then return _,err
   end
   tables = tables()
   for idx = 1,#tables do
      local tolinkv,tolinki = {},{}
      for i,v in pairs( tables[idx] ) do
         if type( v ) == "table" and tables[v[1]] then
            table.insert( tolinkv,{ i,tables[v[1]] } )
         end
         if type( i ) == "table" and tables[i[1]] then
            table.insert( tolinki,{ i,tables[i[1]] } )
         end
      end
      -- link values, first due to possible changes of indices
      for _,v in ipairs( tolinkv ) do
         tables[idx][v[1]] = v[2]
      end
      -- link indices
      for _,v in ipairs( tolinki ) do
         tables[idx][v[2]],tables[idx][v[1]] =  tables[idx][v[1]],nil
      end
   end
   return tables[1]
end

------------------------------------------------------ End Table Load Save

-- import overloads fh functions into table
function import()
	for strIndex, anyValue in pairs(fh) do
		if type(anyValue) == 'function' and strIndex ~= "import" then
			table[strIndex] = anyValue
		end
	end
end -- function import

return fh

end -- local function tablex_v1

--[[
@Title:			+fh+general_v1
@Author:			Mike Tate
@LastUpdated:	19 Oct 2013
@Version:			1.1
@Description:	A general functions module to supplement LUA functions.
@V1.0:				Initial version.
]]

local function general_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

require "lfs"													-- To access LUA filing system

-- Check if file exists --
function FlgFileExists(strFileName)
--	return pl.path.isfile(strFileName)
---[=[
	if lfs.attributes(strFileName,"mode") == "file" then
		return true
	else
		return false
	end
--]=]
end -- function FlgFileExists

-- Check if folder exists --
function FlgFolderExists(strFolderName)
--	return pl.path.isdir(strFolderName)
---[=[
	if lfs.attributes(strFolderName:gsub("\\$",""),"mode") == "directory" then
		return true
	else
		return false
	end
--]=]
end -- function FlgFolderExists

-- Check if folder writable --
function FlgFolderWrite(strFolderName)
	if FlgFolderExists(strFolderName) then
		local fileHandle, strError = io.open(strFolderName.."\\xyz.xyz","w")
		if fileHandle ~= nil then
			fileHandle:close()
			os.remove(strFolderName.."\\xyz.xyz")
			return true
		end
	end
	return false
end -- function FlgFolderWrite

-- Open File and return Handle --
function OpenFile(strFileName,strMode)
	local fileHandle, strError = io.open(strFileName,strMode)
	if fileHandle == nil then
		error("\n Unable to open file in \""..strMode.."\" mode. \n "..strFileName.." \n "..strError.." \n")
	end
	return fileHandle
end -- function OpenFile

-- Save string to file --
function SaveStringToFile(strString,strFileName)
	local fileHandle = OpenFile(strFileName,"w")
	fileHandle:write(strString)
	assert(fileHandle:close())
end -- function SaveStringToFile

-- Load string from file --
function StrLoadFromFile(strFileName)
	local fileHandle = OpenFile(strFileName,"r")
	local strString = fileHandle:read("*all")
	assert(fileHandle:close())
	return strString
end -- function StrLoadFromFile

-- Return the Path, Filename, and extension as 3 values
function SplitFilename(strFilename)
	return strFilename:match("(.-)([^\\]-([^\\%.]+))$")
end -- function SplitFilename

-- Return a Directory Tree entry & attributes on each iteration --
function DirTree(strDir)
	assert(strDir and strDir ~= "", "directory parameter is missing or empty")
	if strDir:sub(-1) == "/" then
		strDir = strDir:sub(1,-2)								-- Remove trailing "/"
	end
    
	local function doYieldTree(strDir)
--!		for strEntry in pl.path.dir(strDir) do
		for strEntry in lfs.dir(strDir) do
			if strEntry ~= "." and strEntry ~= ".." then
				strEntry = strDir.."\\"..strEntry
				local tblAttr, strError = lfs.attributes(strEntry)
				if not tblAttr then tblAttr = { mode="attrfail", error=strError } end 
				coroutine.yield(strEntry,tblAttr)
				if tblAttr.mode == "directory" then
					doYieldTree(strEntry)
				end
			end
		end
	end -- local function doYieldTree

	return coroutine.wrap(function() doYieldTree(strDir) end)
end -- function DirTree

local function strErrorText(strError,strFileName,intRepeat)
	return strError:gsub(strFileName:match("(.+\\).+"),"Del#"..tostring(intRepeat)..":")
end -- local function strErrorText

-- Delete file if it exists --
function DeleteFile(strFileName,errFunction)
	if FlgFileExists(strFileName) then
		local fileHandle, strError = os.remove(strFileName)
		if fileHandle == nil then
			local intRepeat = 1
			repeat
				if intRepeat > 1 and type(errFunction) == "function" then
					errFunction(strErrorText(strError,strFileName,intRepeat))
				end
				fhSleep(300,100)
				if FlgFileExists(strFileName) then
					fileHandle, strError = os.remove(strFileName)
				end
				intRepeat = intRepeat + 1
			until fileHandle ~= nil or intRepeat > 10
			if intRepeat > 10 then error(strErrorText(strError,strFileName,intRepeat)) end
		end
	end
end -- function DeleteFile

-- Invoke FH Shell Execute API --
function DoExecute(strExecutable,...)
	local errFunction = fhMessageBox
	if type(arg[#arg]) == 'function' then
		errFunction = arg[#arg]
		table.remove(arg)
	end
	local isOK, intErrorCode, strErrorText = fhShellExecute(strExecutable,unpack(arg))
	if not isOK then
		errFunction(tostring(strErrorText).." ("..tostring(intErrorCode)..")")
	end
	return isOK
end -- function DoExecute

--[[
@function:		BuildDataRef
@description:	Get Full Data Reference for Pointer
@parameters:		Item Pointer
@returns:			Data Reference String, Record Id Integer, Record Type Tag String
@requires:		None
]]
function BuildDataRef(ptrRef)

	local strDataRef = ""										-- Data Reference with instance indices e.g. INDI.RESI[2].ADDR
	local intRecId   = 0										-- Record Id for associated Record
	local strRecTag  = ""										-- Record Tag of associated Record type i.e. INDI, FAM, NOTE, SOUR, etc

	-- getDataRef() is called recursively per level of the Data Ref
	-- ptrRef points to the upper Data Ref levels yet to be analysed
	-- strRef compiles the lower Data Ref levels including instances

	local function getDataRef(ptrRef,strRef)
		local ptrTag = ptrRef:Clone()
		local strTag = fhGetTag(ptrTag)						-- Current level Tag
		ptrTag:MoveToParentItem(ptrTag)
		if ptrTag:IsNotNull() then							-- Parent level exists
			local intSib = 1
			local ptrSib = ptrRef:Clone()					-- Pointer to siblings with same Tag
			ptrSib:MovePrev("SAME_TAG")
			while ptrSib:IsNotNull() do						-- Count previous siblings with same Tag
				intSib = intSib + 1
				ptrSib:MovePrev("SAME_TAG")
			end
			if intSib > 1 then 	strTag = strTag.."["..intSib.."]" end
			getDataRef(ptrTag,"."..strTag..strRef)			-- Now analyse the parent level
		else
			strDataRef = strTag..strRef						-- Record level reached, so set return values
			intRecId   = fhGetRecordId(ptrRef)
			strRecTag  = strTag
			if not fhIsValidDataRef(strDataRef) then print("BuildDataRef: "..strDataRef.." is Invalid") end
		end
	end -- local function getDataRef

	if type(ptrRef) == "userdata" then getDataRef(ptrRef,"") end

	return strDataRef, intRecId, strRecTag

end -- function BuildDataRef

--[[
@function:		GetDataRefPtr
@description:	Get Pointer for Full Data Reference
@parameters:		Data Reference String, Record Id Integer, Record Type Tag String (optional)
@returns:			Item Pointer which IsNull() if any parameters are invalid
@requires:		None
]]
function GetDataRefPtr(strDataRef,intRecId,strRecTag)
	strDataRef = strDataRef or ""
	if not strRecTag then
		strRecTag = strDataRef:gsub("^(%u+).*$","%1")	-- Extract Record Tag from Data Ref
	end
	local ptrRef = fhNewItemPtr()
	ptrRef:MoveToRecordById(strRecTag,intRecId or 0)	-- Lookup the Record by Id
	ptrRef:MoveTo(ptrRef,strDataRef)						-- Move to the Data Ref
	return ptrRef
end -- function GetDataRefPtr

function TblDataRef(ptrRef)
	local tblRef = {}
	tblRef.DataRef, tblRef.RecId, tblRef.RecTag = BuildDataRef(ptrRef)
	return tblRef
end -- function TblDataRef

function PtrDataRef(tblRef)
	local tblRef = tblRef or {}								-- Ensure table and its fields exist
	return GetDataRefPtr(tblRef.DataRef or "",tblRef.RecId or 0,tblRef.RecTag or "")
end -- function PtrDataRef

return fh

end -- local function general_v1

--[[
@Module:			fh.iterate_v1
@Author:			Mike Tate
@LastUpdated:	19 Oct 2013
@Version:			1.1
@Description:	An iterater functions module to supplement LUA functions.
@V1.0:				Initial version.
]]

local function iterate_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

-- Iterator for all records of one chosen type --
function Records(strType)
	local ptrAll = fhNewItemPtr()							-- Pointer to all records in turn
	local ptrRec = fhNewItemPtr()							-- Pointer to record returned to user
	ptrAll:MoveToFirstRecord(strType)
	return function ()
		ptrRec:MoveTo(ptrAll)
		ptrAll:MoveNext()
		if ptrRec:IsNotNull() then return ptrRec end
	end
end -- function Records

-- Iterator for all the record types --
function RecordTypes()
	local intNext = 0											-- Next record type number
	local intLast = fhGetRecordTypeCount()					-- Last record type number
	return function()
		intNext = intNext + 1
		if intNext <= intLast then
			return fhGetRecordTypeTag(intNext)				-- Return record type tag
		end
	end
end -- function RecordTypes

-- Iterator for all items in all records of chosen types --
function Items(...)
	local intType = 1											-- Integer record type number
	local tblType = {}											-- Table of record type tags
	local ptrNext = fhNewItemPtr()							-- Pointer to next item in turn
	local ptrItem = fhNewItemPtr()							-- Pointer to item returned to user

	if #arg == 0 then
		for intType = 1, fhGetRecordTypeCount() do		-- No parameters so use all record types
			tblType[intType] = fhGetRecordTypeTag(intType)
		end
	else
		tblType = arg											-- Got parameters so use them instead
	end
--	print(tblType[intType],intType)
	ptrNext:MoveToFirstRecord(tblType[intType])			-- Get first record of first type

	return function()
		repeat
			while ptrNext:IsNotNull() do						-- Loop through all items
				ptrItem:MoveTo(ptrNext)
				ptrNext:MoveNextSpecial()
				if ptrItem:IsNotNull() then return ptrItem end
			end
			intType = intType + 1								-- Loop through each record type
			if intType <= #tblType then
				ptrNext:MoveToFirstRecord(tblType[intType])
			end
		until intType > #tblType
	end
end -- function Items

-- Iterator for all facts of an individual --
function Facts(ptrIndi)
	local ptrItem = fhNewItemPtr()							-- Pointer to each item at level 1
	local ptrFact = fhNewItemPtr()							-- Pointer to each fact returned to user
	ptrItem:MoveToFirstChildItem(ptrIndi)
	return function ()
		while ptrItem:IsNotNull() do
			ptrFact:MoveTo(ptrItem)
			ptrItem:MoveNext()
			if fhIsFact(ptrFact) then return ptrFact end
		end
	end
end -- function Facts

return fh

end -- local function iterate_v1

--[[
@Module:			fh.progbar_v1
@Author:			Mike Tate
@LastUpdated:	30 Oct 2013
@Version:			1.1
@Description:	Progress Bar library module.
@V1.0:				Initial version.
]]

local function progbar_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

require "iuplua"												-- To access GUI window builder

local tblBars = {}												-- Table for optional external attributes
local strFont = nil												-- Font dialogue default is current font
local strStop = "255 0 0"										-- Stop button colour default is red
local strBack = "255 255 255"								-- Background colour default is white
local intPosX = iup.CENTER									-- Show window default position is central
local intPosY = iup.CENTER
local intMax, intVal, intPercent, intStart, intDelta, intScale, strClock, isBarStop
local lblText, barGauge, lblDelta, btnStop, dlgGauge

local function doFocus()										-- Bring the Progress Bar window into Focus
	dlgGauge.BringFront="YES"									-- If used too often, inhibits other windows scroll bars, etc
end -- local function doFocus

local function doUpdate()										-- Update the Progress Gauge and the Delta % with clock
	barGauge.Value = intVal
	lblDelta.Title = string.format("%4d %%      %s ",intPercent,strClock)
end -- local function doUpdate

local function doReset()										-- Reset all dialogue variables and Update display
	intVal		= 0													-- Current value of Progress Bar
	intPercent= 0.01											-- Percentage of progress
	intStart	= os.time()										-- Start time of progress
	intDelta	= 0													-- Delta time of progress
	intScale	= math.ceil( intMax / 1000 )					-- Scale of percentage per second of progress (initial guess is corrected in Step function)
	strClock	= "00 : 00 : 00"								-- Clock delta time display
	isBarStop	= false											-- Stop button pressed signal
	doUpdate()
	doFocus()
end -- local function doReset

function Start(strTitle,intMaximum)							-- Create & start Progress Bar window
	if not dlgGauge then
		strTitle	= strTitle or ""							-- Dialogue and button title
		intMax		= intMaximum or 100							-- Maximun range of Progress Bar, default is 100
		local strSize = tostring( math.max( 100, string.len(" Stop "..strTitle) * 8 ) ).."x30"			-- Adjust Stop button size to Title
		lblText	= iup.label	{ Title=" ", Expand="YES", Alignment="ACENTER", Tip="Progress Message" }
		barGauge	= iup.progressbar { RasterSize="400x30", Value=0, Max=intMax, Tip="Progress Bar" }
		lblDelta	= iup.label	{ Title=" ", Expand="YES", Alignment="ACENTER", Tip="Percentage and Elapsed Time" }
		btnStop	= iup.button	{ Title=" Stop "..strTitle, RasterSize=strSize, FgColor=strStop, Tip="Stop Progress Button", action=function() isBarStop = true end }	-- Signal Stop button pressed	return iup.CLOSE -- Often caused main GUI to close !!!
		dlgGauge	= iup.dialog	{ Title=strTitle.." Progress ", Font=strFont, Background=strBack, DialogFrame="YES",	-- Remove Windows minimize/maximize menu
							iup.vbox{ Alignment="ACENTER", Gap="10", Margin="10x10",
								lblText,
								barGauge,
								lblDelta,
								btnStop,
							},
							move_cb	= function(self,x,y) tblBars.X = x tblBars.Y = y end,
							close_cb	= btnStop.action,		-- Windows Close button = Stop button
						}
		if type(tblBars.GUI) == "table"
		and type(tblBars.GUI.ShowDialogue) == "function" then
			dlgGauge.move_cb = nil								-- Use GUI library to show & move window
			tblBars.GUI.ShowDialogue("Bars",dlgGauge,btnStop,"showxy")
		else
			dlgGauge:showxy(intPosX,intPosY)				-- Show the Progress Bar window
		end
		doReset()													-- Reset the Progress Bar display
	end
end -- function Start

function Message(strText)										-- Show the Progress Bar message
	if dlgGauge then lblText.Title = strText end
end -- function Message

function Step(intStep)											-- Step the Progress Bar forward
	if dlgGauge then
		intVal = intVal + ( intStep or 1 )					-- Default step is 1
		local intNew = math.ceil( intVal / intMax * 100 * intScale ) / intScale
		if intPercent ~= intNew then							-- Update progress once per percent or per second, whichever is smaller
			intPercent = math.max( 0.1, intNew )			-- Ensure percentage is greater than zero
			if intVal > intMax then intVal = intMax intPercent = 100 end		-- Ensure values do not exceed maximum
			intNew = os.difftime(os.time(),intStart)
			if intDelta < intNew then							-- Update clock of elapsed time
				intDelta = intNew
				intScale = math.ceil( intDelta / intPercent )	-- Scale of seconds per percentage step
				local intHour = math.floor( intDelta / 3600 )
				local intMins = math.floor( intDelta / 60 - intHour * 60 )
				local intSecs = intDelta - intMins * 60 - intHour * 3600
				strClock = string.format("%02d : %02d : %02d",intHour,intMins,intSecs)
			end
			doUpdate()											-- Update the Progress Bar display
		end
		iup.LoopStep()
	end
end -- function Step

function Focus()												-- Bring the Progress Bar window to front
	if dlgGauge then doFocus() end
end -- function Focus

function Reset()												-- Reset the Progress Bar display
	if dlgGauge then doReset() end
end -- function Reset

function Stop()													-- Check if Stop button pressed
	iup.LoopStep()
	return isBarStop
end -- function Stop

function Close()												-- Close the Progress Bar window
	isBarStop = false
	if dlgGauge then dlgGauge:destroy() dlgGauge = nil end
end -- function Close

function Setup(tblSetup)										-- Setup optional table of external attributes
	if tblSetup then
		tblBars = tblSetup
		strFont = tblBars.Font or strFont					-- Font dialogue
		strStop = tblBars.Stop or strStop					-- Stop button colour
		strBack = tblBars.Back or strBack					-- Background colour
		intPosX = tblBars.X or intPosX						-- Window position
		intPosY = tblBars.Y or intPosY
	end
end -- function Setup

return fh

end -- local function progbar_v1

--[[
@Title:			+fh+iup_gui_v1
@Author:			Mike Tate
@Version:			1.4
@LastUpdated:	12 Nov 2013
@Description:	Graphical User Interface Library Module
@V1.0:				Initial version.
]]

local function iup_gui_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}																		-- Local environment table
package.seeall(fh)																	-- Enable all globals
module(...,package.seeall)														-- Create matching module name
setfenv(1,fh)																		-- All public names are added to local fh table

require "iuplua"																	-- To access GUI window builder
require "iupluacontrols"															-- To access GUI window controls
require "lfs"																		-- To access LUA filing system
require "iupluaole"																	-- To access OLE subsystem
require "luacom"																	-- To access COM subsystem

local general = general_v1														-- To access FH general module
local stringx = stringx_v1														-- To access FH stringx module but cannot import

function ReportVersion()
	local strMessage = "This is +fh+iup_gui_v1"
	print(strMessage)
	return strMessage
end

-- Shared Interface Attributes & Functions --

Plugin		= fhGetContextInfo("CI_PLUGIN_NAME")								-- Plugin Name
Version	= " "																		-- Plugin Version
History	= Version																	-- Version History

Red			= "255 0 0"																-- Color attributes (must exclude leading zeros & spaces to allow value comparisons)
Maroon		= "128 0 0"
Amber		= "250 160 0"
Orange		= "255 165 0"
Yellow		= "255 255 0"
Olive		= "128 128 0"
Lime		= "0 255 0"
Green		= "0 128 0"
Cyan		= "0 255 255"
Teal		= "0 128 128"
Blue		= "0 0 255"
Navy		= "0 0 128"
Magenta	= "255 0 255"
Purple		= "128 0 128"
Black		= "0 0 0"
Gray		= "128 128 128"
Silver		= "192 192 192"
Smoke		= "240 240 240"
White		= "255 255 255"
Risk		= Red																		-- Risk colour for hazardous controls such as Close/Delete buttons
Warn		= Orange																	-- Warn colour for caution controls and warnings
Safe		= Green																	-- Safe colour for active controls such as most buttons
Info		= Black																	-- Info colour for text controls such as labels/tabs
Back		= White																	-- Background colour for all windows

Gap			= "8"																		-- Layout attributes Gap was "10"
Border		= "8x8"																	-- 	was BigMargin="10x10"
Margin		= "1x1"																	--	was MinMargin
Balloon	= "NO"																		-- Tooltip balloon mode

FontSet	=	1																		-- GUI font set assigned by FontAssignment but used globally
FontHead	= ""
FontBody	= ""

GUI = { }																				-- Sub-table for GUI Dialogue attributes to allow any "Name"

--[[
GUI.Name					table of dialogue attributes, where Name is Font, Help, Main, Memo, Bars, etc
GUI.Name.CoordX			x co-ordinate	( Loaded & Saved by default )
GUI.Name.CoordY			y co-ordinate	( Loaded & Saved by default )
GUI.Name.Dialog			dialogue handle
GUI.Name.Focus			focus button handle
GUI.Name.Frame			dialogframe mode, default "no" is dialogframe="NO" + showxy(), "showxy" is dialogframe="YES" + showxy(), "popup" or "keep" is dialogframe="NO" + popup()
GUI.Name.Height			height
GUI.Name.minsize 		minsize default
GUI.Name.MinSize		minsize			( NOT NOW Loaded & Saved by default )
GUI.Name.rastersize 	rastersize default
GUI.Name.Raster			rastersize		( Loaded & Saved by default )
GUI.Name.Width			width
GUI.Name.Back			ProgressBar background colour
GUI.Name.Font			ProgressBar font style
GUI.Name.Stop			ProgressBar Stop button colour
							Help dialogue Window attributes :-
GUI.Help.GetHelp 		Parent dialogue GetHelp button
GUI.Help.RootURL 		Wiki Help & Advice root URL
GUI.Help[n]				Help dialogue nth button :-
GUI.Help[n].Name		Name for title attribute
GUI.Help[n].Tip 		Tooltip for tip attribute
GUI.Help[n].URL 		Page URL to append to root URL 
GUI.Help[n].Page		Page order for intTabPosn
--]]

-- tblScrn[1] = origin x, tblScrn[2] = origin y, tblScrn[3] = width, tblScrn[4] = height
--x 	local tblScrn = iup.GetGlobal("VIRTUALSCREEN"):splitnumbers()
local tblScrn = stringx.splitnumbers(iup.GetGlobal("VIRTUALSCREEN"))	-- Used by CustomDialogue() and CheckWindowPosition() below
local intMaxW = tblScrn[3]
local intMaxH = tblScrn[4]

local function tblOfNames(...)													-- Get table of dialogue Names including "Font","Help","Main" by default
	local tblNames = {"Font","Help","Main"}
	for intName, strName in ipairs(arg) do
		if type(strName) == "string"
		and strName ~= "Font"
		and strName ~= "Help"
		and strName ~= "Main" then
			table.insert(tblNames,strName)
		end
	end
	return tblNames
end -- local function tblOfNames

local function tblNameFor(strName)												-- Get table of parameters for chosen dialogue Name
	strName = tostring(strName)
	if not GUI[strName] then														-- Need new table with default minimum & raster size, and X & Y co-ordinates
		GUI[strName] = { }
		local tblName = GUI[strName]
		tblName.MinSize = "x"
		tblName.Raster  = "x"
		tblName.CoordX  = iup.CENTER
		tblName.CoordY  = iup.CENTER
	end
	return GUI[strName]
end -- local function tblNameFor

local function intDimension(intMin,intVal,intMax)							-- Return a number bounded by intMin and intMax
	if not intVal then return 0 end												-- Except if no value then return 0
	intVal = tonumber(intVal) or (intMin+intMax)/2
	return math.max(intMin,math.min(intVal,intMax))
end -- local function intDimension

function CustomDialogue(strName,strMin,strRas,intX,intY)					-- GUI custom window minimum & raster size, and X & Y co-ordinates
	local tblName = tblNameFor(strName)
	local tblSize, intWide, intHigh
	if strMin then																	-- Ensure minimum size is between 200x200 and screen size
		tblSize = stringx.splitnumbers(strMin)
		intWide = intDimension(200,tblSize[1],intMaxW)
		intHigh = intDimension(200,tblSize[2],intMaxH)
		tblName.minsize = tostring(intWide.."x"..intHigh)
	end
	if strRas then																	-- Ensure raster size is between minimum and screen size
		tblSize = stringx.splitnumbers(strRas)
		intWide = intDimension(intWide,tblSize[1],intMaxW)
		intHigh = intDimension(intHigh,tblSize[2],intMaxH)
		tblName.rastersize = tostring(intWide.."x"..intHigh)
	end
	if intX then intX = intDimension(0,intX,intMaxW-intWide) end			-- Ensure X & Y co-ordinates position window on screen
	if intY then intY = intDimension(0,intY,intMaxH-intHigh) end
	tblName.MinSize = tblName.minsize		or "x"  -- was iup.NULL
	tblName.Raster  = tblName.rastersize	or "x"  -- was iup.NULL
	tblName.CoordX  = tonumber(intX)		or iup.CENTER
	tblName.CoordY  = tonumber(intY)		or iup.CENTER
end -- function CustomDialogue

function DefaultDialogue(...)													-- GUI default window minimum & raster size, and X & Y co-ordinates
	for intName, strName in ipairs(tblOfNames(...)) do
		CustomDialogue(strName)
	end
end -- function DefaultDialogue

function DialogueAttributes(strName)											-- Provide named Dialogue Attributes
	local tblName = tblNameFor(strName)											-- tblName.Dialog = dialog handle, so any other attributes could be retrieved
--x	local tblSize = (tblName.Raster or "x"):splitnumbers()					-- Split Raster Size into width=tblSize[1] and height=tblSize[2]
	local tblSize = stringx.splitnumbers(tblName.Raster or "x")			-- Split Raster Size into width=tblSize[1] and height=tblSize[2]
	tblName.Width  = tblSize[1]
	tblName.Height = tblSize[2]
	tblName.Font = FontBody														-- Following only needed for NewProgressBar
	tblName.Back = Back
	tblName.Stop = Risk
	tblName.GUI  = fh																-- Module table
	return tblName
end -- function DialogueAttributes

local tblLoadData = {}

function LoadLocal(strParam,strDefault)										-- Load Local Parameter for this PC
	return tblLoadData[ComputerName.."-"..strParam] or strDefault
end -- function LoadLocal

function LoadGlobal(strParam,strDefault)										-- Load Global Parameter for all PC
	return tblLoadData[strParam] or strDefault
end -- function LoadGlobal

function LoadDialogue(...)														-- Load Dialogue Parameters for "Font","Help","Main" by default
	for intName, strName in ipairs(tblOfNames(...)) do
		local tblName = tblNameFor(strName)
		tblName.Raster = tostring(LoadLocal(strName.."S",tblName.Raster))  -- Legacy of "S" becomes "R"
		tblName.Raster = tostring(LoadLocal(strName.."R",tblName.Raster))
		tblName.CoordX = tonumber(LoadLocal(strName.."X",tblName.CoordX))
		tblName.CoordY = tonumber(LoadLocal(strName.."Y",tblName.CoordY))
		CheckWindowPosition(tblName)
	end
end -- function LoadDialogue

function LoadSettings(...)														-- Load Sticky Settings from File
	local strFileName = StickyFile
	if general.FlgFileExists(strFileName) then								-- Load Settings File in table lines with key & val fields
		local tblField = {}
		for strLine in io.lines(strFileName) do
			if strLine == "return {"												-- Unless entire Sticky Data table was saved
			and type(table.load) == "function" then
				tblLoadData, StrErr = table.load(strFileName)				-- Load Settings File table
				break
			end
--x			tblField = strLine:split("=")
			tblField = stringx.split(strLine,"=")
			tblLoadData[tblField[1]] = tblField[2]
		end
		FontSet = tonumber(LoadGlobal("FontSet",FontSet))
		History = tostring(LoadGlobal("History",History))
	end
	LoadDialogue(...)
	FontAssignment(FontSet)
end -- function LoadSettings

local tblSaveData = {}

function SaveLocal(strParam,anyValue)											-- Save Local Parameter for this PC
	tblSaveData[ComputerName.."-"..strParam] = anyValue
end -- function SaveLocal

function SaveGlobal(strParam,anyValue)											-- Save Global Parameter for all PC
	tblSaveData[strParam] = anyValue
end -- function SaveGlobal

function SaveDialogue(...)														-- Save Dialogue Parameters for "Font","Help","Main" by default
	for intName, strName in ipairs(tblOfNames(...)) do
		local tblName = tblNameFor(strName)
		SaveLocal(strName.."R",tblName.Raster)
		SaveLocal(strName.."X",tblName.CoordX)
		SaveLocal(strName.."Y",tblName.CoordY)
	end
end -- function SaveDialogue

function SaveSettings(...)														-- Save Sticky Settings to File
	SaveDialogue(...)
	SaveGlobal("FontSet",FontSet)
	SaveGlobal("History",History)
	local strFileName = StickyFile
	if type(table.save) == "function" then										-- Save entire Settings File table
		table.save(tblSaveData,strFileName)
	else
		local fileHandle = general.OpenFile(strFileName,"w")				-- Else save Settings File lines with key & val fields
		for strKey,strVal in pairs(tblSaveData) do
			fileHandle:write(strKey.."="..strVal.."\n")
		end
		fileHandle:close()
	end
end -- function SaveSettings

function CheckWindowPosition(tblName)											-- Ensure dialogue window coordinates are on Screen
	if tonumber(tblName.CoordX) == nil
	or tonumber(tblName.CoordX) > intMaxW then
		tblName.CoordX = iup.CENTER
	end
	if tonumber(tblName.CoordY) == nil
	or tonumber(tblName.CoordY) > intMaxH then
		tblName.CoordY = iup.CENTER
	end
end -- function CheckWindowPosition

function IsNormalWindow(iupDialog)												-- Check dialogue window is not Maximised or Minimised
	-- tblPosn[1] = origin x, tblPosn[2] = origin y, tblPosn[3] = width, tblPosn[4] = height
--x 	local tblPosn = iupDialog.screenposition:splitnumbers()
	local tblPosn = stringx.splitnumbers(iupDialog.screenposition)
	local intPosX = tblPosn[1]
	local intPosY = tblPosn[2]
	if intPosX < 0 and intPosY < 0 then											-- If origin is negative (-8, -8 = Maximised, -3200, -3200 = Minimised)
		return false																	-- then is Maximised or Minimised
	end
	return true
end -- function IsNormalWindow

function ShowDialogue(strName,iupDialog,btnFocus,strFrame)				-- Set standard frame attributes and display dialogue window
	local tblName = tblNameFor(strName)
	iupDialog = iupDialog or tblName.Dialog									-- Retrieve previous parameters if needed
	btnFocus  = btnFocus  or tblName.Focus
	strFrame  = strFrame  or tblName.Frame
	strFrame  = strFrame  or "NO"												-- Default frame mode is dialog:showxy(X,Y) with dialogframe="NO"
	strFrame  = strFrame:lower()													-- Other modes are "show", "popup" & "keep" with dialogframe="YES"
	if strFrame:gsub("%s-%a-map%a*[%s%p]*","") == "" then					-- May be prefixed with "map" mode to just map dialogue initially
		strFrame = strFrame.." & no"
	end
	if type(iupDialog) == "userdata" then
		tblName.Dialog = iupDialog
		tblName.Focus  = btnFocus													-- Preserve parameters
		tblName.Frame  = strFrame
		iupDialog.Background = Back												-- Background colour
		iupDialog.Shrink = "YES"													-- Sometimes needed to shrink controls to raster size
		if type(btnFocus) == "userdata" then									-- Set button as focus for Esc and Enter keys
			iupDialog.StartFocus   = iupDialog.StartFocus   or btnFocus
			iupDialog.DefaultEsc   = iupDialog.DefaultEsc   or btnFocus
			iupDialog.DefaultEnter = iupDialog.DefaultEnter or btnFocus
		end
		iupDialog.MinSize    = tblName.MinSize or "x"						-- Minimum size (default "x" becomes nil)
		iupDialog.RasterSize = tblName.Raster  or "x"						-- Raster size  (default "x" becomes nil)
		if strFrame:match("no") then												-- The dialogframe mode is "NO" by default
			strFrame = strFrame.." & show"										-- Define display mode, and move & resize functions
			iupDialog.move_cb = iupDialog.move_cb or function(self,x,y) if IsNormalWindow(self) then tblName.CoordX=x tblName.CoordY=y end end
			iupDialog.resize_cb = iupDialog.resize_cb or function(self) if IsNormalWindow(self) then tblName.Raster=self.RasterSize end end
		else
			iupDialog.DialogFrame = "YES"										-- Define dialogframe mode, and move & resize function
			iupDialog.move_cb = iupDialog.move_cb or function(self,x,y) tblName.CoordX=x tblName.CoordY=y end
			iupDialog.resize_cb = iupDialog.resize_cb or function(self) tblName.Raster=self.RasterSize end
		end
		iupDialog.close_cb = iupDialog.close_cb or function() return iup.CLOSE end	-- Define default X Close action
		if strFrame:match("map") then											-- Only dialogue mapping is required
			iupDialog:map()
			tblName.Frame = strFrame:gsub("map","")							-- Remove "map" from frame mode ready for subsequent call
			return
		end
		if iup.MainLoopLevel() == 0												-- Called from outside Main GUI, so must use showxy() and not popup()
		or strFrame:match("sho") then											-- Use showxy() to dispay dialogue window for "showxy" mode
			iupDialog:showxy(tblName.CoordX,tblName.CoordY)
			if History ~= Version then											-- Initially show new Version History Help
				if type(HelpDialogue) == "function" then
					History = Version
					HelpDialogue(Version)											-- But only after Help dialogue exists
					iupDialog.BringFront = "YES"
				end
			end
			if strName ~= "Help" and iup.MainLoopLevel() == 0 then iup.MainLoop() end
		else
			iupDialog:popup(tblName.CoordX,tblName.CoordY)					-- Use popup() to display dialogue window for "popup" or "keep" modes
		end
		if strFrame:match("pop") then
			tblName.Dialog = nil													-- When popup closed, clear key parameters, but not for "keep" mode
			tblName.Raster = nil
		end
--x		local tblPosn = iupDialog.ScreenPosition:splitnumbers()
		local tblPosn = stringx.splitnumbers(iupDialog.ScreenPosition)	-- Ensure X & Y coordinates are raster values
		tblName.CoordX = tblPosn[1]
		tblName.CoordY = tblPosn[2]
	end
end -- function ShowDialogue

-- Font Dialogue Attributes and Functions --

local intFontPlain  = 1															-- Font Face & Style values for FontSet in Font... functions
local intFontBold   = 2
local intArialPlain = 3
local intArialBold  = 4
local intTahomaPlain= 5
local intTahomaBold = 6
local intUserPlain  = 7
local intUserBold   = 8
local strUserFont   = iup.GetGlobal("DEFAULTFONT")
local strUserHead   = strUserFont:gsub(",(%D+)(%d+)",",%112")
local strUserBold   = strUserFont:gsub(", ",", Bold ")
local strFontFace   = strUserFont:gsub(",.*","")

local tblFontSet = {}																-- Lookup table for FontHead and FontBody in Font... functions
tblFontSet[intFontPlain]		=	{ Head=strFontFace..", Bold -16",	Body=strFontFace..",      -16", }
tblFontSet[intFontBold]		=	{ Head=strFontFace..", Bold -16",	Body=strFontFace..", Bold -15", }
tblFontSet[intArialPlain]		=	{ Head="Arial,         Bold -16",	Body="Arial,              -16", }
tblFontSet[intArialBold]		=	{ Head="Arial,         Bold -16",	Body="Arial,         Bold -15", }
tblFontSet[intTahomaPlain]	=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,             -16", }
tblFontSet[intTahomaBold]		=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,        Bold -14", }
tblFontSet[intUserPlain]		=	{ Head=strUserHead					,	Body=strUserFont				 , }
tblFontSet[intUserBold]		=	{ Head=strUserBold					,	Body=strUserFont				 , }
-- Note: Pixel sizes -21 = -20 & -17 = -16 & -14 = -13 and pixel sizes -22, -18 & -13 have no point size equivalent.

function FontAssignment(intFontSet)												-- Assign Font Face & Style GUI values
	FontSet  = intFontSet
	FontHead = tblFontSet[intFontSet]["Head"]									-- Font for all GUI dialog header text
	FontBody = tblFontSet[intFontSet]["Body"]									-- Font for all GUI dialog body text
	local tblHelp = tblNameFor("Help")
	if type(tblHelp.Dialog) == "userdata" then
		tblHelp.Dialog.Font = FontBody											-- Update Help dialogue font if it exists
	end
end -- function FontAssignment

function FontDialogue()															-- GUI Font Face & Style Dialogue

	local isFontChosen = true

	local strFontPlainTitle	= strFontFace.." Plain"
	local strFontBoldTitle 	= strFontFace.." Bold"
	local strArialPlainTitle	= "Arial Plain"
	local strArialBoldTitle	= "Arial Bold"
	local strTahomaPlainTitle	= "Tahoma Plain"
	local strTahomaBoldTitle	= "Tahoma Bold"
	local strUserPlainTitle	= "Default Plain"
	local strUserBoldTitle 	= "Default Bold"

	-- Create each GUI label and button with title and tooltip
	local lblHeadName		= iup.label	{ Title=" Name :"				, Tip="Names of the available Fonts"				, }
	local lblHeadPlain		= iup.label	{ Title=" Plain :"				, Tip="Plain versions of the Fonts"					, }
	local lblHeadBold		= iup.label	{ Title=" Bold :"				, Tip="Bold versions of the Fonts"					, }
	local lblFontName		= iup.label	{ Title="Font "..strFontFace	, Tip="Windows default but larger font"			, }
	local btnFontPlain		= iup.button	{ Title=strFontPlainTitle		, Tip="Choose "..strFontPlainTitle.." style"		, }
	local btnFontBold		= iup.button	{ Title=strFontBoldTitle		, Tip="Choose "..strFontBoldTitle.." style"		, }
	local lblArialName		= iup.label	{ Title="Font Arial"			, Tip="Arial alternative fontface"					, }
	local btnArialPlain		= iup.button	{ Title=strArialPlainTitle	, Tip="Choose "..strArialPlainTitle.." style"	, }
	local btnArialBold		= iup.button	{ Title=strArialBoldTitle		, Tip="Choose "..strArialBoldTitle.." style"		, }
	local lblTahomaName		= iup.label	{ Title="Font Tahoma"			, Tip="Tahoma alternative fontface"					, }
	local btnTahomaPlain	= iup.button	{ Title=strTahomaPlainTitle	, Tip="Choose "..strTahomaPlainTitle.." style"	, }
	local btnTahomaBold		= iup.button	{ Title=strTahomaBoldTitle	, Tip="Choose "..strTahomaBoldTitle.." style"	, }
	local lblUserName		= iup.label	{ Title="Font Default"			, Tip="Windows default user font"					, }
	local btnUserPlain		= iup.button	{ Title=strUserPlainTitle		, Tip="Choose "..strUserPlainTitle.." style"		, }
	local btnUserBold		= iup.button	{ Title=strUserBoldTitle		, Tip="Choose "..strUserBoldTitle.." style"		, }
	local lblChoose 		= iup.label	{ Title="Choose your window font style or"											, }
	local btnDestroy		= iup.button	{ Title="Close"					, Tip="Close this Font Style window"				, }

	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local	dialogFont		= iup.dialog { Title=Plugin.." Font Style",
										iup.vbox { Alignment="ACENTER", Gap=Gap, Margin=Border,
											iup.frame { Font=FontHead, FgColor=Info, Active="YES", Title="Font Style",
												iup.vbox { Margin=Margin,
													iup.hbox { Homogeneous="YES", lblHeadName,	lblHeadPlain,	lblHeadBold,		},
													iup.hbox { Homogeneous="YES", lblFontName,	btnFontPlain,	btnFontBold,		},
													iup.hbox { Homogeneous="YES", lblArialName,	btnArialPlain,	btnArialBold,	},
													iup.hbox { Homogeneous="YES", lblTahomaName,	btnTahomaPlain,	btnTahomaBold,	},
													iup.hbox { Homogeneous="YES", lblUserName,	btnUserPlain,	btnUserBold,		},
													iup.hbox { lblChoose, btnDestroy, },
												},
											},
										},
										close_cb = function() isFontChosen=false return iup.CLOSE end,
									}

	-- Assign font styles for GUI labels and buttons
	local strFontPlain		= tblFontSet	[intFontPlain]	["Body"]
	local strFontBold		= tblFontSet	[intFontBold]	["Body"]
	local strArialPlain		= tblFontSet	[intArialPlain]	["Body"]
	local strArialBold		= tblFontSet	[intArialBold]	["Body"]
	local strTahomaPlain	= tblFontSet	[intTahomaPlain]["Body"]
	local strTahomaBold		= tblFontSet	[intTahomaBold]	["Body"]
	local strUserPlain		= tblFontSet	[intUserPlain]	["Body"]
	local strUserBold		= tblFontSet	[intUserBold]	["Head"]

	-- Set other GUI attributes for labels and buttons
	for iupName, tblAttr in pairs( {
		--	Control		= 1~FgColor	, 2~Font		, 3~FontSet		, 4~action function()
		[lblHeadName]	= { Info	, FontBody		, false			, false	},
		[lblHeadPlain]	= { Info	, strFontPlain	, false			, false	},
		[lblHeadBold]	= { Info	, strFontBold	, false			, false	},
		[lblFontName]	= { Info	, strFontPlain	, false			, false	},
		[btnFontPlain]	= { Safe	, strFontPlain	, intFontPlain	, false	},
		[btnFontBold]	= { Safe	, strFontBold	, intFontBold	, false	},
		[lblArialName]	= { Info	, strArialPlain	, false			, false	},
		[btnArialPlain]	= { Safe	, strArialPlain	, intArialPlain	, false	},
		[btnArialBold]	= { Safe	, strArialBold	, intArialBold	, false	},
		[lblTahomaName]	= { Info	, strTahomaPlain, false			, false	},
		[btnTahomaPlain]= { Safe	, strTahomaPlain, intTahomaPlain, false	},
		[btnTahomaBold]	= { Safe	, strTahomaBold	, intTahomaBold	, false	},
		[lblUserName]	= { Info	, strUserPlain	, false			, false	},
		[btnUserPlain]	= { Safe	, strUserPlain	, intUserPlain	, false	},
		[btnUserBold]	= { Safe	, strUserBold	, intUserBold	, false	},
		[lblChoose]		= { Info	, FontBody		, false			, false	},
		[btnDestroy]		= { Risk	, FontBody		, false			, dialogFont.close_cb },
		} ) do
		iupName.TipBalloon	= Balloon
		iupName.Expand	= "YES"
		iupName.FgColor	= tblAttr[1]
		iupName.Font		= tblAttr[2]
		if tblAttr[3] then
			if tblAttr[3] == FontSet then iupName.Active = "NO" end		-- Disable button for currently selected font
			iupName.action = function() FontAssignment(tblAttr[3]) return iup.CLOSE end
		end
		if tblAttr[4] then iupName.action = tblAttr[4] end
	end

	ShowDialogue("Font",dialogFont,btnDestroy,"popup")

	return isFontChosen
end -- function FontDialogue

-- Help Dialogue Attributes and Functions

HelpDialogue = ""																	-- HelpDialogue must be declared for ShowDialogue

local strHelpButtonActive = nil  -- defaults to "YES"						-- Help button active attribute mode used only in NewHelpDialogue

function NewHelpDialogue(btnGetHelp,strRootURL)								-- Prototype for GUI Help Dialogue, with parent Help button, and web page root/namespace URL
	local tblHelp = tblNameFor("Help")
	local oleControl, btnDestroy, hboxHelp, dialogHelp						-- Dialogue component upvalues
	if type(btnGetHelp) == "userdata" then
		btnGetHelp.Active = strHelpButtonActive
		if btnGetHelp.Active == "NO" then										-- Help button inactive, so Help dialogue exists, so just update parent button
			tblHelp.GetHelp = btnGetHelp											-- Allows successive parent GUI to share one Help dialogue
			return
		end
	end
	tblHelp.GetHelp = btnGetHelp
	strRootURL = strRootURL or Plugin:gsub(" ","_"):lower()				-- Default to Plugin name as Wiki namespace
	if strRootURL:match("^[%w_]+$") then										-- Append Wiki namespace to Wiki root URL
		strRootURL = "http://www.fhug.org.uk/wiki/doku.php?id=plugins:help:"..strRootURL..":"
	end
	tblHelp.RootURL = strRootURL
	local intURL = 1																-- Index to Version History help page URL
	local tblURL = { }																-- List of help page URL

	local function doCommonAction()												-- Common action when creating/destroying Help dialogue
		local strMode = "NO"
		if dialogHelp then
			dialogHelp:destroy()													-- If dialogue exists then destroy window
			dialogHelp = nil
			tblHelp.Dialog = nil													-- Also clear dialog handle
			strMode = nil -- defaults to "YES"
		end 
		if type(tblHelp.GetHelp) == "userdata" then							-- Set parent dialogue Help button active mode
			tblHelp.GetHelp.Active = strMode
		end
		strHelpButtonActive = strMode
	end -- local function doCommonAction

	function HelpDialogue(anyPage)												-- GUI Help Dialogue for chosen web page
		--[=[
			Parameter anyPage can be one of several values:
			1. Page number from 0 to index tblURL, often equal to intTabPosn.
			2. Version to display Version History page for version chosen.
			3. String with " "="_" and lowercase substring of a page name in tblURL.
		--]=]

		if not dialogHelp then
			doCommonAction()
			-- Create the WebBrowser based on its ProgID and connect it to LuaCOM
			oleControl = iup.olecontrol{ "Shell.Explorer.1", designmode="NO", }
			oleControl:CreateLuaCOM()
			btnDestroy = iup.button { Title="Close Window", Tip="Close this Help and Advice window", TipBalloon=Balloon, Expand="HORIZONTAL", Size="x10", FgColor=Risk, action=function() doCommonAction() end }
			hboxHelp = iup.hbox { margin=Margin, homogeneous="NO" }
			-- Create each GUI button with title, tooltip, color, action, etc, and table of web page URL
			for intButton, tblButton in ipairs(tblHelp) do
				local intPage = tblButton.Page or intButton
				local strURL  = tblButton.URL
				if strURL:match("ver.-hist") then intURL = intPage end
				tblURL[intPage] = strURL
				local btnName = iup.button { Title=tblButton.Name, Tip=tblButton.Tip, TipBalloon=Balloon, Expand=btnDestroy.Expand, Size=btnDestroy.Size, FgColor=Safe, action=function() oleControl.com:Navigate(tblHelp.RootURL..strURL) end }
				iup.Append(hboxHelp,btnName)
			end
			iup.Append(hboxHelp,btnDestroy)
			dialogHelp = iup.dialog { Title=Plugin.." Help & Advice", Font=FontBody,
								iup.vbox { Alignment="ACENTER", Gap=Gap, Margin=Border, ExpandChildren="YES",
									oleControl,
									hboxHelp,
								},
								close_cb = function() doCommonAction() end,
							}
			ShowDialogue("Help",dialogHelp,btnDestroy)						-- Show Help dialogue window
		end
		anyPage = anyPage or 0
		if type(anyPage) == "number" then										-- Select page by Tab = Button = Help page index
			anyPage = math.max(1,math.min(#tblURL,anyPage+1))
			anyPage = tblURL[anyPage] or ""
		elseif anyPage == Version then											-- Select the Version History features section
			anyPage = anyPage:gsub("[%s%p]","")
			anyPage = anyPage:gsub("^(%d)","V%1")
			anyPage = tblURL[intURL].."#features_of_"..anyPage
		elseif type(anyPage) == "string" then									-- Select page by matching name text
			local strPage = anyPage:gsub(" ","_"):lower()
			anyPage = tblURL[1] or ""												-- Default to first web page
			for intURL = 1, #tblURL do
				local strURL = tblURL[intURL]
				if strURL:match(strPage) then
					anyPage = strURL
					break
				end
			end
		else
			anyPage = tblURL[1] or ""												-- Default to first web page
		end
		oleControl.com:Navigate(tblHelp.RootURL..anyPage)					-- Navigate to chosen web page
	end -- function HelpDialogue

end -- function NewHelpDialogue

function AddHelpButton(strName,strTip,strURL,intPage)						-- Add button to GUI Help Dialogue
	local tblHelp = tblNameFor("Help")
	if tblHelp and not strHelpButtonActive then
		for intHelp, tblHelp in ipairs(tblHelp) do							-- Check button does not already exist
			if tblHelp.Name == strName then return end
		end
		if tonumber(intPage) then intPage = intPage + 1 end					-- Optional external intPage number matches intTabPosn
		table.insert( tblHelp, { Name=strName, Tip=strTip, URL=strURL, Page=intPage } )
	end
end -- function AddHelpButton

local function anyMemoControl(anyName,fgColor)								-- Compose any control Title and FgColor
	local strName = tostring(anyName)											-- anyName may be a string, and fgColor is default FgColor
	local tipText = nil
	if type(anyName) == "table" then											-- anyName may be a table = { Title string , FgColor string , ToolTip string (optional) }
		strName = anyName[1]
		fgColor = anyName[2]:match("%d* %d* %d*") or fgColor
		tipText = anyName[3]
	end
	return strName, fgColor, tipText
end -- local function anyMemoControl

local function anyMemoDialogue(anyHead,anyMemo,...)							-- Display framed memo dialogue with buttons
	local intButt = 0																-- Returned value if "X Close" button is used
	local tblButt = { [0]="X Close" }											-- Button names lookup table
	if not anyHead then anyHead = "" end
	local strHead, fgcHead, tipHead = anyMemoControl(anyHead,Info)
	local strMemo, fgcMemo, tipMemo = anyMemoControl(anyMemo,Info)
	-- Create the GUI labels and buttons
	local lblMemo = iup.label { Title=strMemo, FgColor=fgcMemo, Tip=tipMemo, TipBalloon=Balloon, Alignment="ACENTER", Padding=Margin, Expand="YES", WordWrap="YES" }
	local lblLine = iup.label { Separator="HORIZONTAL" }
	local iupHbox = iup.hbox  { Homogeneous="YES" }
	local btnButt = iup.button { }
	if #arg == 0 then arg[1] = "OK" end											-- If no buttons listed then default to an "OK" button
	for intArg, anyButt in ipairs(arg) do
		local strButt, fgcButt, tipButt = anyMemoControl(anyButt,Safe)
		tblButt[intArg] = strButt
		btnButt = iup.button { Title=strButt, FgColor=fgcButt, Tip=tipButt, TipBalloon=Balloon, Expand="NO", MinSize="80", Padding=Margin, action=function() intButt=intArg return iup.CLOSE end }
		iup.Append( iupHbox, btnButt )
	end
	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local iupMemo = iup.dialog { Title=Plugin..Version..strHead,
							iup.vbox { Alignment="ACENTER", Gap=Gap, Margin=Margin,
								iup.frame { Title=strHead, FgColor=fgcHead, Font=FontHead,
									iup.vbox { Alignment="ACENTER", Font=FontBody, lblMemo, lblLine, iupHbox },
								},
							},
						}
	ShowDialogue("Memo",iupMemo,btnButt,"popup")								-- Show popup Memo dialogue window with righthand button in focus
	iupMemo:destroy()
	return intButt, tblButt[intButt]
end -- local function anyMemoDialogue

function MemoDialogue(anyMemo,...)												-- Multi-Button GUI like iup.Alarm and fhMessageBox, with "Memo" in frame
	return anyMemoDialogue("Memo",anyMemo,...)
end -- function MemoDialogue

function WarnDialogue(anyHead,anyMemo,...)									-- Multi-Button GUI like iup.Alarm and fhMessageBox, with heading in frame
	return anyMemoDialogue(anyHead,anyMemo,...)
end -- function WarnDialogue

function VersionInStore(anyPlugin)												-- Obtain the Version in Plugin Store by Name or Id
	local strType = "name="
	if type(anyPlugin) == "number"
	or tonumber(anyPlugin) then strType = "id=" end
	if anyPlugin then
		local http = luacom.CreateObject("winhttp.winhttprequest.5.1")
		local strRequest ="http://www.family-historian.co.uk/lnk/checkpluginversion.php?"..strType..anyPlugin
 		http:Open("GET",strRequest,false)
		http:Send()
		local strReturn = http.Responsebody
		local strVersion = "0"
		if strReturn ~= nil then
			strVersion = strReturn:match("([%d%.]*),%d*")					-- Version digits & dots then comma and Id digits 
		end
		return strVersion or "0"
	else
		return "0"
	end
end -- function VersionInStore

local function intVersion(strVersion)											-- Convert version string to comparable integer
	local intVersion = 0
--x	local tblVersion = strVersion:split(".")
	local tblVersion = stringx.split(strVersion,".")
	for i=1,5 do
		intVersion = intVersion * 1000 + tonumber(tblVersion[i] or 0)
	end
	return intVersion
end -- local function intVersion

function CheckVersionInStore()													-- Check if later Version available in Plugin Store
	local strPlugin = fhGetContextInfo("CI_PLUGIN_NAME")
	local strNewVer = VersionInStore(strPlugin:gsub(" %- .*",""))
	local strOldVer = Version
	if intVersion(strNewVer) > intVersion(strOldVer:match("%D*([%d%.]*)")) then
		MemoDialogue( "Later Version "..strNewVer.." of this Plugin is available from the Family Historian 'Plugin Store'.", "OK" )
	end
end -- function CheckVersionInStore

function Initialise(strVersion,strPlugin)										-- Initialise the GUI module with optional Version & Plugin name

	local strAppData = fhGetContextInfo("CI_APP_DATA_FOLDER")
	Plugin = fhGetContextInfo("CI_PLUGIN_NAME")								-- Plugin Name from file
	Version = strVersion or " "													-- Plugin Version
	if Version == " " then
		local strTitle = "\n@Title is missing"
		local strAuthor = "\n@Author is missing"
		local strVersion = "\n@Version is missing"
		local strPlugin = strAppData.."\\Plugins\\"..Plugin..".fh_lua"
		for strLine in io.lines(strPlugin) do									-- Read each line from the Plugin file
			strPlugin = strLine:match("^@Title:%s*(.*)")
			if strPlugin then
				strPlugin = strPlugin:gsub("&&","&")
				if Plugin:match("^"..strPlugin:gsub("(%W)","%%%1")) then
					Plugin = strPlugin												-- Prefer Title to Filename if it matches
					strTitle = nil
				else
					strTitle = "\n@Title differs from Filename"				-- Report abnormality
				end
			end
			if strLine:match("^@Author:%s*(.*)") then							-- Check @Author exists
				strAuthor = nil
			end 
			Version = strLine:gsub("^@Version:%D*([%d%.]*)%D*"," %1 ")
			if Version ~= strLine then											-- Obtain the @Version from Plugin file
				strVersion = nil
				break
			end
		end
		if strTitle or strAuthor or strVersion then							-- Report any header abnormalities
			fhMessageBox("\nScript Header: "..Plugin..(strTitle or "")..(strAuthor or "")..(strVersion or ""))
		end
	end
	History = Version																-- Version History
	Plugin  = strPlugin or Plugin												-- Plugin Name from argument or default from file

	CustomDialogue("Help","800x600","1030x730")								-- Custom "Help" dialogue sizes

	DefaultDialogue()																-- Default "Font","Help","Main" dialogues

	FontAssignment(intFontPlain)													-- Assign default Font Face & Style

	-- File System & Sticky Data Names & Functions --

	local strStickyFile = fhGetPluginDataFileName()
	-- Allow plugins with variant filenames to use same plugin data files
	strStickyFile = strStickyFile:gsub("\\"..Plugin:gsub(" ","_"):lower(),"\\"..Plugin)
	strStickyFile = strStickyFile:gsub("\\"..Plugin..".+%.[D,d][A,a][T,t]$","\\"..Plugin..".dat")
	if strStickyFile == "" then
		-- Use standalone GEDCOM path & filename..".fh_data\Plugin Data\" as the folder + the Plugin Filename..".dat"
		strStickyFile = fhGetContextInfo("CI_GEDCOM_FILE")
		strStickyFile = strStickyFile:gsub("%.[G,g][E,e][D,d]",".fh_data")
		lfs.mkdir(strStickyFile)
		strStickyFile = strStickyFile.."\\Plugin Data"
		lfs.mkdir(strStickyFile)
		strStickyFile = strStickyFile.."\\"..Plugin..".dat"
	end

	-- Sticky File name for saving parameters
	StickyFile = strStickyFile

	-- Plugin data folder path name
	PluginPath = StickyFile:gsub("\\"..Plugin.."%.[D,d][A,a][T,t]$","")

	-- Plugin data file root name
	PluginRoot = PluginPath.."\\"..Plugin

	-- Public data folder path name
	PublicPath = fhGetContextInfo("CI_PROJECT_PUBLIC_FOLDER")
	if PublicPath == "" then PublicPath = PluginPath end

	-- Program Data Calico Pie path name
	CalicoPie = strAppData:gsub("\\Calico Pie\\.*","\\Calico Pie")

	-- Local PC Computer Name
	ComputerName = os.getenv("COMPUTERNAME")

end -- function Initialise

Initialise()		-- Initialise module with default values

return fh

end -- local function iup_gui_v1

stringx_v1 = stringx_v1("stringx")
tablex_v1  = tablex_v1 ("tablex")
general_v1 = general_v1("general")
iterate_v1 = iterate_v1("iterate")
progbar_v1 = progbar_v1("progbar")
iup_gui_v1 = iup_gui_v1("iup_gui")

-- All above should eventually become library modules as loaded below --

--]==]

--[==[
local fhLoadRequire = require("fhLoadRequire").fhLoadRequire				-- Interim fhLoadRequire() API

if not fhLoadRequire("pl","pl.init") then return end						-- Load required Penlight modules
require("pl.import_into")()
require("pl.strict")																-- Strict check for undeclared globals

if not fhLoadRequire("fh.library_v2") then return end 						-- Load required FH v2 modules
require("fh.modules_v2")()
--]==]
stringx_v1.import()																	-- To access FH string extension v1 module
tablex_v1.import()																	-- To access FH table extension v1 module
local general = general_v1														-- To access FH general useful v1 module
local iterate = iterate_v1														-- To access FH iterate items v1 module
local progbar = progbar_v1														-- To access FH progress bar v1 module including "iuplua"
local iup_gui = iup_gui_v1														-- To access FH GUI builder v1 module including "iuplua", "lfs", "fh.general_v1" & "fh.loadreq_v1", "fh.stringx_v1", etc

-- Preset Global Data Definitions --
function PresetGlobalData()
	iup_gui.Gap = "2"
	iup_gui.Balloon = "YES"
--	iup_gui.CustomDialogue("Main","800x590","1000x650")						-- Main dialogue minimum and raster size
	iup_gui.CustomDialogue("Main","750x450","820x550")						-- Main dialogue minimum and raster size
	TblOption = {}																	-- Table of GUI options
	TblOption.Set = {}																-- Non-toggle option settings are in Set sub-table
	TblOption.Lst = {}																-- All dropdown list settings are in Lst sub-table
	TblOption.Tgl = {}																-- All toggle ON/OFF settings are in Tgl sub-table
	TblRecord   = {}																-- Result Set tables
	TblDataRef  = {}
	TblOldValue = {}
	TblNewValue = {}
end -- function PresetGlobalData

-- Reset Sticky Settings to Default Values --
function ResetDefaultSettings()
	iup_gui.DefaultDialogue("Bars","Memo")										-- GUI window position X & Y co-ordinates, and minsize & rastersize for "Main","Font","Help","Bars","Memo" dialogues
	iup_gui.History		= " "														-- Version History reset for initial Help
																						-- GUI Modes are mixed case, Classes are lower case, Tags are upper case
	TblOption.Set.Item	=	0														-- Item count of database size
	TblOption.Set.Date	=	""														-- Date of last Item update
	TblOption.Set.Seek	=	""														-- Search text string empty
	TblOption.Set.Swap	=	""														-- Replace text string empty
	for strName, anyValue in pairs ( TblOption.Lst ) do
		TblOption.Lst[strName] = ""												-- Reset all GUI dropdown lists associated with toggles
	end
	for strName, anyValue in pairs ( TblOption.Tgl ) do
		TblOption.Tgl[strName] = "ON"											-- Enable all GUI toggle options except as below
	end
	TblOption.Tgl.Conf			= "ON"												-- V2.1 Ensure Confirmation toggle is ticked
	TblOption.Tgl["SOUR.TITL"]= "OFF"											-- V1.7 Parent Child Tag for Source Titles
	TblOption.Tgl.age			= "OFF"											-- V1.7 Class age is just the Age fields
	TblOption.Tgl.Age			= "OFF"											-- V2.1 Age field error checks
	TblOption.Tgl.date			= "OFF"											-- V1.7 Class date is all the Date fields
	TblOption.Tgl.Date			= "OFF"											-- V1.7 Date field warnings
end -- function ResetDefaultSettings

-- Load Sticky Settings from File --
function LoadSettings()
	iup_gui.LoadSettings("Bars")													-- Includes "Main","Font","Help" dialogues and "FontSet" & "History"
	TblOption = iup_gui.LoadGlobal("Option",TblOption)
	if not TblOption.Set then TblOption.Set = {} end						-- Cope with legacy settings
	if not TblOption.Lst then TblOption.Lst = {} end
	TblOption.Tgl.Conf			= TblOption.Tgl.Conf or "ON"					-- V2.1 Ensure Confirmation toggle is ticked
	TblOption.Tgl["SOUR.TITL"]= TblOption.Tgl["SOUR.TITL"] or "OFF"		-- V1.7 Parent Child Tag for Source Titles
	TblOption.Tgl.age			= TblOption.Tgl.age  or "OFF"				-- V1.7 Class age is just the Age fields
	TblOption.Tgl.Age			= TblOption.Tgl.Age  or "OFF"				-- V2.1 Age field error checks
	TblOption.Tgl.date			= TblOption.Tgl.date or "OFF"				-- V1.7 Class date is all the Date fields
	TblOption.Tgl.Date			= TblOption.Tgl.Date or "OFF"				-- V1.7 Date field warnings
	SaveSettings()																	-- Save sticky data settings
end -- function LoadSettings

-- Save Sticky Settings to File --
function SaveSettings()
	local datToday = fhNewDate(2000)
	datToday:SetSimpleDate(fhCallBuiltInFunction("Today"))					-- Obtain date today
	local strToday = datToday:GetDisplayText("ABBREV")
	if TblOption.Set.Date ~= strToday then										-- Different date so recalculate database size
		TblOption.Set.Date = strToday
		local intItem = 0
		for ptrItem in iterate.Items() do
			intItem = intItem + 1													-- Count number of database items
		end
		TblOption.Set.Item = intItem
	end
	iup_gui.SaveGlobal("Option",TblOption)
	iup_gui.SaveSettings()															-- Includes "Main","Font","Help" dialogues and "FontSet" & "History"
end -- function SaveSettings

-- Make New Help Dialogue from Prototype --
function MakeHelpDialogue(btnGetHelp)
	iup_gui.NewHelpDialogue(btnGetHelp)											-- Supply control Help button with alphabetically ordered page names
	iup_gui.AddHelpButton("Introduction"		, "Introduction for Help and Advice"	, "search_and_replace"	)
	iup_gui.AddHelpButton("User Options"		, "Option settings Help and Advice"		, "options"			)
	iup_gui.AddHelpButton("Confirmation"		, "Confirmation popup Help and Advice"	, "popupconf"		)
	iup_gui.AddHelpButton("Result Set"			, "Result Set list Help and Advice"		, "result_set"		)
	iup_gui.AddHelpButton("Usage Examples"		, "Usage examples Help and Advice"		, "usage_examples"	)
	iup_gui.AddHelpButton("Version History"	, "Version History of Features"			, "version_history"	)
end -- function MakeHelpDialogue

function StrAgeWarning(ptrItem,strNewAge)
	if #strNewAge > 0 and TblOption.Set.Mode == "Replace" then			-- No age error checks unless Age Item exists in Replace mode
		local strOldAge = fhGetValueAsText(ptrItem)
		if TblOption.Tgl.Age then
			fhSetValueAsText(ptrItem,strNewAge)									-- Check for invalid Age returning blank
			local strWarning = fhGetValueAsText(ptrItem)
			fhSetValueAsText(ptrItem,strOldAge)									-- Restore the original Age value
			if strWarning == "" then
				return " ! ! BEWARE ! !     Replacement age is invalid. \n The field will be DELETED if 'Replace' is confirmed. ",strNewAge
			else
				return nil,strWarning												-- Otherwise, return nil warning with corrected Age text
			end
		end
	end
	return nil,strNewAge									  						-- For OK values or no warning return nil, and original text
end -- function StrAgeWarning

function StrDateWarning(ptrItem,strNewVal)
	if #strNewVal > 0 and TblOption.Set.Mode == "Replace" then			-- No date warnings unless Date Item exists in Replace mode
		local oldDate = fhGetValueAsDate(ptrItem)
		local newDate = fhNewDate(1999)							  				-- For "date" value type use Date Object
		local isOK = newDate:SetValueAsText(strNewVal,false)
		if isOK then
			if TblOption.Tgl.Date then
				fhSetValueAsDate(ptrItem,newDate)								-- Check for invalid Date warnings
				local strWarning = fhCallBuiltInFunction("GetDataWarning",ptrItem,1)
				fhSetValueAsDate(ptrItem,oldDate)								-- Restore the original Date value
				if strWarning ~= "" then
					return " ! ! BEWARE ! !     Replacement date is inconsistent. \n "..strWarning.." \n It will be set anyway if 'Replace' is confirmed. "
				end
			end
		else
			return " ! ! BEWARE ! !     Replacement date is invalid. \n It will be set as a Date Phrase if 'Replace' is confirmed. "
		end
	end
	return nil									  									-- For OK values or no warning return nil
end -- function StrDateWarning

-- Search & Replace Prompt GUI --
function SearchReplacePrompt(ptrItem,strOldVal,strNewVal,strWarning)
	-- ptrItem:		Pointer to data item
	-- strOldVal:	Old value of data item
	-- strNewVal:	New value for data item
	-- strWarning:	Warning message for Age/Date value

	local function intLineCount(strText,maxLines)
		--[[
		@Function:	intLineCount
		@Description:Works out approximate number of lines to display a text string in a GUI text box.
		@Parameters:
		 strText:		String to process mandatory
		 maxLines:	Maximum height for text box, defaults to 9 lines if not provided
		]]
		maxLines = maxLines or 9
		local intLines = 1
		for strLine in string.gmatch(strText,"(.-)\n") do
			intLines = intLines + 1
		end
		return math.min(intLines,maxLines)
	end -- function intLineCount

	local function strItemDetails(ptrItem)
		-- Returns Record Tag and [Id] plus full Data Ref, and descriptive text for each Tag level
		local tblDetails = {}
		local ptrTemp = ptrItem:Clone()
		local strDataRef, intRecId, strRecTag = general.BuildDataRef(ptrItem)
		TblOption.Set.Data = strDataRef											-- Save the Data Ref for Result Set
		table.insert(tblDetails,strRecTag.."  Record Id: ["..intRecId.."]  Data Ref: "..strDataRef)
		while ptrTemp:IsNotNull() do
			local strUDF = ""
			if fhIsUDF(ptrTemp) then												-- V2.0 adds UDF indication
				strWarning = " ! ! BEWARE ! !     Unrecognised Data Field (UDF)"
				strUDF = "    {*UDF!}"
			end
			table.insert(tblDetails,2,fhGetDisplayText(ptrTemp)..strUDF)
			ptrTemp:MoveToParentItem(ptrTemp)
		end
 		return table.concat(tblDetails,"\n")
	end -- local function strItemDetails

	local function iupMultiLineText(strVal,strRead)							-- Return iup.text multiline control
		return iup.text {	Value=strVal, ReadOnly=strRead, VisibleLines=intLineCount(strVal,5),
								MultiLine="YES", AutoHide="YES", Formatting="YES", AddFormatTag=iup.user { Bulk="YES", CleanOut="YES" } }
	end -- local function iupMultiLineText

	local strButton = "Cancel"													-- Default to value for X Close window button

	local function iupButtonControl(strTitle)									-- Return iup.button control
		return iup.button { Title=strTitle, MinSize="100x40", action=function(self) strButton=self.Title return iup.CLOSE end }
	end -- local function iupButtonControl

	local strMode = TblOption.Set.Mode											-- Mode is either "Replace" or "Report" text

	local lblDataRef = iup.label  { Title="Data Reference : " }
	local txtDataRef = iupMultiLineText( strItemDetails(ptrItem), "YES" )
	local lblCurrent = iup.label  { Title="Current Value : " }
	local txtCurrent = iupMultiLineText( strOldVal, "YES" )
	local lblReplace = iup.label  { Title="Replacement Value : " }
	local txtReplace = iupMultiLineText( strNewVal, "NO" )
	local lblWarning = iup.label  { Title=strWarning }
	local tglConfirm = iup.toggle { Title="Confirm every item found" }
	local btnPerform = iupButtonControl( strMode )
	local btnSkipOne = iupButtonControl( "Skip" )
	local btnDestroy = iupButtonControl( "Cancel" )

	if strMode ~= "Replace" then													-- Hide the Replacement Value controls
		lblReplace.Visible  = "NO"
		lblReplace.Floating = "YES"
		txtReplace.Visible  = "NO"
		txtReplace.Floating = "YES"
	end
	if not strWarning then															-- Disable the Warning label control
		lblWarning.Active = "NO"
	end
	if TblOption.Tgl.Conf then													-- Set initial Confirmation toggle value
		tglConfirm.Value = "ON"
	else
		tglConfirm.Value = "OFF"
	end

	local tblConfirm = { ON = "Confirmation prompt for each item found", OFF = strMode.." all matching text unconditionally" }

	-- Set other GUI control attributes
	for iupName, tblAttr in pairs ( {
		-- Control	=	1~FgColor		, 2~Font				, 3~Expand		, 4~Tip							, 5~action
		[lblDataRef]	= { iup_gui.Info, iup_gui.FontHead	, "NO" 			, "Data reference details"	},
		[txtDataRef]	= { iup_gui.Info, iup_gui.FontBody	, "YES"			, "Data reference details"	},
		[lblCurrent]	= { iup_gui.Info, iup_gui.FontHead	, "NO" 			, "Current text string"		},
		[txtCurrent]	= { iup_gui.Info, iup_gui.FontBody	, "YES"			, "Current text string"		},
		[lblReplace]	= { iup_gui.Info, iup_gui.FontHead	, "NO" 			, "Replacement text string that can be edited"	},
		[txtReplace]	= { iup_gui.Safe, iup_gui.FontBody	, "YES"			, "Replacement text string that can be edited"	},
		[lblWarning]	= { iup_gui.Risk, iup_gui.FontBody	, "YES"			, "Data warning message"		},
		[tglConfirm]	= { iup_gui.Safe, iup_gui.FontBody	, "YES"			, tblConfirm[tglConfirm.Value], function() tglConfirm.Tip = tblConfirm[tglConfirm.Value] end },
		[btnPerform]	= { iup_gui.Safe, iup_gui.FontBody	, "HORIZONTAL"	, strMode.." the data item"	},
		[btnSkipOne]	= { iup_gui.Safe, iup_gui.FontBody	, "HORIZONTAL"	, "Skip this data item"		},
		[btnDestroy]	= { iup_gui.Risk, iup_gui.FontBody	, "HORIZONTAL"	, "Cancel rest of search"		},
		} ) do
		iupName.FgColor	= tblAttr[1]
		iupName.Font 	= tblAttr[2]
		iupName.Expand	= tblAttr[3]
		iupName.Tip		= tblAttr[4]
		iupName.TipBalloon = iup_gui.Balloon
		if tblAttr[5] then iupName.action = tblAttr[5] end
	end

	local boxDataRef	= iup.vbox	{ lblDataRef, txtDataRef, }
	local boxCurrent	= iup.vbox	{ lblCurrent, txtCurrent, }
	local boxReplace	= iup.vbox	{ lblReplace, txtReplace, }
	local boxControls	= iup.vbox	{ lblWarning, iup.hbox { tglConfirm, btnPerform, btnSkipOne, btnDestroy, Margin="3x3", Alignment="ABOTTOM", } }
	local boxDialogue	= iup.vbox	{ boxDataRef, boxCurrent, boxReplace, boxControls, }

	local dlgPerform	= iup.dialog	{ Title=iup_gui.Plugin..iup_gui.Version, Gap=iup_gui.Gap, Margin="3x3", boxDialogue, }

	local strDataClass = fhGetDataClass(ptrItem)

	function txtReplace:action(intChar,strText)								-- Replacement Value is being changed
		if strDataClass ~= "longtext" and string.char(intChar) == "\n" then
			return iup.IGNORE														-- Prevent short text items exceeding one line
		end
	end -- function txtReplace:action

	function txtReplace:valuechanged_cb()										-- Replacement Value has been changed
		if strDataClass == "age" then
			if strNewVal:gsub("%s","") == txtReplace.Value:gsub("%s","") then return end	-- Let spaces be added to allow yrs/mns/dys to be entered
			local strTxtVal = txtReplace.Value
			strWarning,strNewVal = StrAgeWarning(ptrItem,strTxtVal)		-- Regenerate any Age Warnings and corrected Value
			if strTxtVal ~= strNewVal then
				local intCaretPos = txtReplace.CaretPos						-- Maintain editing caret position and update Value
				txtReplace.Value = strNewVal
				txtReplace.CaretPos = intCaretPos
			end
		elseif strDataClass == "date" then
			strWarning = StrDateWarning(ptrItem,txtReplace.Value)			-- Regenerate any Date Warnings
		end
		lblWarning.Title = strWarning
		if strWarning then
			lblWarning.Active = "YES"
		else
			lblWarning.Active = "NO"
		end
	end -- function txtReplace:valuechanged_cb

	iup_gui.ShowDialogue("User",dlgPerform,btnPerform,"Keep")				-- Popup dialogue that remembers its attributes

	strNewVal = txtReplace.Value													-- Retrieve new Replacement text and Confirmation toggle values
	TblOption.Tgl.Conf = ( tglConfirm.Value == "ON" )
	dlgPerform:destroy()
	return strButton, strNewVal 
end -- function SearchReplacePrompt

-- Perform Text Search and Optional Replace --
function DoSeekMatch(ptrItem,strDataClass)

	local strOldVal = fhGetValueAsText(ptrItem)
	local strNewVal = ""
	local strSeek = TblOption.Set.Seek
	local strSwap = TblOption.Set.Swap

	local function doManageString(strOldVal,strNewVal)						-- V1.7 new function
		if TblOption.Set.Mode == "Replace" then
			if isDateItem then
				local newDate = fhNewDate(1999)
				if strNewVal == "" then
					newDate:SetNull()												-- Null Date Object for empty string
				else
					newDate:SetValueAsText(strNewVal,true)						-- Allow Date Phrase for Date Object
				end
				fhSetValueAsDate(ptrItem,newDate)
			else
				fhSetValueAsText(ptrItem,strNewVal)								-- For text values use Text object
			end
			fhUpdateDisplay()
		end
		local ptrRecord = fhNewItemPtr()										-- Save result set entries
		ptrRecord:MoveToRecordItem(ptrItem)
		table.insert(TblRecord,ptrRecord:Clone())
		table.insert(TblDataRef,TblOption.Set.Data)
		table.insert(TblOldValue,strOldVal)
		table.insert(TblNewValue,ptrItem:Clone())
	end -- local function doManageString

	if strDataClass == "date" then												-- V1.7 new conditional statement for Date field
		strOldVal = fhGetDisplayText(ptrItem):gsub("Date: ",""):gsub("Entry ","")
	end
	if TblOption.Tgl.Word then													-- V2.1 revised to cater for successive repetitions of the seek word
		strSeek = "([%s%p\01])"..strSeek.."([%s%p\01])"						-- Replace whole words delimited by white space or punctuation or SOH="\01" characters
		strSwap = "%1"..strSwap.."%2"
		strNewVal = ("\01"..strOldVal.."\01"):gsub("([%s%p])","%1\01")	-- Insert leading & trailing SOH="\01" so first & last words match, and add SOH="\01" to each white space/punctuation character so repeated words match
		strNewVal = strNewVal:gsub(strSeek,strSwap):gsub("\01","")		-- Replace words and remove all inserted SOH="\01" characters
	else
		strNewVal = strOldVal:gsub(strSeek,strSwap)							-- Replace any other cases
	end
	if strOldVal ~= strNewVal then
		strNewVal = strNewVal:gsub("\01","")									-- V2.0 Eliminate any SOH="\01" characters added by doPerformAction() to force a change
		local strWarning = nil
		if strDataClass == "age" then											-- Obtain any Warning for Age field, with corrected text value
			strWarning,strNewVal = StrAgeWarning(ptrItem,strNewVal)
		elseif strDataClass == "date" then										-- Obtain any Warning for Date field
			strWarning = StrDateWarning(ptrItem,strNewVal)
		end
		if TblOption.Tgl.Conf or strWarning then								-- Confirmation required or Warning to report
			local strButton = nil
			strButton, strNewVal = SearchReplacePrompt(ptrItem,strOldVal,strNewVal,strWarning)
			if strButton == TblOption.Set.Mode then
				doManageString(strOldVal,strNewVal)								-- V1.7 call new function
			elseif strButton ~= "Skip" then
				return false															-- Process cancelled
			end
		else
			TblOption.Set.Data = general.BuildDataRef(ptrItem)
			doManageString(strOldVal,strNewVal)									-- V1.7 call new function
		end
	end
	return true
end -- function DoSeekMatch

-- Search All Data Items --
function DoAllItems()
	local isContinue = true
	local tblTgl = TblOption.Tgl													-- Keyword array of Mode & Class & Tag boolean toggles
	local intItem = tonumber(TblOption.Set.Item)								-- Number of items in database
	local tblUser = iup_gui.DialogueAttributes("Main")
	tblUser.X = tblUser.CoordX+100												-- Popup Progress Bar in same place as Main dialogue
	tblUser.Y = tblUser.CoordY+150
	progbar.Setup( tblUser )
	if intItem > 5000 then
		progbar.Start("Searching",intItem)										-- Start Progress Bar if enough items in database
	end
	for strType in iterate.RecordTypes() do									-- Loop through all record types
		progbar.Message("Searching "..strType.." Records")
		for ptrItem in iterate.Items(strType) do								-- Loop through all data items
			local strChild = fhGetTag(ptrItem)									-- Obtain child item Tag
			local strParent = ""
			local ptrParent = fhNewItemPtr()									-- Obtain parent item
			ptrParent:MoveToParentItem(ptrItem) 
			if fhIsFact(ptrParent) then											-- Parent is any Fact Tag
				strParent = "Fact."
			elseif fhGetDisplayText(ptrParent):match("^LDS %l%l") then	-- Parent is any LDS Ordinance
				strParent = "LDS."
			else
				strParent = fhGetTag(ptrParent).."."							-- Otherwise use parent item Tag
				ptrParent:MoveToParentItem(ptrParent)							-- Prefix "" to distinguish from Parent=Record
				if ptrParent:IsNotNull() then strParent = ""..strParent end
			end
			local strParentChild = strParent..strChild						-- Parent.Child Tags
			if fhIsAttribute(ptrItem) then strChild = "Attr" end			-- Special case for all Attributes
			local strDataClass = fhGetDataClass(ptrItem)
			local strValueType = fhGetValueType(ptrItem)
			if  ( strValueType == "text" or strValueType == "date" )		-- Only text & date fields are supported
			and (		tblTgl[strChild]											-- Child item Tag or V2.0 "Attr" ?
				 or 	tblTgl[strParentChild]										-- V2.0 & V2.1 Parent.Child item Tags ?
				 or (	tblTgl[strDataClass] and									-- V2.0 Class match and
						tblTgl[strChild] == nil and								-- Child and Parent.Child without any toggle option ?
						tblTgl[strParentChild] == nil )														
				 ) then
				isContinue = DoSeekMatch(ptrItem,strDataClass)				-- Try string value match for matching data item type
			end
			if not isContinue then break end
			if progbar.Stop() then break end	
			progbar.Step(1)
		end
	end
	progbar.Close()
end -- function DoAllItems

-- Main GUI Dialogue --
function GUI_MainDialogue()

	--[[
		TblOption.Set has these entries for global option settings :
			Item	Item count of database size for search progress bar
			Date	Date of last Item update to avoid recalculation run-time
			Seek	Search text string
			Swap	Replace text string
			Mode	"Replace" = Search & Replace or "Report" = Search ONLY		(not sticky)
			Data	Data reference for currently matched item						(not sticky)
		TblOption.Tgl and TblOption.Lst and other tables below may have these entries for "ON"/"OFF" toggles or drop list Tags :
		Mixed case entries are Mode settings :
			Conf	Confirm Text Replacements
			Text	Plain Text Mode v. LUA Pattern Text Mode
			Case	Case Insensitive v. Case Sensitive
			Word	Whole Words v. Part Words
			Attr	Attribute Values enabled/disabled	-- V2.0
			Age 	Age Error checks enabled/disabled	-- V2.1
			Date	Date Warnings enabled/disabled		-- V1.7
		Lower case entries are single Data Class names such as "text", "name", "place" and "longtext"
		Upper case entries are single Gedcom Tag names such as "NICK", "FORM", "_PLAC" and "_EMAIL"
		Upper case entries separated by dot are parent & child Gedcom Tag names such as "SOUR.TITL"
		Upper case entries prefixed by ellipsis "" are non-Record parent & child such as "DATA.TEXT"
		These latter are used where similar Gedcom Tag names need to be differentiated :
			INDI.NAME "name" (Individual Name) versus REPO.NAME & SUBM.NAME "text" (Repository/Submitter record Name c.f. Source/Media record Title)
			INDI.TITL "text" (Title Attribute) versus SOUR.TITL "longtext" & SOUR.ABBR "text" & OBJE.TITL "text" (Source/Media record Title)
			NOTE.TEXT (Note record Text) versus SOUR.TEXT & DATA.TEXT (Text From Source) all "longtext"
		Special variants are Fact.NOTE & Fact.DATE for any Fact parent tags, and LDS.NOTE & LDS.DATE for any LDS Ordinance parent tags.
	--]]

	local tblSet = TblOption.Set													-- Local shortcuts to option tables
	local tblTgl = TblOption.Tgl
	local tblLst = TblOption.Lst
	local tblBasic  = { }															-- GUI basic toggle iup controls
	local tblToggle = { }															-- GUI extra toggle iup controls
	local tblList   = { }															-- GUI dropdown list iup controls

	local tblRelated = {															-- Related GUI settings dependancies
		text 			= { "word", "word2", "wordlist", },						-- FORM is "word", ROLE is "word2", remainder are "text", except NAME/"name" & PLAC/"place" below 
		name 			= { "NPFX", "NSFX", "NICK", "GIVN", "_USED", "SURN", "SPFX", },
		PLAC 			= { "place", "_PLAC", },
		RFN  			= { "RIN"  , },
		FORM 			= { "_FILE", },												-- FORM is "word"
		PHON 			= { "_WEB" , "_EMAIL", },
		ADR1 			= { "ADR2" , "CITY", "STAE", "POST", "CTRY", },
		TEMP 			= { "AFN"  , "FAMF",  },									-- INDI.CONL.TEMP & SUBN.TEMP & INDI.AFN & SUBN.FAMF
		NOTE2			= { "_NOTE", },
		["SOUR.TEXT"]= { "DATA.TEXT", },
		["SOUR.TITL"]= { "SOUR.ABBR", "OBJE.TITL", "REPO.NAME", "SUBM.NAME", },
	}

	local tblBasicShort = { 														-- Basic Filter Short Text toggle options
		{ "name"		, "Individual Names, Prefix, Suffix, Given, etc"		, "All Individual Primary and Alternate Name (NAME) fields including: \n (NPFX) Name Prefix, \n (NSFX) Name Suffix, \n (NICK) Nickname, \n (GIVN) Given Name, \n (_USED) Given Name Used, \n (SURN) Surname, \n (SPFX) Surname Prefix" },
		{ "PLAC"		, "Fact Place fields"											, "Fact Place and To/From (PLAC/_PLAC) fields only"									},
		{ "PAGE"		, "Where Within Source fields"								, "Where Within Source (PAGE) fields for Citations only"							},
		{ "text"		, "All other Text fields"										, "All other Short Text and Long Text fields"										},
		{ "date"		, "Date fields"													, "Fact, Citation Entry, Multimedia, and LDS Date (DATE/_DATE) fields"			}, -- Fact DATE, Citation DATA.DATE, Multimedia OBJE._DATE, LDS Ordination BAPL/CONL/ENDL/SLGC/SLGS.DATE fields
	}

	local tblBasicLong = { 														-- Basic Filter Long Text toggle options
		{ "NOTE2"		, "Note fields"													, "All the Note and Link/Note (NOTE/_NOTE) fields"									},
		{ "ADDR"		, "Fact Address fields"										, "Fact Address (ADDR) fields only"														},
		{ "SOUR.TEXT", "Text From Source fields"									, "Text From Source (TEXT) fields for Citations and Sources"						},
		{ "boxButtons" },
	}

	local tblShortText = { 														-- Short Text toggle & drop list options
		-- 1~Name		, 2~Title for toggle											, 3~Tip for toggle																			, 4~Tip for drop list					, 5~1st Item for drop list	, 6~2nd Item for drop list	, 7~3rd Item for drop list	, etc				
		{ "name"		, "Individual Names, Prefix, Suffix, Given, etc"		, "All Individual Primary and Alternate Name (NAME) fields including: \n (NPFX) Name Prefix, \n (NSFX) Name Suffix, \n (NICK) Nickname, \n (GIVN) Given Name, \n (_USED) Given Name Used, \n (SURN) Surname, \n (SPFX) Surname Prefix" },
		{ "PLAC"		, "Fact Place fields"											, "Fact Place and To/From (PLAC/_PLAC) fields only"									},
		{ "PAGE"		, "Where Within Source fields"								, "Where Within Source (PAGE) fields for Citations only"							},
		{ "Attr"		, "Fact Attribute values"										, "Any value for Fact Attributes"														, "Select an Attribute fact"			, " All the Attribute facts" },
		{ "CAUS"		, "Fact Cause fields"											, "Fact Cause (CAUS) fields only"														},
		{ "AGNC"		, "Fact && Source Responsible Agency fields"				, "Fact and Source Responsible Agency (AGNC) fields"								},
		{ "_TYPE"		, "Source record Type fields"								, "Source record Type (_TYPE) fields only"											},
		{ "TYPE"		, "Type fields for Facts && Custom Id"						, "Facts Type and Custom Id Type (TYPE) fields"										},
		{ "REFN"		, "Custom Id fields"											, "Custom Id (REFN) fields only"														},
		{ "RFN"		, "Permanent && Automated Record Number fields"			, "Permanent and Automated Record Number (RFN/RIN) fields only"					},
		{ "FORM"		, "Multimedia Format && Linked File fields"				, "Multimedia Format (FORM) and Linked File (_FILE) fields only"				},
		{ "_KEYS"		, "Multimedia Keyword fields"								, "Multimedia Keyword (_KEYS) fields only"											},
		{ "PHON"		, "Phone && Email && Website fields"						, "All the Phone (PHON) and Email (_EMAIL) and Website (_WEB) fields"			},
		{ "ADR1"		, "Address Line1/2, City, State, Postcode && Country"	, "All address Line1 (ADR1), Line2 (ADR2), City (CITY), \n State (STAE), Postcode (POST) and Country (CTRY) fields" },
		{ "TEMP"		, "LDS Temple && File Number && Filename fields"		, "LDS Temple Codes (TEMP) and Ancestral File Number (AFN) and Family Filename (FAMF) fields" },
		{ "text"		, "All other one line Short Text fields"					, "All other one line Short Text fields including: \n (\"UDF\") Uncategorised Data Fields, \n (_SENT) Fact Customised Sentences, \n (ROLE) Citation Event Type Roles, \n (RELA) Association Relationships, \n (LANG) Submitter Record Languages, \n (CALN) Source Repository Identifications" },
		--[[	Uncategorised Data Fields (UDF),
				Fact Customised Sentences (Fact._SENT),
				Citation Event Type Roles (Fact.SOUR.EVEN.ROLE word2),
				Association Relationships (INDI.ASSO.RELA),
				Submitter Record Language (SUBM.LANG),
				Source Repository Identifications (SOUR.REPO.CALN),
		--]]
	}

	local tblLongText = { 															-- Long Text toggle & drop list options
		-- 1~Name		, 2~Title for toggle											, 3~Tip for toggle																			, 4~Tip for drop list					, 5~1st Item for drop list	, 6~2nd Item for drop list	, 7~3rd Item for drop list	, 8~4th Item for drop list , etc				
		{ "NOTE2"		, "Note fields"													, "All the Note and Link/Note (NOTE/_NOTE) fields"									, "Select a Note field type"			, "All the Note fields"		, "Fact Notes (Fact.NOTE)"	, "Individual (INDI.NOTE)"	, "Family (FAM.NOTE)" , "Citation (SOUR.NOTE)" , "Source (SOUR.NOTE)" , "Repository (REPO.NOTE)" , "Multimedia (OBJE._NOTE)" , "Link/Notes (OBJE.NOTE)" , "LDS Ordination (LDS.NOTE)" },
		{ "ADDR"		, "Fact Address fields"										, "Fact Address (ADDR) fields only"														},
		{ "SOUR.TEXT", "Text From Source fields"									, "Text From Source (TEXT) fields for Citations and Sources"						, "Select Citations or Sources"		, "Both the field types"		, "Citation (DATA.TEXT)"		, "Source (SOUR.TEXT)"			},
		{ "AUTH"		, "Author for Source fields"									, "Author (AUTH) fields for Sources only"												},
		{ "PUBL"		, "Publication Info for Source fields"						, "Publication Info (PUBL) fields for Sources only"									},
		{ "SOUR2"		, "Source Note fields"											, "Source Note (SOUR) fields only"														},
		{ "NOTE.TEXT", "Note record Text fields"									, "Note record Text (TEXT) fields only"												},
	}

	local tblDistinct = {															-- Distinct toggle & drop list options
		-- 1~Name		, 2~Title for toggle											, 3~Tip for toggle																			, 4~Tip for drop list					, 5~1st Item for drop list	, 6~2nd Item for drop list	, 7~3rd Item for drop list	, 8~4th Item for drop list , etc				
		{ "SOUR.TITL", "Record Titles/Names"										, "Source, Multimedia, Repository, Submitter Title (ABBR/TITL/NAME) fields"	, "Select Record title/name type"	, "All the Record types"		, "Source Title (SOUR.TITL)"	, "Source Short (SOUR.ABBR)"	, "Repository (REPO.NAME)" , "Multimedia (OBJE.TITL)" , "Submitter (SUBM.NAME)" }, -- Source Short Title SOUR.ABBR, Source Title SOUR.TITL, Repository Name REPO.NAME, Multimedia Title OBJE.TITL, Submitter Name SUBM.NAME fields
		{ "age"		, "Fact Age fields"												, "Fact Age (AGE) fields only"															},
		{ "radAge_Mode" },
		{ "date"		, "Date fields"													, "Fact, Citation Entry, Multimedia, and LDS Date (DATE/_DATE) fields"			, "Select a Date field type"			, "All the Date fields"		, "Fact Dates (Fact.DATE)"	, "Citation Entry (DATA.DATE)" , "Multimedia (OBJE._DATE)" , "LDS Ordination (LDS.DATE)" }, -- Fact DATE, Citation DATA.DATE, Multimedia OBJE._DATE, LDS Ordination BAPL/CONL/ENDL/SLGC/SLGS.DATE fields
		{ "radDateMode" },
	}

	local function strListTag(strTag)											-- Dropdown list tag structure to ensure conformity, must also be used in each 'Item for drop list' above
		if strTag then return " ("..strTag..")" end							-- Used by doPopulateList() to set tag, and setListTags() to match tag
		return " %((.*)%)$"															-- Used by saveOptions() to extract & save tag
	end -- local function strListTag

	local function doPopulateList(tblItem)										-- Populate all the dropdown list controls defined later -- V2.1
		local strList = tblItem[1]
		local iupList = tblList[strList]										-- Obtain the iup.list control via its name
		iupList.AutoRedraw = "NO"
		iupList.Sort = "NO" 
		for intTag = 1, #tblItem-4 do											-- Populate the basic dropdown list without Sort, as table items set order
			iupList[intTag] = tblItem[intTag+4]
		end
		if strList == "Attr" then													-- Populate the Attribute dropdown list with Sort, as names are indeterminate
			local tblTag = { RESI=true }
			local intTag = 1
			local strTag = ""
			iupList.Sort = "YES" 
			for intRec, strRec in ipairs ({"INDI","FAM"}) do				-- Find all Individual and Family Attributes for dropdown list
				for ptrRec in iterate.Records(strRec) do
		 			for ptrFact in iterate.Facts(ptrRec) do
						if fhIsAttribute(ptrFact) then							-- Attribute fact found
							strTag = fhGetTag(ptrFact)
							if not tblTag[strTag] then							-- Omit any Attribute already found and Residence (RESI) Attribute
								intTag = intTag + 1
								tblTag[strTag] = true
								iupList[intTag] = fhCallBuiltInFunction("FactName",ptrFact)..strListTag(strRec.."."..strTag)
							end
						end
					end
				end
			end
		end
		iupList.AutoRedraw = "YES"
	end -- local function doPopulateList

	local function setListTags()													-- Set values for dropdown list tags, called by btnDefault:action, and before iup_gui.ShowDialogue  -- V2.1
		for strList, iupList in pairs ( tblList ) do
			local strTag = tblLst[strList] or ""
			iupList.Value = 1														-- Default to 1st entry
			for intList = 2, iupList.Count do
				if iupList[intList]:matches(strListTag(strTag)) then
					iupList.Value = intList										-- Select chosen entry
					break
				end
			end
		end
	end -- local function setListTags

	local function iupToggle(tblItem,intItem,strOpt)											-- Return toggle handle created from a table item above
		local strToggle = tblItem[1]
		local strValue  = tblTgl[strToggle] or "ON"
		local iupToggle = iup.toggle { Value=strValue, Title=tblItem[2], Tip=tblItem[3], TipBalloon=iup_gui.Balloon, Expand="YES" }
		if strOpt == "Basic" then
			if strToggle == "text" or strToggle == "date"
			or ( tblLongText[intItem][1] == strToggle and tblLongText[intItem][4] ) then
				iupToggle["3State"] = "YES"
				iupToggle.action = function(self,intState) if intState < 0 then self.Value = "OFF" end end	-- User can only set "ON"=1 or "OFF"=0 but Advanced tab can set "NOTDEF"=-1
			end
			tblBasic[strToggle] = iupToggle
		else
			tblToggle[strToggle] = iupToggle
		end
		iupToggle.TipDelay = 6000 + ( #tblItem[3] * 20 )					-- Display larger tooltips for longer
		return iupToggle
	end -- local function iupToggle

	local function iupList(tblItem)												-- Return dropdown list handle created from a table item above
		local strList = tblItem[1]
		local iupList = iup.list { FgColor=iup_gui.Safe, DropDown="YES", Tip=tblItem[4], TipBalloon=iup_gui.Balloon, Expand="YES", VisibleColumns="9", Visible_Items="20", MaxSize="x9" }
		tblList[strList] = iupList
		doPopulateList(tblItem)													-- Populate dropdown list with names & tags
		return iupList
	end -- local function iupList

	local function doAppend(boxOpt,tblOpt,strOpt,...)								-- Append controls to GUI box using table options above
		intArg = 1
		for intItem, tblItem in ipairs ( tblOpt ) do
			if tblItem[4] then														-- Append toggle and dropdown list
				iup.Append( boxOpt, iup.hbox { iupToggle(tblItem,intItem,strOpt), iup.hbox { iupList(tblItem), Margin="2x0" }, Homogeneous="YES", Margin="0x0" } ) -- V2.1
			elseif tblItem[2] then
				iup.Append( boxOpt, iupToggle(tblItem,intItem,strOpt) )						-- Append just a toggle
			else
				if arg[intArg] then
					iup.Append(boxOpt,arg[intArg])								-- Append another control if supplied
					intArg = intArg + 1
				end
			end
		end
	end -- local function doAppend

	local function iupValue(strValue,tglA,tglB)								-- Return toggle handle depending on toggle value
		if strValue == "OFF" then
			return tglB
		else
			return tglA
		end
	end -- local function iupValue

	local function iupRadio(strValue,tglA,tglB)								-- Return radio handle created from two toggles
		return iup.radio { iup.hbox	{ tglA, tglB, Homogeneous="YES", }, Value=iupValue(strValue,tglA,tglB), }
	end -- local function iupRadio

	local function setAllToggles(tblText,strMode)							-- Set all Short/Long Text toggle options "ON"/"OFF"
		for intItem, tblItem in ipairs ( tblText ) do
			tblToggle[tblItem[1]].Value = strMode
			if strMode == "ON" and tblList[tblItem[1]] then
				tblList[tblItem[1]].Value = 1									-- Reset dropdown lists to default 1st entry
			end
		end
	end -- local function setAllToggles

	local function iupText(strVal)												-- Return multiline text handle
		return iup.text { Value=strVal, MultiLine="YES", AutoHide="YES", Formatting="YES", AddFormatTag=iup.user { Bulk="YES", CleanOut="YES" } }
	end -- local function iupText

	local lblSeekText 	= iup.label	{ Title="Search  : "				}
	local txtSeekText 	= iupText		( tblSet.Seek )
	local lblSwapText	= iup.label	{ Title="Replace : "				}
	local txtSwapText	= iupText		( tblSet.Swap )

	local tglTextPlain	= iup.toggle	{ Title="Plain Text Mode"			}
	local tglTextPatt	= iup.toggle	{ Title="LUA Pattern Mode"		}
	local radTextMode	= iupRadio(tblTgl.Text,tglTextPlain,tglTextPatt)
	local tglCaseInse	= iup.toggle	{ Title="Case Insensitive"		}
	local tglCaseSens	= iup.toggle	{ Title="Case Sensistive"			}
	local radCaseMode	= iupRadio(tblTgl.Case,tglCaseInse,tglCaseSens)
	local tglWordWhole	= iup.toggle	{ Title="Whole Words"				}
	local tglWordPart	= iup.toggle	{ Title="Part Words"				}
	local radWordMode	= iupRadio(tblTgl.Word,tglWordWhole,tglWordPart)
	local tglConfirm	= iup.toggle	{ Title="Confirm the action for every item found", Value=tblTgl.Conf or "ON" }

	local boxOptLeft	= iup.hbox	{ iup.vbox { lblSeekText, lblSwapText }, iup.vbox { txtSeekText, txtSwapText } }
	local boxOptRight	= iup.vbox	{ radTextMode, radCaseMode, radWordMode, iup.hbox { tglConfirm, Margin="6" }, Margin="6" }
	local boxOptions	= iup.hbox	{ Font=iup_gui.FontBody, boxOptLeft, boxOptRight, Homogeneous="YES", Margin="x2" }
	local frmOptions	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title=" Search Mode ", boxOptions }

	local btnReplaces 	= iup.button	{ Title=" Search && Replace", Font=iup_gui.FontHead }
	local btnSearches 	= iup.button	{ Title="   Search ONLY   " , Font=iup_gui.FontHead }
	local frmBasicBtn	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title="", iup.hbox { btnReplaces, btnSearches, Homogeneous="YES", Margin="2x2", } }
	local boxBasicShort	= iup.vbox	{ Font=iup_gui.FontBody, iup.hbox { Homogeneous="YES" } }
	doAppend(boxBasicShort,tblBasicShort,"Basic")
	local boxBasicLong	= iup.vbox	{ Font=iup_gui.FontBody, iup.hbox { Homogeneous="YES" } }
	doAppend(boxBasicLong, tblBasicLong, "Basic", frmBasicBtn)
	local frmBasicFilt	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title=" Basic Filters ", iup.hbox { boxBasicShort, boxBasicLong, Homogeneous="YES" }, }

	local btnShortInc	= iup.button	{ Title="Include All Short Text" }
	local btnShortExc	= iup.button	{ Title="Exclude All Short Text" }
	local boxShortText	= iup.vbox	{ Font=iup_gui.FontBody, iup.hbox { btnShortInc, btnShortExc, Homogeneous="YES" } }
	local frmShortText	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title=" Short Text Fields ", boxShortText }
	doAppend(boxShortText,tblShortText,"Extra")

	local btnLongInc	= iup.button	{ Title="Include All Long Text" }
	local btnLongExc	= iup.button	{ Title="Exclude All Long Text" }
	local boxLongText	= iup.vbox	{ Font=iup_gui.FontBody, iup.hbox { btnLongInc, btnLongExc, Homogeneous="YES" } }
	local frmLongText	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title=" Long Text Fields ", boxLongText }
	doAppend(boxLongText,tblLongText,"Extra")

	local tglAge_Inc	= iup.toggle	{ Title="Age Warnings", TipBalloonTitle="BEWARE!", TipBalloonTitleIcon="2" } 
	local tglAge_Exc	= iup.toggle	{ Title="No Age Warnings"		} 
	local radAge_Mode	= iupRadio(tblTgl.Age,tglAge_Inc,tglAge_Exc)
	local tglDateInc	= iup.toggle	{ Title="Date Warnings", TipBalloonTitle="BEWARE!", TipBalloonTitleIcon="2" } 
	local tglDateExc	= iup.toggle	{ Title="No Date Warnings"		} 
	local radDateMode	= iupRadio(tblTgl.Date,tglDateInc,tglDateExc)
	local boxDistinct	= iup.vbox	{ Font=iup_gui.FontBody			}
	local frmDistinct	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title=" Distinctive Fields ", boxDistinct }
	doAppend(boxDistinct,tblDistinct,"Extra",radAge_Mode,radDateMode)

	local btnReplacer 	= iup.button	{ Title=" Search && Replace", Font=iup_gui.FontHead }
	local btnSearcher 	= iup.button	{ Title="   Search ONLY   " , Font=iup_gui.FontHead }
	local frmExtraBtn	= iup.frame	{ Font=iup_gui.FontHead, FgColor=iup_gui.Info, Title="", iup.hbox { btnReplacer, btnSearcher, Homogeneous="YES", Margin="2x2", } }

	local btnDefault	= iup.button	{ Title="Restore Defaults"		}
	local btnSetFont	= iup.button	{ Title="Set Window Font"			}
	local btnGetHelp	= iup.button	{ Title="   Help && Advice"		}
	local btnDestroy	= iup.button	{ Title="Close Plugin"				}
	local boxButtons	= iup.hbox	{ btnDefault, btnSetFont, btnGetHelp, btnDestroy, Homogeneous="YES", Font=iup_gui.FontBody }

	local tblConfirm	= { ON = "Confirmation prompt for every item found", OFF = "Process all matching text unconditionally" }

	-- Set other GUI control attributes
	for iupName, tblAttr in pairs ( {
		-- Control		=	1~FgColor		, 2~Expand	, 3~Tip												, 4~action
		[lblSeekText]	= { iup_gui.Info, "VERTICAL"	, "Plain text string to search for"				},
		[txtSeekText]	= { iup_gui.Safe, "YES"		, "Plain text string to search for"				},
		[lblSwapText]	= { iup_gui.Info, "VERTICAL"	, "Plain text string to substitute"				},
		[txtSwapText]	= { iup_gui.Safe, "YES"		, "Plain text string to substitute"				},
		[tglTextPlain]	= { iup_gui.Safe, "YES"		, "Plain text strings"								},
		[tglTextPatt]	= { iup_gui.Safe, "YES"		, "LUA pattern strings\nSee 'Help and Advice' for details"		},
		[tglCaseInse]	= { iup_gui.Safe, "YES"		, "Case insensitive text search"				},
		[tglCaseSens]	= { iup_gui.Safe, "YES"		, "Case sensitive text search"					},
		[tglWordWhole]	= { iup_gui.Safe, "YES"		, "Whole words are delimited by spaces, tabs, and punctuation"	},
		[tglWordPart]	= { iup_gui.Safe, "YES"		, "Part words may be any text"					},
		[tglConfirm ]	= { iup_gui.Safe, "YES"		, tblConfirm[tglConfirm.Value]					, function() tglConfirm.Tip = tblConfirm[tglConfirm.Value] end },

		[btnReplaces]	= { iup_gui.Safe, "YES"		, "Start the Search and Replace process"		},
		[btnSearches]	= { iup_gui.Safe, "YES"		, "Start the Search only process"				},

		[btnShortInc]	= { iup_gui.Safe, "YES"		, "Include all one line Short Text fields"	, function() setAllToggles(tblShortText,"ON")  end },
		[btnShortExc]	= { iup_gui.Risk, "YES"		, "Exclude all one line Short Text fields"	, function() setAllToggles(tblShortText,"OFF") end },
		[btnLongInc ]	= { iup_gui.Safe, "YES"		, "Include all multi-line Long Text fields"	, function() setAllToggles(tblLongText,"ON")  end },
		[btnLongExc ]	= { iup_gui.Risk, "YES"		, "Exclude all multi-line Long Text fields"	, function() setAllToggles(tblLongText,"OFF") end },
		[tglAge_Inc ]	= { iup_gui.Risk, "YES"		, "This affects the record 'Updated' date\neven if the Age fields are skipped ! !" },
		[tglAge_Exc ]	= { iup_gui.Safe, "YES"		, "Age Warnings disabled"						},
		[tglDateInc ]	= { iup_gui.Risk, "YES"		, "This affects the record 'Updated' date\neven if the Date fields are skipped ! !" },
		[tglDateExc ]	= { iup_gui.Safe, "YES"		, "Date Warnings disabled"						},

		[btnReplacer]	= { iup_gui.Safe, "YES"		, "Start the Search and Replace process"		},
		[btnSearcher]	= { iup_gui.Safe, "YES"		, "Start the Search only process"				},

		[btnDefault ]	= { iup_gui.Safe,"HORIZONTAL", "Restore default Settings for Options and Window positions and sizes" },
		[btnSetFont ]	= { iup_gui.Safe,"HORIZONTAL", "Choose user interface window font style"	},
		[btnGetHelp ]	= { iup_gui.Safe,"HORIZONTAL", "Obtain online Help and Advice from the FHUG Knowledge Base"	},
		[btnDestroy ]	= { iup_gui.Risk,"HORIZONTAL", "Close the Plugin"								},
		} ) do
		iupName.FgColor	= tblAttr[1]
		iupName.Expand	= tblAttr[2]
		iupName.Tip		= tblAttr[3]
		iupName.TipBalloon = iup_gui.Balloon
		if tblAttr[4] then iupName.action = tblAttr[4] end
	end

	local boxMajor = iup.vbox	{ frmOptions, frmBasicFilt, }

	local boxExtra = iup.vbox	{ iup.hbox { frmShortText, iup.vbox { frmLongText, frmDistinct, frmExtraBtn, }, Homogeneous="YES", }, }

	-- Create the Tab controls layout
	local tabControl = iup.tabs { Font=iup_gui.FontHead, Padding="8x4", Tip="Select 'Major Oprions' or 'Extra Filters'.",
								boxMajor, TabTitle0=" Major Options ",
								boxExtra, TabTitle1=" Extra Filters ", 
							}
	local dialogMain	= iup.dialog	{ Title=iup_gui.Plugin..iup_gui.Version, Gap=1, Margin="2x0", iup.vbox { tabControl, boxButtons, }, }

	MakeHelpDialogue(btnGetHelp)

	local function setTabMode(intNew)											-- Set toggles according to chosen new tab
		if intNew == 0 then
			local strValue = nil
			for strName, anyValue in pairs ( tblToggle ) do
				if not tblBasic[strName] then
					strValue = strValue or tblToggle[strName].Value
					if tblToggle[strName].Value ~= strValue then
						strValue = "NOTDEF"
					end
				end
			end
			for strName, anyValue in pairs ( tblBasic ) do					-- Needs more work on Basic "All other Text fields" to reflect Extra toggles for all but toggles matching Basic toggles.
				if strName ~= "text"
				and tblBasic[strName]["3State"] == "YES"
				and tblToggle[strName].Value == "ON"
				and tonumber(tblList[strName].Value) > 1 then
					tblBasic[strName].Value = "NOTDEF"
				else
					tblBasic[strName].Value = tblToggle[strName].Value
				end
			end
			tblBasic["text"].Value = strValue
		elseif intNew == 1 then
			for strName, anyValue in pairs ( tblToggle ) do
				if strName ~= "date" then
					tblToggle[strName].Value = tblBasic["text"].Value
				end
			end
			for strName, anyValue in pairs ( tblBasic ) do
				if tblToggle[strName] and tblBasic[strName].Value ~= "NOTDEF" then
					tblToggle[strName].Value = tblBasic[strName].Value
					if tblList[strName] and tblBasic[strName].Value == "ON" then
						tblList[strName].Value = 1
					end
				end
			end
		end
	end -- local function setTabMode

	local function setTextMode()													-- Set Text Case & Word Modes called from tglTextPlain:action, btnDefault:action, and before iup_gui.ShowDialogue
		if tglTextPlain.Value == "ON" then
			radCaseMode.Active = "YES"											-- Plain Text Mode enables Case & Word modes
			radWordMode.Active = "YES"
			lblSeekText.Tip = "Plain text string to search for"
			txtSeekText.Tip = lblSeekText.Tip
			lblSwapText.Tip = "Plain text string to substitute"
			txtSwapText.Tip = lblSwapText.Tip
		else
			radCaseMode.Active = "NO"												-- LUA Pattern Mode disables Case & Word modes
			radWordMode.Active = "NO"
			lblSeekText.Tip = "LUA pattern string to search for"
			txtSeekText.Tip = lblSeekText.Tip
			lblSwapText.Tip = "LUA pattern string to substitute"
			txtSwapText.Tip = lblSwapText.Tip
		end
	end -- local function setTextMode

	local function setWarnMode()													-- Set Age & Date Warning Mode called from tblToggle.age:action, tblToggle.date:action, btnDefault:action, and before iup_gui.ShowDialogue
		if tblToggle.age.Value == "ON" then
			radAge_Mode.Active = "YES"											-- Age Fields included enables Warning mode
		else
			radAge_Mode.Active = "NO"												-- Age Fields excluded disables Warning mode
		end
		if tblToggle.date.Value == "ON" then
			radDateMode.Active = "YES"											-- Date Fields included enables Warning mode
		else
			radDateMode.Active = "NO"												-- Date Fields excluded disables Warning mode
		end
	end -- local function setWarnMode

	local function saveOptions()													-- Save all GUI settings
		setTabMode(0)
		setTabMode(1)
		for strName, anyValue in pairs ( tblTgl ) do
			if not tblToggle[strName] then
				tblTgl[strName] = nil												-- Clear the non-GUI Class and Tag toggles
			end
		end
		for strName, anyValue in pairs ( tblToggle ) do
			tblTgl[strName] = tblToggle[strName].Value						-- Save all the GUI Class and Tag and "Attr" toggles
		end
		for strName, anyValue in pairs ( tblList ) do
			local strText = tblList[strName][tblList[strName].Value]
			tblLst[strName] = strText:match(strListTag()) or "" 			-- Save all the GUI dropdown list Tags
		end
		tblSet.Seek = txtSeekText.Value											-- Save text strings
		tblSet.Swap = txtSwapText.Value
		tblSet.Mode = nil															-- Mode and Data Ref are not saved
		tblSet.Data = nil
		tblTgl.Conf = tglConfirm.Value											-- Save all mode toggles
		tblTgl.Text = tglTextPlain.Value
		tblTgl.Case = tglCaseInse.Value
		tblTgl.Word = tglWordWhole.Value
		tblTgl.Age  = tglAge_Inc.Value
		tblTgl.Date = tglDateInc.Value
		SaveSettings()																-- Save sticky data settings
	end -- local function saveOptions

	function tglTextPlain:action(intState)										-- Action for Plain Text Mode v LUA Pattern Mode radio toggle
		setTextMode()
	end -- function tglTextPlain:action

	function tblToggle.age:action(intState)									-- Action for Age fields toggle
		setWarnMode()
	end -- function tblToggle.age:action

	function tblToggle.date:action(intState)									-- Action for Date fields toggle
		setWarnMode()
	end -- function tblToggle.date:action

	local function doPerformAction()											-- Perform action for both Search & Replace and Search ONLY button
		if tblSet.Seek:match("\n") or tblSet.Swap:match("\n") then		-- Check newline characters are only used with Long Text fields -- V2.1
			local strToggle = "OFF"
			for intItem, tblItem in ipairs ( tblShortText ) do
				if tblTgl[tblItem[1]] == "ON" then								-- Must check before true/false adjustment below as main toggle may get disabled
					strToggle = "ON"												-- Short Text option selected
					break
				end
			end
			if strToggle == "ON"													-- Short Text or Record Title or Age or Date selected?
			or tblTgl["SOUR.TITL"] == "ON"										-- Source Title is Long Text, but others are Short Text, and Source Title unlikely to have newlines
			or tblTgl.age == "ON"
			or tblTgl.date == "ON" then
				iup_gui.MemoDialogue("\n  Newline characters in Search &&/or Replace text  \n  are reserved exclusively for Long Text Fields.  \n")
				return false
			end
		end
		for strName, strValue in pairs ( tblTgl ) do							-- TblOptions can be altered as SaveSettings() is not now called except via saveOptions()
			tblTgl[strName] = ( strValue == "ON" )								-- Swap "ON" to true, and "OFF" to false, in all toggle options
		end
		for strSource, tblTarget in pairs ( tblRelated ) do
			for _, strTarget in ipairs ( tblTarget ) do						-- Settings for related target Classes & Tags from source options
				tblTgl[strTarget] = tblTgl[strSource]
			end
		end
		for strName, anyValue in pairs ( tblList ) do						-- Adjust true/false settings for related drop list tags
			if tblTgl[strName] and tblLst[strName] ~= "" then				-- Matching main toggle option is ticked and dropdown list has selected a tag
				local strTag = tblLst[strName]:replace(".NOTE",".NOTE2")
				tblTgl[strName] = ( strName == strTag )
				for _, strTarget in ipairs ( tblRelated[strName] or {} ) do
					tblTgl[strTarget] = ( strTarget == strTag )
				end
				tblTgl[strTag] = true
			end
		end
		if tblTgl.Text then															-- Plain Text search mode
			tblTgl.Text = " Plain Text "
			tblSet.Seek = tblSet.Seek:plain()									-- Hide any LUA pattern magic characters
			tblSet.Swap = tblSet.Swap:plain()
			if tblTgl.Case then														-- Set the Case Insensitive search mode
				tblSet.Seek = tblSet.Seek:gsub("%a",function(c) return "["..c:lower()..c:upper().."]" end)
			end
			if tblSet.Seek:match("^[%s%p]+$") then								-- V2.1 Exclude seek for white space &/or punctuation from Whole Word search
				tblTgl.Word = false
			end
		else
			tblTgl.Text = " LUA Pattern "										-- LUA Pattern search mode
			tblTgl.Case = false														-- Must disable Case Insensitive and Whole Word searches
			tblTgl.Word = false
		end
		if tblSet.Seek == "" then
			tblSet.Seek = "^$"														-- Empty search string must use empty LUA pattern -- V2.0
			tblTgl.Word = false														-- and disable Whole Word search mode
		end
		if tblSet.Swap == "" then													-- Change to any char < "\07" as it cannot be enterd by user even via Alt+001
			tblSet.Swap = "\01" 													-- Use SOH="\01" character so DoSeekMatch() always detects a change -- V2.0
		end
		local tblUser = iup_gui.DialogueAttributes("Main")					-- Customise the Replace dialogue to use Main dialogue size & position
		iup_gui.CustomDialogue("User",tblUser.MinSize,tblUser.Raster,tblUser.CoordX,tblUser.CoordY)
		DoAllItems()																	-- Perform the Search and optional Replace process
		return true
	end -- local function doPerformAction

	local function doSearchReplace()
		saveOptions()
		local strSeek = tblSet.Seek
		local strSwap = tblSet.Swap
		tblSet.Mode = "Replace"
		if doPerformAction() then
			if #TblRecord == 0 then
				iup_gui.MemoDialogue("\n  No matching data items have been replaced.  \n")
			else																		-- Output Result Set for replacements
				local strTitle = "Search and Replace Results "
				local strSubTitle = "Replacing"..tblTgl.Text..strSeek.." with "..strSwap
				fhOutputResultSetTitles(strTitle..strSubTitle, strTitle, strSubTitle.."    Date: %#x")
				fhOutputResultSetColumn("Record Name", "item", TblRecord  , #TblRecord, 180, "align_left")
				fhOutputResultSetColumn("Data Ref"   , "text", TblDataRef , #TblRecord, 090, "align_left")
				fhOutputResultSetColumn("Old Value"  , "text", TblOldValue, #TblRecord, 180, "align_left")
				fhOutputResultSetColumn("New Value"  , "item", TblNewValue, #TblRecord, 180, "align_left")
				return iup.CLOSE 
			end
		end
	end -- local function doSearchReplace

	function btnReplaces:action()												-- Action for Basic Search & Replace button
		return doSearchReplace()
	end -- function btnReplaces:action

	function btnReplacer:action()												-- Action for Extra Search & Replace button
		return doSearchReplace()
	end -- function btnReplacer:action

	local function doSearchOnly()
		saveOptions()
		local strSeek = tblSet.Seek
		tblSet.Mode = "Report"
		if doPerformAction() then
			if #TblRecord == 0 then
				iup_gui.MemoDialogue("\n  No matching data items have been reported.  \n")
			else																		-- Output Result Set for reported text
				local strTitle = "Search Results "
				local strSubTitle = "Searching for"..tblTgl.Text..strSeek
				fhOutputResultSetTitles(strTitle..strSubTitle, strTitle, strSubTitle.."    Date: %#x")
				fhOutputResultSetColumn("Record Name", "item", TblRecord  , #TblRecord, 180, "align_left")
				fhOutputResultSetColumn("Data Ref"   , "text", TblDataRef , #TblRecord, 090, "align_left")
				fhOutputResultSetColumn("Data Value" , "item", TblNewValue, #TblRecord, 180, "align_left")
				return iup.CLOSE 
			end
		end
	end -- local function doSearchOnly

	function btnSearches:action()												-- Action for Basic Search ONLY button
		return doSearchOnly()
	end -- function btnSearches:action

	function btnSearcher:action()												-- Action for Extra Search ONLY button
		return doSearchOnly()
	end -- function btnSearcher:action

	function btnDefault:action()													-- Action for Restore Defaults button
		ResetDefaultSettings()
		iup_gui.ShowDialogue("Help")
		txtSeekText.Value = tblSet.Seek											-- Reset controls & redisplay Main dialogue
		txtSwapText.Value = tblSet.Swap
		tglConfirm.Value  = tblTgl.Conf
		tglConfirm.Tip    = tblConfirm[tglConfirm.Value]
		radTextMode.Value = iupValue(tblTgl.Text,tglTextPlain,tglTextPatt)
		radCaseMode.Value = iupValue(tblTgl.Case,tglCaseInse ,tglCaseSens)
		radWordMode.Value = iupValue(tblTgl.Word,tglWordWhole,tglWordPart)
		radAge_Mode.Value = iupValue(tblTgl.Age ,tglAge_Inc  ,tglAge_Exc )
		radDateMode.Value = iupValue(tblTgl.Date,tglDateInc  ,tglDateExc )
		for strName, iupValue in pairs ( tblToggle ) do
			tblToggle[strName].Value = tblTgl[strName] or "ON"
		end
		setListTags()																-- Set values for matching dropdown list tags -- V2.1
		setTabMode(0)
		setTextMode()																-- Set Text Case & Word Modes depending on Plain Text/LUA Pattern mode
		setWarnMode()																-- Set Date & Age Warning mode depending on Date & Age toggle settings
		iup_gui.ShowDialogue("Main")
		SaveSettings()																-- Save sticky data settings
	end -- function btnDefault:action

	function btnSetFont:action()													-- Action for Set Window Font button
		if iup_gui.FontDialogue() then
			for i, control in ipairs ({ frmOptions, frmBasicFilt, frmShortText, frmLongText, frmDistinct, btnReplacer, btnSearcher, btnReplaces, btnSearches, tabControl }) do
				control.Font = iup_gui.FontHead
			end
			for i, control in ipairs ({ boxOptions, boxBasicShort, boxBasicLong, boxShortText, boxLongText, boxDistinct, boxButtons, }) do
				control.Font = iup_gui.FontBody
			end
			SaveSettings()															-- Save sticky data settings
		end
	end -- function btnFontSet:action

	function btnGetHelp:action()													-- Action for Help & Advice button
		iup_gui.HelpDialogue()
	end -- function btnGetHelp:action

	function btnDestroy:action()													-- Action for Close Plugin button
		saveOptions()
		return iup.CLOSE 
	end -- function btnDestroy:action

	iup_gui.ShowDialogue("Main",dialogMain,btnDestroy,"map")				-- Map dialogue to allow dropdown lists to be managed

	function tabControl:tabchangepos_cb(intNew,intOld)						-- Call back when Main tab position is changed  
		IntTabPosn = intNew + 1
		setTabMode(intNew)
--		saveOptions()
	end -- function tabControl:tabchangepos_cb

	setListTags()																	-- Set values for matching dropdown list tags -- V2.1

	IntTabPosn = 1
	setTabMode(IntTabPosn-1)														-- Will eventually use sticky IntTabPosn

	setTextMode()																	-- Set Text Case & Word Modes depending on Plain Text/LUA Pattern mode
	setWarnMode()																	-- Set Date & Age Warning mode depending on Date & Age toggle settings

	iup_gui.ShowDialogue("Main")

end -- function GUI_MainDialogue

-- Main Code Section Starts Here --

	fhInitialise(5,0,0,"save_recommended")

	PresetGlobalData()																-- Preset global data definitions

	ResetDefaultSettings()															-- Preset default sticky settings

	LoadSettings()																	-- Load sticky data settings

	iup_gui.CheckVersionInStore()												-- Notify if later Version

	GUI_MainDialogue()																-- Invoke graphical user interface
