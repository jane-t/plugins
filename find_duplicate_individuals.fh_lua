--[[
@Title:			Find Duplicate Individuals
@Author:			Mike Tate
@Version:			1.6
@LastUpdated:	4 July 2012
@Description:	Find duplicated Individual Records
@V1.6:				Fix bug with selecting subset, extra chronology checks
@V1.5:				1st Child name check, corrected Gen Gap check, better Date chronology check, tweaked other scores, improved run time estimate, Diagnostic mode.
@V1.4:				Fixed GUI size on Font change, fixed bug in last Update check, corrected run time estimate, added Burial Event, added Date chronology check.
@V1.3:				Proportional Generation gap score, separate Names table, Father & Mother Name & Soundex check, Result Set diagnostic sub-scores, GUI with selection options.
@V1.2:				Soundex checks runtime improvements, limit Name checks score, Event Date +/-50 days check, Place Name & Soundex check, Spouse Name & Soundex check, Generation gap check.
@V1.1:				Added child count comparison. Prune low scores from results to prevent exceeding memory.
@V1.0:				Initial version.
]]
	require "iuplua"										-- To access GUI window builder
	require "lfs"											-- To access LUA filing system
	require "iupluaole"										-- To access OLE subsystem
	require "luacom"										-- To access COM subsystem

-- Global Data Constants Definition --
function PresetGlobalConstants()

	-- GUI Global Constants

	StrPlugin			= "Find Duplicate Records"		-- Plugin title & version
	StrVersion		= " Version 1.6 "
	StrRed				= "255 000 000"						-- Color attributes
	StrAmber			= "250 160 000"
	StrGreen			= "000 120 000"
	StrBlue			= "000 000 255"
	StrGray			= "120 120 120"
	StrBlack			= "000 000 000"
	StrWhite			= "255 255 255"
	StrGap 			= "2"									-- Gap & Margin attributes
	StrMinMargin		= "1x1"
	StrBigMargin		= "8x8"
	StrFontSetTitle	= "Set Interface Font"
	IntFontPlain		= 1										-- Font Face & Style values for IntFontSet
	IntFontBold		= 2
	IntArialPlain	= 3
	IntArialBold		= 4
	IntTahomaPlain	= 5
	IntTahomaBold	= 6
	StrFontFace		= string.gsub(iup.GetGlobal("DEFAULTFONT"),",.*","")

	-- Filename Global Constants

	StrComputerName = os.getenv("COMPUTERNAME")

	StrStickyFile = fhGetPluginDataFileName()
	-- Allow plugins with variant filenames to use same plugin data files
	StrStickyFile = string.gsub(StrStickyFile,"\\"..StrPlugin..".+%.[D,d][A,a][T,t]$","\\"..StrPlugin..".dat")
	if StrStickyFile == "" then
		-- Use standalone GEDCOM path & filename..".fh_data\Plugin Data\" as the folder + the Plugin Filename..".dat"
		StrStickyFile = fhGetContextInfo("CI_GEDCOM_FILE")
		StrStickyFile = string.gsub(StrStickyFile, "%.[G,g][E,e][D,d]", ".fh_data")
		lfs.mkdir(StrStickyFile)
		StrStickyFile = StrStickyFile.."\\Plugin Data"
		lfs.mkdir(StrStickyFile)
		StrStickyFile = StrStickyFile.."\\"..StrPlugin..".dat"
	end

	-- Plugin data folder path name
	StrPluginPath = string.gsub(StrStickyFile,"\\"..StrPlugin.."%.[D,d][A,a][T,t]$","")

	-- Plugin data file root name
	local strPluginRoot = StrPluginPath.."\\"..StrPlugin

	-- Public data folder path name
	StrPublicPath = fhGetContextInfo("CI_PROJECT_PUBLIC_FOLDER")
	if StrPublicPath == "" then StrPublicPath = StrPluginPath end

end -- function PresetGlobalConstants

-- Split a string using separator --
function string:split(sep)
	local sep = sep or ":"
	local fields = {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) fields[#fields+1] = c end)
	return fields
end -- function string:split

-- Split a string into numbers using separators space or comma or x --
function string:SplitNumbers()
	local tblNum = {}
	self:gsub("([^%s,x]+)", function(c) tblNum[#tblNum+1] = c end)
	for i=1, #tblNum do
		tblNum[i] = tonumber(tblNum[i])
	end
	return tblNum
end -- function string:SplitNumbers

-- Check if file exists --
function FlgFileExists(strFileName)
	if lfs.attributes(strFileName,"mode") == "file" then
		return true
	else
		return false
	end
end -- function FlgFileExists
--[[
-- Check if folder exists --
function FlgFolderExists(strFolderName)
	if lfs.attributes(strFolderName,"mode") == "directory" then
		return true
	else
		return false
	end
end -- function FlgFolderExists
]]
-- Open File and return Handle --
function OpenFile(strFileName,strMode)
	local fileHandle, strError = io.open(strFileName,strMode)
	if fileHandle == nil then
		error("\n Unable to open file in \""..strMode.."\" mode. \n "..strFileName.." \n "..strError.." \n")
	end
	return fileHandle
end -- function OpenFile
--[[
-- Save string to file --
function SaveStringToFile(strString,strFileName)
	local fileHandle = OpenFile(strFileName,"w")
	fileHandle:write(strString)
	assert(fileHandle:close())
end -- function SaveStringToFile

-- Load string from file --
function StrLoadFromFile(strFileName)
	local fileHandle = OpenFile(strFileName,"r")
	local strString = fileHandle:read("*all")
	assert(fileHandle:close())
	return strString
end -- function StrLoadFromFile

-- Return the Path, Filename, and extension as 3 values --
function SplitFilename(strFilename)
	return string.match(strFilename, "(.-)([^\\]-([^%.]+))$")
end -- function SplitFilename

-- Return a Directory Tree entry & attributes on each iteration --
function DirTree(strDir)
	assert(strDir and strDir ~= "", "directory parameter is missing or empty")
	if string.sub(strDir, -1) == "/" then
		strDir = string.sub(strDir, 1, -2)		-- Remove trailing "/"
	end
    
	local function doYieldTree(strDir)
		for strEntry in lfs.dir(strDir) do
			if strEntry ~= "." and strEntry ~= ".." then
				strEntry = strDir.."\\"..strEntry
				local tblAttr = lfs.attributes(strEntry)
				coroutine.yield(strEntry,tblAttr)
				if tblAttr.mode == "directory" then
					doYieldTree(strEntry)
				end
			end
		end
	end -- local function doYieldTree

	return coroutine.wrap(function() doYieldTree(strDir) end)
end -- function DirTree

-- Delete file if it exists --
function DeleteFile(strFileName)
	if FlgFileExists(strFileName) then
		local fileHandle, strError = os.remove(strFileName)
		if fileHandle == nil then
			local intRepeat = 1
			repeat
				if intRepeat > 1 and ShowStatusMessage then ShowStatusMessage(StrRed,string.gsub(strError,strFileName:match("(.+\\).+"),"Del#"..tostring(intRepeat)..":")) end
				fhSleep(300,100)
				if FlgFileExists(strFileName) then
					fileHandle, strError = os.remove(strFileName)
				end
				intRepeat = intRepeat + 1
			until fileHandle ~= nil or intRepeat > 10
			if intRepeat > 10 and not ShowStatusMessage then error(string.gsub(strError,strFileName:match("(.+\\).+"),"Del#"..tostring(intRepeat)..":")) end
		end
	end
end -- function DeleteFile

function DoExecute(strExecutable, strParameter)
	local isOK, intErrorCode, strErrorText = fhShellExecute(strExecutable, strParameter)
	if not isOK then
		fhMessageBox(strErrorText.." ("..intErrorCode..")")
	end
end -- function DoExecute
]]
-- Inhibit Regular Expression magic characters ^$()%.[]*+-?)
function StrPlainText(strText)
	-- Prefix every non-alphanumeric character (%W) with a % escape character, where %% is the % escape, and %1 is original character
	return strText:gsub("(%W)","%%%1")
end -- function StrPlainText

-- Obtain Version in Plugin Store by Id or Name --
function StrVersionInStore(strPlugin)
	local strType = "name="
	if tonumber(strPlugin) then strType = "id=" end
	if strPlugin then
		local http = luacom.CreateObject("winhttp.winhttprequest.5.1")
		local strRequest ="http://www.family-historian.co.uk/lnk/checkpluginversion.php?"..strType..strPlugin
 		http:Open("GET",strRequest,false)
		http:Send()
		local strReturn = http.Responsebody
		local strVersion = ""
		if strReturn ~= nil then
			strVersion = strReturn:match("(%d.*),%d*")
		end
		return strVersion or "0"
	else
		return "0"
	end
end -- function StrVersionInStore

-- Check if New Version Available --
function CheckVersionInStore(strOldVer)
	local strPlugin = fhGetContextInfo("CI_PLUGIN_NAME")
	local strNewVer = StrVersionInStore(strPlugin)
	if strNewVer > strOldVer:match("[^%d]*([%d%.]*)") then
		iup.Alarm(strPlugin..strOldVer,"Later Version "..strNewVer.." of this Plugin is available from the Family Historian 'Plugin Store'.","OK")
	end
end -- function CheckVersionInStore

-- Flag if GUI Window is Normal rather than Minimised or Maximised --
function IsNormalWindow(dialogGUI)
	-- tblScrn[1] = origin x, tblScrn[2] = origin y, tblScrn[3] = width, tblScrn[4] = height
	local tblPosn = dialogGUI.screenposition:SplitNumbers()
	local intPosX = tblPosn[1]
	local intPosY = tblPosn[2]
	if intPosX < 0 and intPosY < 0 then						-- If origin is negative (-8, -8 = Maximised, -3200, -3200 = Minimised)
		return false												-- then is Maximised or Minimised
	end
	return true
end -- function IsNormalWindow

-- GUI Font Face & Style Dialogue --
function GUI_FontDialogue(intFontSet)

	-- Note: Pixel sizes -21 = -20 & -17 = -16 & -14 = -13 and pixel sizes -22, -18 & -13 have no point size equivalent.
	local tblFontSet = {}			-- Lookup table for StrFontHead and StrFontBody font sets
	tblFontSet[IntFontPlain]		=	{ Head=StrFontFace..", Bold -16",	Body=StrFontFace..",      -16", }
	tblFontSet[IntFontBold]		=	{ Head=StrFontFace..", Bold -16",	Body=StrFontFace..", Bold -15", }
	tblFontSet[IntArialPlain]		=	{ Head="Arial,         Bold -16",	Body="Arial,              -16", }
	tblFontSet[IntArialBold]		=	{ Head="Arial,         Bold -16",	Body="Arial,         Bold -15", }
	tblFontSet[IntTahomaPlain]	=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,             -16", }
	tblFontSet[IntTahomaBold]		=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,        Bold -14", }

	-- Assign font set global variables
	local function doAssignFontSet(intFontSet)
		IntFontSet = intFontSet
		StrFontHead = tblFontSet[intFontSet]["Head"] -- Font for all GUI dialog header text
		StrFontBody = tblFontSet[intFontSet]["Body"] -- Font for all GUI dialog body text
	end -- local function doAssignFontSet

	-- If parameter exists, simply set it as current font set
	if intFontSet then doAssignFontSet(intFontSet) return end

	local strAnswer = "Change"

	local strFontPlainTitle	= StrFontFace.." Plain"
	local strFontBoldTitle		= StrFontFace.." Bold"
	local strArialPlainTitle	= "Arial Plain"
	local strArialBoldTitle	= "Arial Bold"
	local strTahomaPlainTitle	= "Tahoma Plain"
	local strTahomaBoldTitle	= "Tahoma Bold"

	-- Create each GUI label and button with title and tooltip
	local	lblHeadName		= iup.label	{ title=" Name :"				, tip="Names of the available Fonts"				, }
	local	lblHeadPlain		= iup.label	{ title=" Plain :"				, tip="Plain versions of the Fonts"					, }
	local	lblHeadBold		= iup.label	{ title=" Bold :"				, tip="Bold versions of the Fonts"					, }
	local	lblFontName		= iup.label	{ title="Font "..StrFontFace	, tip="Default Windows fontface"					, }
	local	btnFontPlain		= iup.button	{ title=strFontPlainTitle		, tip="Choose "..strFontPlainTitle.." style"		, }
	local	btnFontBold		= iup.button	{ title=strFontBoldTitle		, tip="Choose "..strFontBoldTitle.." style"		, }
	local	lblArialName		= iup.label	{ title="Font Arial"			, tip="Arial alternative fontface"					, }
	local	btnArialPlain	= iup.button	{ title=strArialPlainTitle	, tip="Choose "..strArialPlainTitle.." style"	, }
	local	btnArialBold		= iup.button	{ title=strArialBoldTitle		, tip="Choose "..strArialBoldTitle.." style"		, }
	local	lblTahomaName	= iup.label	{ title="Font Tahoma"			, tip="Tahoma alternative fontface"					, }
	local	btnTahomaPlain	= iup.button	{ title=strTahomaPlainTitle	, tip="Choose "..strTahomaPlainTitle.." style"	, }
	local	btnTahomaBold	= iup.button	{ title=strTahomaBoldTitle	, tip="Choose "..strTahomaBoldTitle.." style"	, }
	local	lblChoose			= iup.label	{ title="Choose your interface font style or"										, }
	local	btnClose			= iup.button	{ title="Close"					, tip="Close this Font Style window"				, }

	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local	dialogFont		= iup.dialog { title=(StrPlugin or "").." Font Style", dialogframe="YES", background=StrWhite, startfocus=btnClose,
										iup.vbox { alignment="ACENTER", gap=StrGap, margin=StrBigMargin,
											iup.frame { font=StrFontHead, fgcolor=StrBlack, active="YES", title="Font Style",
												iup.vbox { margin=StrMinMargin,
													iup.hbox { homogeneous="YES", lblHeadName,	lblHeadPlain,	lblHeadBold,		},
													iup.hbox { homogeneous="YES", lblFontName,	btnFontPlain,	btnFontBold,		},
													iup.hbox { homogeneous="YES", lblArialName,	btnArialPlain,	btnArialBold,	},
													iup.hbox { homogeneous="YES", lblTahomaName,	btnTahomaPlain,	btnTahomaBold,	},
													iup.hbox { lblChoose, btnClose, },
												},
											},
										},
										move_cb	= function(self,x,y) IntDataX=x IntDataY=y end,
										close_cb	= function() strAnswer="Ignore" return iup.CLOSE end,
									}

	-- Assign font styles for GUI labels and buttons
	local strFontPlain		= tblFontSet	[IntFontPlain]	["Body"]
	local strFontBold		= tblFontSet	[IntFontBold]	["Body"]
	local strArialPlain		= tblFontSet	[IntArialPlain]	["Body"]
	local strArialBold		= tblFontSet	[IntArialBold]	["Body"]
	local strTahomaPlain	= tblFontSet	[IntTahomaPlain]["Body"]
	local strTahomaBold		= tblFontSet	[IntTahomaBold]	["Body"]

	-- Set other GUI attributes for labels and buttons
	for iupName, tblAttr in pairs( {
		--	Control		=	1~fgcolor	, 2~font			, 3~FontSet		, 4~action function()
		[lblHeadName]	= { StrBlack	, StrFontBody	, false			, false	},
		[lblHeadPlain]	= { StrBlack	, strFontPlain	, false			, false	},
		[lblHeadBold]	= { StrBlack	, strFontBold	, false			, false	},
		[lblFontName]	= { StrBlack	, strFontPlain	, false			, false	},
		[btnFontPlain]	= { StrGreen	, strFontPlain	, IntFontPlain	, false	},
		[btnFontBold]	= { StrGreen	, strFontBold	, IntFontBold	, false	},
		[lblArialName]	= { StrBlack	, strArialPlain	, false			, false	},
		[btnArialPlain]	= { StrGreen	, strArialPlain	, IntArialPlain	, false	},
		[btnArialBold]	= { StrGreen	, strArialBold	, IntArialBold	, false	},
		[lblTahomaName]	= { StrBlack	, strTahomaPlain, false			, false	},
		[btnTahomaPlain]= { StrGreen	, strTahomaPlain, IntTahomaPlain, false	},
		[btnTahomaBold]	= { StrGreen	, strTahomaBold	, IntTahomaBold	, false	},
		[lblChoose]		= { StrBlack	, StrFontBody	, false			, false	},
		[btnClose]		= { StrRed	, StrFontBody	, false			, dialogFont.close_cb },
		} ) do
		iupName.expand	= "YES"
		iupName.fgcolor	= tblAttr[1]
		iupName.font		= tblAttr[2]
		if tblAttr[3] then
			if tblAttr[3] == IntFontSet then iupName.active = "NO" end	-- Disable button for currently selected font
			iupName.action = function() doAssignFontSet(tblAttr[3]) return iup.CLOSE end
		end
		if tblAttr[4] then iupName.action = tblAttr[4] end
	end

	if iup.MainLoopLevel() == 0 then	-- called from outside Main GUI, so must use showxy() instead of popup()
		dialogFont:showxy(IntDataX,IntDataY)
	else
		dialogFont:popup(IntDataX,IntDataY)
	end

	if (iup.MainLoopLevel()==0) then iup.MainLoop() end

	return strAnswer
end -- function GUI_FontDialogue

ProgressBar = {

	Start = function(strTitle,intMax)																-- Create & start Progress Bar window
		if not DlgGauge then
			IsBarStop = false
			IntStart = os.time()
			IntDelta = 0
			StrClock = "00:00:00"
			local	btnStop	= iup.button	{ title="Stop "..strTitle, font=StrFontBody, rastersize="200x30", fgcolor=StrRed, action=function() IsBarStop = true end, }	-- Signal Stop button pressed	return iup.CLOSE -- Often caused main GUI to close !!!
					BarGauge	= iup.progressbar { rastersize="400x30", value=0, max=intMax, }	-- Progress bar maximum range
					LblText	= iup.label	{ title=" ", expand="YES", alignment="ACENTER", tip="Percentage and Time Elapsed", }
					DlgGauge	= iup.dialog	{ title=strTitle.." Progress", dialogframe="YES", background=StrWhite,	-- Remove Windows minimize/maximize menu
										iup.vbox{ alignment="ACENTER", gap="10", margin=StrBigMargin or "8x8",
											LblText,
											BarGauge,
											btnStop,
										},
										move_cb	= function(self,x,y) IntDataX=x IntDataY=y end,
										close_cb	= btnStop.action,									-- Windows Close button = Stop button
									}
			DlgGauge:showxy(IntDataX,IntDataY)														-- Show the Progress Bar window
		end
	end,

	SetText = function(strText)																		-- Show the Progress text message
		if DlgGauge then LblText.title = strText end
	end,

	Step = function(intStep)																			-- Step the Progress Bar forward
		if DlgGauge then
			local intVal = tonumber(BarGauge.value)
			local intMax = tonumber(BarGauge.max)
			intVal = intVal + intStep
			if intVal > intMax then intVal = intMax end											-- Ensure value does not exceed maximum
			BarGauge.value = intVal
			local intDelta = os.difftime(os.time(),IntStart)
			if IntDelta < intDelta then																-- Update clock of elapsed time
				IntDelta = intDelta
				local intHour = math.floor( intDelta / 3600 )
				local intMins = math.floor( intDelta / 60 - intHour * 60 )
				local intSecs = intDelta - intMins * 60 - intHour * 3600
				StrClock = string.format("%02d : %02d : %02d",intHour,intMins,intSecs)
--				DlgGauge.bringfront = "YES"															-- If used too often, inhibits other windows scroll bars, etc
			end
			LblText.title = string.format("%4d %%      %s ", math.floor( intVal / intMax * 100 ), StrClock) -- Display % and clock progress
			iup.LoopStep()
		end
	end,

	Reset = function()																					-- Reset the Progress Bar
		if DlgGauge then BarGauge.value = 0 end
	end,

	Stop = function()																					-- Check if Stop button pressed
		return IsBarStop
	end,

	Close = function()																					-- Close the Progress Bar window
		IsBarStop = false
		if DlgGauge then DlgGauge:destroy() DlgGauge = nil end
	end,

} -- end ProgressBar

-- GUI Help & Advice Dialogue --
function GUI_HelpDialogue()

	local function doActivateMainHelpButton()
		if BtnHelp then BtnHelp.active = "YES" end
	end -- local function doActivateMainHelpButton

	-- create the WebBrowser based on its ProgID and connect it to LuaCOM
	local	oleControl = iup.olecontrol{ "Shell.Explorer.1", designmode="NO", }
			oleControl:CreateLuaCOM()

	-- Create each GUI button with title and tooltip
	local	btnIntro	= iup.button	{ title="Introduction"		, tip="Introduction for Help and Advice"	, }
--	local	btnIndex	= iup.button	{ title="Index of Names"	, tip="Index of Names Help and Advice"		, }
--	local	btnHyper	= iup.button	{ title="URL Hyperlinks"	, tip="URL Hyperlinks Help and Advice"		, }
	local	btnClose	= iup.button	{ title="Close Window"		, tip="Close this Help and Advice window"	, }

	-- The following controls are global to allow Main GUI to alter font and restore default position
	HboxHelp		=	iup.hbox { font=StrFontBody, margin=StrMinMargin, homogeneous="YES", btnIntro, btnClose, }
	DialogHelp	=	iup.dialog { title=StrPlugin.." Help & Advice", background=StrWhite, startfocus=btnClose, rastersize=StrHelpS,
							iup.vbox { alignment="ACENTER", margin=StrBigMargin, expandchildren="YES",
								oleControl,
								HboxHelp,
							},
							move_cb	= function(self,x,y) if IsNormalWindow(self) then IntHelpX=x IntHelpY=y end end,
							resize_cb	= function(self) if IsNormalWindow(self) then StrHelpS=self.rastersize end end,
							close_cb	= function() doActivateMainHelpButton() end,
						}

--	local strFHUG = "http://www.fhug.org.uk/wiki/doku.php?id=plugins:help:improve_html:"
	local strFHUG = "http://www.fhug.org.uk/wiki/doku.php?id=plugins:wip:find_duplicate_individuals"

	-- Set other GUI control attributes
	for iupName, tblAttr in pairs( {
		-- Control	=	1~fgcolor	, 2~Navigate URL, 3~action function()
		[btnIntro]	= { StrGreen	, "improve_html", false },
--		[btnIndex]	= { StrGreen	, "name_index"	, false },
--		[btnHyper]	= { StrGreen	, "hyperlinks"	, false },
		[btnClose]	= { StrRed	, false			, function() DialogHelp:destroy() doActivateMainHelpButton() end }
		} ) do
		iupName.expand	= "HORIZONTAL"
		iupName.size		= "x10"
		iupName.fgcolor	= tblAttr[1]
--		if tblAttr[2] then iupName.action = function() oleControl.com:Navigate(strFHUG..tblAttr[2]) end end
		if tblAttr[2] then iupName.action = function() oleControl.com:Navigate(strFHUG) end end
		if tblAttr[3] then iupName.action = tblAttr[3] end
	end

	DialogHelp:showxy(IntHelpX,IntHelpY)		-- Show Help GUI window
	DialogHelp.rastersize=nil						-- Allow window to be resized	nil = iup.NULL

--	oleControl.com:Navigate(strFHUG.."improve_html")
	oleControl.com:Navigate(strFHUG)

	if (iup.MainLoopLevel()==0) then iup.MainLoop() end

end -- function GUI_HelpDialogue

-- Graphical User Interface --
function GUI_MainDialogue()

	-- Create GUI controls
	local	lblDate	= iup.label	{ expand="YES", padding="10", fgcolor=StrBlack,	title="Include Individuals last Updated from Date", alignment="ACENTER" }
	local	txtDate	= iup.text	{ expand="YES", padding="10", fgcolor=StrGreen,	value="1 Jan 1900", alignment="ACENTER" }
	local	hbxDate	= iup.hbox	{ alignment="ACENTER", margin="10x0", lblDate, txtDate }

	local	btnPick	= iup.button	{ expand="YES", padding="10", fgcolor=StrGreen,	title="Include Selected Subset of the Individuals " }
	local	txtPick	= iup.text	{ expand="YES", padding="10", fgcolor=StrBlack,	value="99 Records", readonly="YES", alignment="ACENTER" }
	local	hbxPick	= iup.hbox	{ alignment="ACENTER", margin="10x0", btnPick, txtPick }

	local	lblList	= iup.label	{ expand="YES", padding="10", fgcolor=StrBlack,	title="Excludes any Individual Records placed in the 'Non-Duplicates' Named List", alignment="ACENTER" }
	local	hbxList	= iup.hbox	{ alignment="ACENTER", margin="10x0", lblList }

	local	btnFind	= iup.button	{ expand="YES", padding="10", fgcolor=StrGreen,	title=" Find any Duplicates from the Included set of Individuals " }
	local	tglDiag	= iup.toggle	{ expand="YES", padding="10", fgcolor=StrBlack,	title="Enable Diagnostic Mode:", value="OFF", rightbutton="YES" }
	local	hbxFind	= iup.hbox	{ alignment="ACENTER", margin="10x0", btnFind, tglDiag }

	local	lblTime	= iup.label	{ expand="YES", padding="10", fgcolor=StrBlack,	title="Estimated run time to check Individuals for Duplicates is 99 min 99 sec", alignment="ACENTER" }
	local	hbxTime	= iup.hbox	{ alignment="ACENTER", margin="10x0", lblTime }

	local	btnReset	= iup.button	{ expand="YES", padding="10", fgcolor=StrGreen,	title="Restore Defaults" }
	local	btnFont	= iup.button	{ expand="YES", padding="10", fgcolor=StrGreen,	title="Set Interface Font" }
			BtnHelp	= iup.button	{ expand="YES", padding="10", fgcolor=StrGreen,	title="  Help && Advice" }
	local	btnClose	= iup.button	{ expand="YES", padding="10", fgcolor=StrRed,	title="Close Plugin" }
	local	hbxOption	= iup.hbox	{ alignment="ACENTER", margin="10x0", btnReset, btnFont, BtnHelp, btnClose, homogeneous="YES" }

	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local	dialogMain =	iup.dialog { title=StrPlugin..StrVersion, dialogframe="YES", background=StrWhite, startfocus=btnClose, font=StrFontBody, rastersize="700",
								iup.vbox { alignment="ACENTER", gap="10", margin="10x10", hbxDate, hbxPick, hbxList, hbxFind, hbxTime, hbxOption },
								move_cb	=function(self,x,y) if IsNormalWindow(self) then IntMainX=x IntMainY=y end end,
							}
	local tblData	= {}														-- Data table of Record Id to include in candidate checks
	local intTotal	= 0															-- Total number of Idividual Records
	local intPick	= 0															-- Picked number of Individual Records
	local tblIndi	= {}														-- User selection of Individual Records
	local intDate	= 0															-- Date threshold for last Updated value

	local function intChosenRecord(ptrIndi)								-- Check if Record last Updated after chosen Date, and not in Named List
		local intRecId = fhGetRecordId(ptrIndi)
		tblData[intRecId] = {}													-- Create primary table of data entries per Record Id
		if ( fhCallBuiltInFunction("DayNumber",fhCallBuiltInFunction("LastUpdated",ptrIndi)) or 0 ) >= intDate
		and not fhCallBuiltInFunction("IsInList",ptrIndi,"Non-Duplicates") then
			tblData[intRecId]["Chosen"] = true								-- Flag the chosen Records to include
			return 1
		end
		return 0
	end -- local function intChosenRecord

	local function setEstimatedTime()										-- Set estimated run time based on chosen & total records
		local strTime = "less than a few minutes"
		local intScale = 60000000
		if tglDiag.value == "ON" then intScale = intScale / 20 end	-- Lengthen estimate in Diagnostic Mode
		local intMins = math.floor( intPick * intTotal / intScale )
		if intMins <= 0 then strTime = "only a few seconds" end
		if intMins >= 2 then strTime = "from "..intMins.." minutes to "..(intMins*4).." minutes" end
		lblTime.title = "Estimated run time to check for Duplicates is "..strTime
	end -- local function setEstimatedTime

	local function intPickRecords()											-- Pick chosen Individual Records
		intPick = 0
--		tblData = {}
		if #tblIndi == 0 then													-- No selection
			intTotal = 0
			local ptrIndi = fhNewItemPtr()
			ptrIndi:MoveToFirstRecord("INDI")
			while ptrIndi:IsNotNull() do
				intTotal = intTotal + 1
				intPick = intPick + intChosenRecord(ptrIndi)				-- So check all the Records
				ptrIndi:MoveNext()
			end
		else
			for intIndi = 1, #tblIndi do
				intPick = intPick + intChosenRecord(tblIndi[intIndi])	-- Check just selected Records
			end
		end
		txtPick.value = intPick.." Records"	
		setEstimatedTime()
		return intPick
	end -- local function intPickRecords

	local function setDateValue()											-- Set Date Value
		local strDate = txtDate.value
		local datDate = fhNewDate(9999)
		if datDate:SetValueAsText(strDate) then							-- Check that Date has valid format
			intDate = fhCallBuiltInFunction("DayNumber",datDate:GetDatePt1())
		end
		if not intDate then fhMessageBox("Unrecognised Date\n"..strDate) end
	end -- local function intSetDate

	function btnPick:action()													-- Action for Pick button
		dialogMain.active = "NO"
		tblIndi = fhPromptUserForRecordSel('INDI')
		txtPick.value = intPickRecords().." Records"						-- Pick and count the Records
		dialogMain.active = "YES"
	end -- function btnPick:action

	function txtDate:valuechanged_cb()										-- Call back after Date is edited
		setDateValue()
		txtPick.value = intPickRecords().." Records"
	end -- function txtDate:valuechanged_cb

	function btnFind:action()													-- Action for Find button
		dialogMain.active = "NO"
		if intPick > 0 then														-- If any Records chosen, then run Find Duplicates, which returns true if any found
			if FindDuplicateRecords(intTotal,tblData,tglDiag.value=="ON") then
				return iup.CLOSE
			end
		end
		dialogMain.bringfront = "YES"
		dialogMain.active = "YES"
	end -- function btnFind:action

	function tglDiag:action(intState)										-- Action for Diagnostic toggle
--		if intState == 0 then StrDiag = "OFF" end
--		if intState == 1 then StrDiag = "ON" end
		setEstimatedTime()														-- Increase run time estimate
--		SaveSettings(StrStickyFile)
	end -- function tglDiag:action

	function btnReset:action()												-- Action for Restore Defaults button
		ResetDefaultSettings()
		if	BtnHelp.active == "NO" then										-- If Help button inactive, then Help is active, so redisplay its dialogue
			DialogHelp.rastersize = StrHelpS
			DialogHelp:showxy(IntHelpX,IntHelpY)
		end
		txtDate.value = "1 Jan 1900"											-- Reset controls & redisplay Main dialogue
		setDateValue()
		tblIndi = {}
		txtPick.value = intPickRecords().." Records"
		dialogMain:showxy(IntMainX,IntMainY)
--		SaveSettings(StrStickyFile)											-- Save sticky data settings
	end -- function btnReset:action

	function btnFont:action()													-- Action for Set Interface Font button
		local strAnswer = GUI_FontDialogue()
		if strAnswer == "Change" then
			dialogMain.font	= StrFontBody
			if	BtnHelp.active == "NO" then									-- If Help button inactive, then Help is active, so update its font
				HboxHelp.font = StrFontBody
			end
--			SaveSettings(StrStickyFile)										-- Save sticky data settings
		end
	end -- function btnFont:action

	function BtnHelp:action()													-- Action for Help & Advice button
		BtnHelp.active = "NO"
		GUI_HelpDialogue()
	end -- function BtnHelp:action

	function btnClose:action()												-- Action for Close Plugin button
		return iup.CLOSE
	end -- function btnClose:action

	txtDate.value = "1 Jan 1900"
	setDateValue()
	txtPick.value = intPickRecords().." Records"

	dialogMain:showxy(IntMainX,IntMainY)

	if (iup.MainLoopLevel()==0) then iup.MainLoop() end

end -- function GUI_MainDialogue

-- Reset Sticky Settings to Default Values --
function ResetDefaultSettings()
	IntMainX		= iup.CENTER			-- GUI Main window position X & Y co-ordinate and rastersize
	IntMainY		= iup.CENTER
	IntHelpX		= iup.CENTER			-- GUI Help window position X & Y co-ordinate and rastersize
	IntHelpY		= iup.CENTER
	StrHelpS		= "1030x730"
	IntDataX		= iup.CENTER			-- ProgressBar window position X & Y co-ordinate
	IntDataY		= iup.CENTER
end -- function ResetDefaultSettings

-- Load Sticky Settings from File --
function LoadSettings(strFileName)

	local tblStickyData = {}

	-- Load Local Parameter for this PC --
	local function strLoadLocal(strParam,strDefault)
		return tblStickyData[StrComputerName.."-"..strParam] or strDefault
	end

	-- Load Global Parameter for all PC --
	local function strLoadGlobal(strParam,strDefault)
		return tblStickyData[strParam] or strDefault
	end

	-- Ensure Window Position is on Screen --
	local function intintCheckPosition(x,y)
		local tblScrn = iup.GetGlobal("VIRTUALSCREEN"):SplitNumbers()
		-- tblScrn[1] = origin x, tblScrn[2] = origin y, tblScrn[3] = width, tblScrn[4] = height
		if tonumber(x) == nil then
			x = iup.CENTER
		elseif tonumber(x) > tblScrn[3] then
			x = iup.CENTER
		end
		if tonumber(y) == nil then
			y = iup.CENTER
		elseif tonumber(y) > tblScrn[4] then
			y = iup.CENTER
		end
		return tonumber(x),tonumber(y)
	end -- local function intintCheckPosition

	if FlgFileExists(strFileName) then
		-- Load Settings File in table lines with key & val fields
		local tblField = {}
		for strLine in io.lines(strFileName) do
			tblField = strLine:split("=")
			tblStickyData[tblField[1]] = tblField[2]
		end
		IntMainX = tonumber(strLoadLocal("MainX",IntMainX))
		IntMainY = tonumber(strLoadLocal("MainY",IntMainY))
		IntHelpX = tonumber(strLoadLocal("HelpX",IntHelpX))
		IntHelpY = tonumber(strLoadLocal("HelpY",IntHelpY))
		StrHelpS = strLoadLocal			("HelpS",StrHelpS)
		IntDataX = tonumber(strLoadLocal("DataX",IntDataX))
		IntDataY = tonumber(strLoadLocal("DataY",IntDataY))
		IntFontSet= tonumber(strLoadGlobal("FontSet",IntFontSet))
	end
	IntMainX,IntMainY = intintCheckPosition(IntMainX,IntMainY)
	IntHelpX,IntHelpY = intintCheckPosition(IntHelpX,IntHelpY)
	IntDataX,IntDataY = intintCheckPosition(IntDataX,IntDataY)
	GUI_FontDialogue(IntFontSet)								-- Assign font set
	SaveSettings(strFileName)									-- Save sticky data settings
end -- function LoadSettings

-- Save Sticky Settings to File --
function SaveSettings(strFileName)

	local tblStickyData = {}

	-- Save Local Parameter for this PC --
	local function doSaveLocal(strParam,param)
		tblStickyData[StrComputerName.."-"..strParam] = param
	end

	-- Save Global Parameter for all PC --
	local function doSaveGlobal(strParam,param)
		tblStickyData[strParam] = param
	end

	doSaveLocal("MainX",IntMainX)
	doSaveLocal("MainY",IntMainY)
	doSaveLocal("HelpX",IntHelpX)
	doSaveLocal("HelpY",IntHelpY)
	doSaveLocal("HelpS",StrHelpS)
	doSaveLocal("DataX",IntDataX)
	doSaveLocal("DataY",IntDataY)
	doSaveGlobal("FontSet",IntFontSet)

	local fileHandle = OpenFile(strFileName,"w")
	for strKey,strVal in pairs(tblStickyData) do
		fileHandle:write(strKey.."="..strVal.."\n")
	end
	fileHandle:close()
end -- function SaveSettings

TblSoundex = {																		-- Soundex code lookup table is quicker Global than Local
	A=0,E=0,I=0,O=0,U=0,Y=0,	--	H=0,W=0,
	B=1,F=1,P=1,V=1,
	C=2,G=2,J=2,K=2,Q=2,S=2,X=2,Z=2,
	D=3,T=3,
	L=4,
	M=5,N=5,
	R=6
	}

-- Convert a Name to Soundex as per http://en.wikipedia.org/wiki/Soundex and http://creativyst.com/Doc/Articles/SoundEx1/SoundEx1.htm#SoundExAndCensus
function StrSoundex(strAnyName)
	strAnyName = string.upper(strAnyName:gsub("[^%a]",""))					-- Make name upper case letters only
	if strAnyName == "" then return "Z000" end
	local strSoundex = string.sub(strAnyName,1,1)							-- Soundex starts with initial letter
	local tblSoundex = TblSoundex
	local strLastNum = tblSoundex[strSoundex]									-- Set initial Soundex code
	for i = 2, string.len(strAnyName) do
		local strCodeNum = tblSoundex[string.sub(strAnyName,i,i)]			-- Step through Soundex code of each other letter
		if strCodeNum then
			if strCodeNum > 0 and strCodeNum ~= strLastNum then				-- Not a vowel nor same as previous code
				strSoundex = strSoundex..strCodeNum								-- So append Soundex code until 4 chars long
				if string.len(strSoundex) == 4 then return strSoundex end
			end
			strLastNum = strCodeNum												-- Save previous Soundex code, unless H or W
		end
	end
	return string.sub(strSoundex.."0000",1,4)									-- Pad code with zeroes to 4 chars long
end -- function StrSoundex

-- Obtain a Names & Soundex Dictionary for an Individual
function TblGetNamesData(ptrIndi)
		local tblName = {}
		local strName = ""
		local ptrName = fhGetItemPtr(ptrIndi,"~.NAME")
		while ptrName:IsNotNull() do												-- Loop through every NAME tag instance
			local strSurname = " "..StrPlainText(fhGetItemText(ptrName,"~:SURNAME")).." "
			for intRef, strRef in ipairs({"~:ADORNED_FULL","~.NICK","~._USED"}) do
				strName = fhGetItemText(ptrName,strRef).." "					-- Remove unnamed Names, and ensure Surname is uppercase
				strName = strName:gsub("%[unnamed person%]",""):gsub(strSurname,string.upper(strSurname))
				for strName in string.gmatch(strName,"[%a%d%.]+") do		-- Names comprise letters, digits & dots, and more than 2 chars
					if string.len(strName) > 2 and not tblName[strName] then
						tblName[strName] = 2										-- Ensure replicated Names & Soundex are eliminated
						tblName[StrSoundex(strName)] = 1
					end
				end
			end
			ptrName:MoveNext("SAME_TAG")
		end
	return tblName
end -- function TblGetNamesData

-- Obtain the BMD Event Data for an Individual
function TblGetEventData(ptrIndi,strTag)
	local dateDate = fhGetValueAsDate(fhGetItemPtr(ptrIndi,"~."..strTag..".DATE"))
	if dateDate:IsNull() then return nil end									-- If no Event Date, then return nil
	local pntLower = dateDate:GetDatePt1()										-- Lower end of Date range
	local intLower = fhCallBuiltInFunction("DayNumber",pntLower) or 0	-- Lower date missing Month uses Jan and missing Day uses 1st
	local pntUpper = dateDate:GetDatePt2()
	local intUpper = fhCallBuiltInFunction("DayNumber",pntUpper)			-- Upper end of Date range, or nil if single Date
	if intUpper then
		if   pntUpper:GetMonth() == 0 then intUpper = intUpper + 364		-- Upper date missing Month, so extend to end of Year
		elseif pntUpper:GetDay() == 0 then intUpper = intUpper + 30 end	-- Upper date missing Day, so extend to end of Month (could adjust according to Month?)
	else
		intUpper = intLower
		if   pntLower:GetMonth() == 0 then intUpper = intUpper + 364		-- Single Date, so set Upper date = Lower date and extend as above
		elseif pntLower:GetDay() == 0 then intUpper = intUpper + 30 end
	end
	local tblEvent = {}
	tblEvent["Lower"] = intLower													-- Save Lower & Upper Event Dates
	tblEvent["Upper"] = intUpper
	tblEvent["Place"] = {}
	local tblPlace = tblEvent["Place"]											-- Save Event Place & Soundex for each comma separated Place part
	for i, strPlace in ipairs(fhGetValueAsText(fhGetItemPtr(ptrIndi,"~."..strTag..".PLAC")):split(",")) do
		if string.len(strPlace) > 1 and not tblPlace[strPlace] then
			tblPlace[strPlace] = 1													-- Ensure replicated Places & Soundex are eliminated
			tblPlace[StrSoundex(strPlace)] = 1
		end
	end
	return tblEvent
end -- function TblGetEventData

-- Calculate the Score for Comparing two Events
function IntScoreEventData(tblEventA,tblEventB)
	local intScore = 0
	if tblEventA and tblEventB then												-- Both the Event Dates exist
		if math.abs( tblEventA["Lower"] - tblEventB["Lower"] ) < 50 then intScore = intScore + 2 end	-- Similar lower Date
		if math.abs( tblEventA["Upper"] - tblEventB["Upper"] ) < 50 then intScore = intScore + 2 end	-- Similar upper Date
		if math.max(tblEventA["Lower"],tblEventB["Lower"]) <= math.min(tblEventA["Upper"],tblEventB["Upper"]) then intScore = intScore + 2 end -- Dates ovelap
		if intScore == 0 then return -10 end									-- Dates completely different, so reduce score (previously -5)
		for strPlace in pairs(tblEventA["Place"]) do
			intScore = intScore + ( tblEventB["Place"][strPlace] or 0 )	-- Increase score for Place part or Soundex matches
		end
		return math.min(intScore,10)												-- Limit score to prevent multiple Place part matches overwhelming result
	end
	return 0
end -- function IntScoreEventData

-- Calculate the Score for Comparing Gender
function IntScoreGenderSex(strGenderA,strGenderB)
	if strGenderA == strGenderB then return 0 else return -10 end		-- Reduce score for gender mismatch
end -- function IntScoreGenderSex

-- Calculate the Score for Comparing Child Count
function IntScoreChildren(intCountA,intCountB)
	if intCountA == intCountB then return math.min(intCountA,5) end		-- Score is plus matching child count, capped at +5
	return -math.min(math.abs(intCountA-intCountB),5)						-- or minus difference in child count, capped at -5
end -- function IntScoreChildren

-- Calculate the Score for Comparing Gender Gap
function IntScoreGenGap(ptrIndiA,ptrIndiB)
	local intGensUp = fhCallBuiltInFunction("RelationCode",ptrIndiA,ptrIndiB,"GENS_UP",1) or 9	-- Always positive or nil
	local intGensDn = fhCallBuiltInFunction("RelationCode",ptrIndiA,ptrIndiB,"GENS_DOWN",1) or 9	-- Always positive or nil
	local intGenGap = intGensUp + intGensDn									-- spouse = 0, parent:child = 1, sibling/gparent:gchild = 2, etc
	local intMaxGap = 6
	if intGenGap < intMaxGap then												-- Reduce score according to closeness of relationship
		return ( intMaxGap - intGenGap ) ^ 2 * -5, intGensUp, intGensDn	-- i.e. spouse -180, parent:child -125, sibling/gparent:gchild -80, nephew/neice/uncle/aunt/ggparent/ggchild -45, etc
	end
	return 0, intGensUp, intGensDn
end -- function IntScoreGenGap

-- Sort the Results into Descending Order of Score
function SortResults(tblResults)
	table.sort( tblResults, function(tblA,tblB) return tblA["FullScore"] > tblB["FullScore"] end )
end -- function SortResults

-- Find Duplicate Records --
function FindDuplicateRecords(intTotal,tblData,flgDiag)					-- Total records, Data table with Record Id chosen, Diagnostic mode

	local function intKeyData(ptrIndi)											-- Get key Individual Record data
		if ptrIndi:IsNull() then return nil end
		local intData	= fhGetRecordId(ptrIndi)								-- Obtain the Record Id of Individual
		local tblIndi	= tblData[intData]
		if not tblIndi["Indiv"] then												-- Individual Record data needs to be saved
			tblIndi["Indiv"]	= ptrIndi:Clone()
			tblIndi["Names"]	= TblGetNamesData(ptrIndi)
			tblIndi["Birth"]	= TblGetEventData(ptrIndi,"BIRT")
			tblIndi["BapCh"]	= TblGetEventData(ptrIndi,"BAPM") or TblGetEventData(ptrIndi,"CHR")
			tblIndi["Marry"]	= TblGetEventData(ptrIndi,"FAMS>MARR")
			tblIndi["Death"]	= TblGetEventData(ptrIndi,"DEAT") or TblGetEventData(ptrIndi,"BURI")
			tblIndi["Child"]	= fhCallBuiltInFunction("ChildCount",ptrIndi)
			tblIndi["Gender"]	= fhGetItemText(ptrIndi,"~.SEX")
		end
		return intData
	end -- local function intKeyData

	local function intScoreNamesData(tblListA,tblListB)						-- Calculate the Score for Comparing two Name Lists
		if tblListA and tblListB then											-- Both the Name Lists exist
			local intScore = 0
			for strName in pairs(tblListA) do
				intScore = intScore + ( tblListB[strName] or 0 )			-- Increase score for Individual Name or Soundex matches
			end
			if intScore == 0 then return -10 end								-- Names completely different, so reduce score (previously -5)
			return math.min(intScore,10)											-- Limit score to prevent multiple Alternate Name matches overwhelming result
		end
		return 0
	end -- local function intScoreNamesData

	local function intScoreRelatives(intDataA,intDataB)						-- Calculate the Score for Comparing two Relatives
		if intDataA and intDataB then											-- Both the Record Id exist
			local tblIndiA = tblData[intDataA]
			local tblIndiB = tblData[intDataB]									-- Score Names and Event data
			intNames = intScoreNamesData(tblIndiA["Names"],tblIndiB["Names"])
			if intNames > 3 then	-- was 0
				local intBirth = IntScoreEventData(tblIndiA["Birth"],tblIndiB["Birth"])
				local intBapCh = IntScoreEventData(tblIndiA["BapCh"],tblIndiB["BapCh"])
				local intMarry = IntScoreEventData(tblIndiA["Marry"],tblIndiB["Marry"])
				local intDeath = IntScoreEventData(tblIndiA["Death"],tblIndiB["Death"])
				return intNames+intBirth+intBapCh+intMarry+intDeath, intNames, intBirth, intBapCh, intMarry, intDeath
			end
			return intNames, intNames, 0, 0, 0, 0
		end
		return 0, 0, 0, 0, 0, 0
	end -- local function intScoreRelatives

-- Calculate the Score for the Chronology of Event Dates i.e. Is Birth after Baptism after Marriage after Death ?
local function IntScoreDateChron(tblIndiA,tblIndiB)

	local function intLower(tblEvent,intEvent,strEvent)
		if tblEvent then return tblEvent["Lower"] end							-- Lower date range value
		if intEvent then tblEvent = tblData[intEvent][strEvent] end
		if tblEvent then return tblEvent["Lower"] end
		return 0
	end -- local function intLower

	local function intUpper(tblEvent,intEvent,strEvent)
		if tblEvent then return tblEvent["Upper"] end							-- Upper date range value
		if intEvent then tblEvent = tblData[intEvent][strEvent] end
		if tblEvent then return tblEvent["Upper"] end
		return 9999999
	end -- local function intUpper

	local intScore = 0

	if intLower(tblIndiA["Birth"]) > intUpper(tblIndiB["BapCh"],tblIndiB["Mother"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiA["Birth"]) > intUpper(tblIndiB["Marry"],tblIndiB["Spouse"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiA["Birth"],tblIndiA["Child1"],"Birth") > intUpper(tblIndiB["Death"]) then intScore = intScore - 10 end
	if intLower(tblIndiA["BapCh"]) > intUpper(tblIndiB["Marry"],tblIndiB["Spouse"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiA["BapCh"],tblIndiA["Child1"],"BapCh") > intUpper(tblIndiB["Death"]) then intScore = intScore - 10 end
	if intLower(tblIndiA["Marry"],tblIndiA["Spouse"],"Birth") > intUpper(tblIndiB["Death"]) then intScore = intScore - 10 end

	if intLower(tblIndiB["Birth"]) > intUpper(tblIndiA["BapCh"],tblIndiA["Mother"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiB["Birth"]) > intUpper(tblIndiA["Marry"],tblIndiA["Spouse"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiB["Birth"],tblIndiB["Child1"],"Birth") > intUpper(tblIndiA["Death"]) then intScore = intScore - 10 end
	if intLower(tblIndiB["BapCh"]) > intUpper(tblIndiA["Marry"],tblIndiA["Spouse"],"Death") then intScore = intScore - 10 end
	if intLower(tblIndiB["BapCh"],tblIndiB["Child1"],"BapCh") > intUpper(tblIndiA["Death"]) then intScore = intScore - 10 end
	if intLower(tblIndiB["Marry"],tblIndiB["Spouse"],"Birth") > intUpper(tblIndiA["Death"]) then intScore = intScore - 10 end

	return intScore
end -- local function IntScoreDateChron

	local tblRecId = {}																-- Individual Record Id pointers to Individual Record Data saved for comparisons
	local intMatches = 3															-- Score threshold for full comparisions and Result Set display
	local intMinimum = 0															-- Minimum score to retain in Results
	local tblResults = {}															-- Results for Individual Record matches
	local intResults = 199															-- Results entries maximum and Result Set display
	local isResult = true															-- Flag if completed run with Result Set
	local intStart = 400000														-- Threshold at which to start the Progress Bar
	local intInter = 16384															-- Interval between comparisons for Progress Bar Steps
	if flgDiag then
		intMatches = -100															-- Adjusted values for Diagnostic Mode
		intResults = 9999
		intStart = 40000
	end
	local intSteps = intTotal * ( intTotal-1 ) / 2							-- Number of Individual versus Individual comparisons
	if intSteps > intStart then ProgressBar.Start("Finding Duplicates",intSteps/intInter) end
	intSteps = 0
	local ptrIndiA = fhNewItemPtr()
	ptrIndiA:MoveToFirstRecord("INDI")
	while ptrIndiA:IsNotNull() do												-- Loop through every Individual Record

		local intDataA		= intKeyData(ptrIndiA)								-- Save key Individual Record Data against Record Id
		local tblIndiA		= tblData[intDataA]
		tblIndiA["Father"]	= intKeyData(fhGetItemPtr(ptrIndiA,"~.~FATH>"))
		tblIndiA["Mother"]	= intKeyData(fhGetItemPtr(ptrIndiA,"~.~MOTH>"))
		tblIndiA["Spouse"]	= intKeyData(fhGetItemPtr(ptrIndiA,"~.~SPOU>"))
		tblIndiA["Child1"]	= intKeyData(fhGetItemPtr(ptrIndiA,"~.~CHIL>"))
		table.insert(tblRecId,intDataA)

		if ProgressBar.Stop() then
			isResult = false
			break
		end
		for intIndiB = 1, #tblRecId - 1 do										-- Loop through prior Individual Record entries
			intSteps = ( intSteps + 1 ) % intInter
			if intSteps == 0 then ProgressBar.Step(1) end					-- Step Progress Bar occasionally

			local intDataB = tblRecId[intIndiB]									-- Lookup Individual Record Id
			local tblIndiB = tblData[intDataB]									-- Lookup Individual Record Data

			if tblIndiA["Chosen"] or tblIndiB["Chosen"] then				-- Only check Records that were Chosen in GUI

				local intIndiNames = intScoreNamesData(tblIndiA["Names"],tblIndiB["Names"])

				if intIndiNames > intMatches then								-- If some Names match, adjust score for BMD Events, Relations, etc

					local intIndiBirth	= IntScoreEventData(tblIndiA["Birth"],tblIndiB["Birth"])
					local intIndiBapCh	= IntScoreEventData(tblIndiA["BapCh"],tblIndiB["BapCh"])
					local intIndiMarry	= IntScoreEventData(tblIndiA["Marry"],tblIndiB["Marry"])
					local intIndiDeath	= IntScoreEventData(tblIndiA["Death"],tblIndiB["Death"])
					local intChildren	= IntScoreChildren (tblIndiA["Child"],tblIndiB["Child"])
					local intGenderSex	= IntScoreGenderSex(tblIndiA["Gender"],tblIndiB["Gender"])
					local intFathScore, intFathNames, intFathBirth, intFathBapCh, intFathMarry, intFathDeath = intScoreRelatives(tblIndiA["Father"],tblIndiB["Father"])
					local intMothScore, intMothNames, intMothBirth, intMothBapCh, intMothMarry, intMothDeath = intScoreRelatives(tblIndiA["Mother"],tblIndiB["Mother"])
					local intSpouScore, intSpouNames, intSpouBirth, intSpouBapCh, intSpouMarry, intSpouDeath = intScoreRelatives(tblIndiA["Spouse"],tblIndiB["Spouse"])
					local intChd1Score, intChd1Names, intChd1Birth, intChd1BapCh, intChd1Marry, intChd1Death = intScoreRelatives(tblIndiA["Child1"],tblIndiB["Child1"])

					local intFullScore	= intIndiNames+intIndiBirth+intIndiBapCh+intIndiMarry+intIndiDeath+intChildren+intGenderSex+intFathScore+intMothScore+intSpouScore+intChd1Score

					if intFullScore >= intMinimum then							-- Continue if score is above lowest retained Results entry
						local ptrIndiB	= tblIndiB["Indiv"]

						local intDateChron = IntScoreDateChron(tblIndiA,tblIndiB)	-- Check date chronology

						local intFamGenGap, intFamGensUp, intFamGensDn = IntScoreGenGap(ptrIndiA,ptrIndiB)	-- Only check generation gap now as it has a high run time overhead

						if ( intDateChron > -25 and intFamGenGap > -60 ) or flgDiag then -- Exclude major chronology mismatch, and exclude spouse, parent/child, sibling, gparent/gchild
							intFullScore = intFullScore+intDateChron+intFamGenGap
							table.insert( tblResults, {
									FullScore=intFullScore, PossibleA=ptrIndiA:Clone(), PossibleB=ptrIndiB:Clone(),
									IndiNames=intIndiNames, IndiBirth=intIndiBirth, IndiBapCh=intIndiBapCh, IndiMarry=intIndiMarry, IndiDeath=intIndiDeath,
									FathScore=intFathScore, FathNames=intFathNames, FathBirth=intFathBirth, FathBapCh=intFathBapCh, FathMarry=intFathMarry, FathDeath=intFathDeath,
									MothScore=intMothScore, MothNames=intMothNames, MothBirth=intMothBirth, MothBapCh=intMothBapCh, MothMarry=intMothMarry, MothDeath=intMothDeath,
									SpouScore=intSpouScore, SpouNames=intSpouNames, SpouBirth=intSpouBirth, SpouBapCh=intSpouBapCh, SpouMarry=intSpouMarry, SpouDeath=intSpouDeath,
									Chd1Score=intChd1Score, Chd1Names=intChd1Names, Chd1Birth=intChd1Birth, Chd1BapCh=intChd1BapCh, Chd1Marry=intChd1Marry, Chd1Death=intChd1Death,
									FamGenGap=intFamGenGap, FamGensUp=intFamGensUp, FamGensDn=intFamGensDn, DateChron=intDateChron, Children=intChildren, GenderSex=intGenderSex,
									} )
							if #tblResults > intResults then						-- Prune low scores from Results to avoid exceeding memory
								SortResults(tblResults)								-- Sort and remove the lower 75% of the scores
								for i = 1 , #tblResults * 3 / 4 do table.remove(tblResults) end
								intMinimum = tblResults[#tblResults]["FullScore"]
								if DlgGauge then DlgGauge.bringfront="YES" end	-- If used too often, inhibits other windows scroll bars, etc
							end
						end
					end
				end
			end
		end
		ptrIndiA:MoveNext()
	end
	ProgressBar.Close()

	SortResults(tblResults)

	local tblColumnKey =															-- Result Set Title and Index per Column
	{	{ "Names",	"IndiNames"	},
		{ "Birth",	"IndiBirth"	},
		{ "Bap/Ch",	"IndiBapCh"	},
		{ "Marry",	"IndiMarry"	},
		{ "Death",	"IndiDeath"	},
		{ "Gen.Gap",	"FamGenGap"	},
		{ "Gens-Up",	"FamGensUp"	},
		{ "Gens-Dn",	"FamGensDn"	},
		{ "Chron",	"DateChron"	},
		{ "Father",	"FathScore"	},
		{ "F-Names",	"FathNames"	},
		{ "F-Birth",	"FathBirth"	},
		{ "F-Bap/Ch","FathBapCh"	},
		{ "F-Marry",	"FathMarry"	},
		{ "F-Death",	"FathDeath"	},
		{ "Mother",	"MothScore"	},
		{ "M-Names",	"MothNames"	},
		{ "M-Birth",	"MothBirth"	},
		{ "M-Bap/Ch","MothBapCh"	},
		{ "M-Marry",	"MothMarry"	},
		{ "M-Death",	"MothDeath"	},
		{ "Spouse",	"SpouScore"	},
		{ "S-Names",	"SpouNames"	},
		{ "S-Birth",	"SpouBirth"	},
		{ "S-Bap/Ch","SpouBapCh"	},
		{ "S-Marry",	"SpouMarry"	},
		{ "S-Death",	"SpouDeath"	},
		{ "Child 1",	"Chd1Score"	},
		{ "C-Names",	"Chd1Names"	},
		{ "C-Birth",	"Chd1Birth"	},
		{ "C-Bap/Ch","Chd1BapCh"	},
		{ "C-Marry",	"Chd1Marry"	},
		{ "C-Death",	"Chd1Death"	},
		{ "Children","Children"	},
		{ "Gender",	"GenderSex"	},
	}
	local intFullScore	= 0															-- Full Score
	local tblFullScore	= {}
	local intRecordIdA	= 0															-- Record Id A & Individual A
	local tblRecordIdA	= {}
	local tblPossibleA	= {}
	local intRecordIdB	= 0															-- Record Id B & Individual B
	local tblRecordIdB	= {}
	local tblPossibleB	= {}
	local tblResultSet = {}														-- Table of Result Set Columns for sub-scores

	for intEntry = 1, math.min(#tblResults,intResults/2) do				-- Extract highest scoring entries & insert in Result Set Column tables
		local tblEntry = tblResults[intEntry]
		intFullScore = tblEntry["FullScore"]
		if intFullScore < intMatches then break end
		local ptrPossibleA = tblEntry["PossibleA"]							-- Record Pointer and Id of Individual A
		intRecordIdA = fhGetRecordId(ptrPossibleA)
		local ptrPossibleB = tblEntry["PossibleB"]							-- Record Pointer and Id of Individual B
		intRecordIdB = fhGetRecordId(ptrPossibleB)

		table.insert(tblFullScore,intFullScore)								-- Full Score
		table.insert(tblRecordIdA,intRecordIdA)								-- Individual Record Id A
		table.insert(tblPossibleA,ptrPossibleA)								-- Individual Record A
		table.insert(tblRecordIdB,intRecordIdB)								-- Individual Record Id B
		table.insert(tblPossibleB,ptrPossibleB)								-- Individual Record B

		for i, tblColumn in ipairs( tblColumnKey ) do
			local strIndex = tblColumn[2]
			if intEntry==1 then tblResultSet[strIndex] = {} end
			table.insert(tblResultSet[strIndex],tblEntry[strIndex])		-- Diagnostic sub-scores
		end
	end
	if tblFullScore[1] then														-- Output Result Set Columns
		local intSize = #tblFullScore
		fhOutputResultSetTitles(StrPlugin..StrVersion.."Candidates")
		fhOutputResultSetColumn(" Score "	, "integer"	, tblFullScore , intSize,  32, "align_mid" )
		fhOutputResultSetColumn("Rec Id A"	, "integer"	, tblRecordIdA , intSize,  32, "align_mid" )
		fhOutputResultSetColumn("Record A"	, "item"		, tblPossibleA , intSize, 150, "align_left")
		fhOutputResultSetColumn("Rec Id B"	, "integer"	, tblRecordIdB , intSize,  32, "align_mid" )
		fhOutputResultSetColumn("Record B"	, "item"		, tblPossibleB , intSize, 150, "align_left")

		for i, tblColumn in ipairs( tblColumnKey ) do						-- Diagnostic sub-scores
			local strTitle = tblColumn[1]
			local strIndex = tblColumn[2]
			if flgDiag or not strTitle:match("%-") then
				fhOutputResultSetColumn(strTitle, "integer", tblResultSet[strIndex], intSize, 32, "align_mid" )
			end 
		end
	else
		fhMessageBox("No Duplicate Individuals Found")
		isResult = false
	end
	return isResult
end -- function FindDuplicateRecords

-- Main Code Section Starts Here --

--	CheckVersionInStore(StrVersion)

	PresetGlobalConstants()			-- Preset global data constants

	ResetDefaultSettings()				-- Preset default sticky settings

	IntFontSet = IntFontPlain			-- Font Face & Style default

--	LoadSettings(StrStickyFile)		-- Load sticky data settings

	GUI_MainDialogue()					-- Invoke graphical user interface

--	SaveSettings(StrStickyFile)		-- Save sticky data settings
