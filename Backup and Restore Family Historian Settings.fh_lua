--[[
@Title:			Backup and Restore Family Historian Settings
@Author:			Mike Tate
@Version:			2.0
@LastUpdated:	20 Feb 2014
@Description:	Backup and Restore the Family Historian Custom & Preference Settings using any folder.
@Version Log:	See end of file.
]]

--[[
@Title:			aa Library Functions Preamble
@Author:			Mike Tate
@Version:			1.4
@LastUpdated:	15 Feb 2014
@Description:	All the library module functions as preamble for Plugins.
]]

---[==[

-- Initial +fh+ functions below should eventually become library modules --

--[[
@Title:			+fh+stringx_v2
@Author:			Mike Tate
@LastUpdated:	28 Dec 2013
@Version:			2.4
@Description:	Extended string functions to supplement LUA string library.
@V2.4:				Tolerant of integer & nil parameters just link match & gsub.
@V1.0:				Initial version.
]]

local function stringx_v2(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}									-- Local environment table
package.seeall(fh)								-- Enable all globals
module(...,package.seeall)					-- Create matching module name
setfenv(1,fh)									-- All public names are added to local fh table

function ReportVersion()
	local strMessage = "This is +fh+stringx_v2"
	print(strMessage)
	return strMessage
end

-- Split a string using "," or chosen separator --
function split(strTxt,strSep)
	local tblFields = {}
	local strPattern = string.format("([^%s]+)", strSep or ",")
	strTxt = tostring(strTxt or "")
	strTxt:gsub(strPattern, function(strField) tblFields[#tblFields+1] = strField end)
	return tblFields
end -- function split

-- Split a string into numbers using " " or "," or "x" separators	-- Any non-number remains as a string
function splitnumbers(strTxt)
	local tblNum = {}
	strTxt = tostring(strTxt or "")
	strTxt:gsub("([^ ,x]+)", function(strNum) tblNum[#tblNum+1] = tonumber(strNum) or strNum end)
	return tblNum
end -- function splitnumbers

-- Hide magic pattern symbols	^ $ ( ) % . [ ] * + - ?
function plain(strTxt)
	-- Prefix every non-alphanumeric character (%W) with a % escape character,
	-- where %% is the % escape, and %1 is the original character capture.
	strTxt = tostring(strTxt or ""):gsub("(%W)","%%%1")
	return strTxt
end -- function plain

-- matches is plain text version of string.match()
function matches(strTxt,strFind,intInit)
	strFind = tostring(strFind or ""):gsub("(%W)","%%%1")				-- Hide magic pattern symbols
	return tostring(strTxt or ""):match(strFind,tonumber(intInit))
end -- function matches

-- replace is plain text version of string.gsub()
function replace(strTxt,strOld,strNew,intNum)
	strOld = tostring(strOld or ""):gsub("(%W)","%%%1")					-- Hide magic pattern symbols
	return tostring(strTxt or ""):gsub(strOld,function() return strNew end,tonumber(intNum))	-- Hide % capture symbols
end -- function replace

-- convert is pattern without captures version of string.gsub()
function convert(strTxt,strOld,strNew,intNum)
	return tostring(strTxt or ""):gsub(tostring(strOld or ""),function() return strNew end,tonumber(intNum))	-- Hide % capture symbols
end -- function convert

-- import overloads fh functions into string table
function import()
	for strIndex, anyValue in pairs(fh) do
		if type(anyValue) == 'function' and strIndex ~= "import" then
			string[strIndex] = anyValue
		end
	end
end -- function import
return fh

end -- local function stringx_v2

--[[
@Module:			fh.tablex_v1
@Author:			Mike Tate
@Version:			1.1
@LastUpdated:	19 Oct 2013
@Description:	A Table Load Save Module.
@V1.0:				Initial version 0.94 is Lua 5.1 compatible.
]]

local function tablex_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

------------------------------------------------------ Start Table Load Save
-- require "_tableloadsave"
--[[
   Save Table to File/Stringtable
   Load Table from File/Stringtable
   v 0.94
   
   Lua 5.1 compatible
   
   Userdata and indices of these are not saved
   Functions are saved via string.dump, so make sure it has no upvalues
   References are saved
   ----------------------------------------------------
   table.save( table [, filename] )
   
   Saves a table so it can be called via the table.load function again
   table must a object of type 'table'
   filename is optional, and may be a string representing a filename or true/1
   
   table.save( table )
      on success: returns a string representing the table (stringtable)
      (uses a string as buffer, ideal for smaller tables)
   table.save( table, true or 1 )
      on success: returns a string representing the table (stringtable)
      (uses io.tmpfile() as buffer, ideal for bigger tables)
   table.save( table, "filename" )
      on success: returns 1
      (saves the table to file "filename")
   on failure: returns as second argument an error msg
   ----------------------------------------------------
   table.load( filename or stringtable )
   
   Loads a table that has been saved via the table.save function
   
   on success: returns a previously saved table
   on failure: returns as second argument an error msg
   ----------------------------------------------------
   
   chillcode, http://lua-users.org/wiki/SaveTableToFile
   Licensed under the same terms as Lua itself.
]]--

   -- declare local variables
   --// exportstring( string )
   --// returns a "Lua" portable version of the string
   local function exportstring( s )
      s = string.format( "%q",s )
      -- to replace
      s = string.gsub( s,"\\\n","\\n" )
      s = string.gsub( s,"\r","\\r" )
      s = string.gsub( s,string.char(26),"\"..string.char(26)..\"" )
      return s
   end
--// The Save Function
function save(  tbl,filename )
   local charS,charE = "   ","\n"
   local file,err
   -- create a pseudo file that writes to a string and return the string
   if not filename then
      file =  { write = function( self,newstr ) self.str = self.str..newstr end, str = "" }
      charS,charE = "",""
   -- write table to tmpfile
   elseif filename == true or filename == 1 then
      charS,charE,file = "","",io.tmpfile()
   -- write table to file
   -- use io.open here rather than io.output, since in windows when clicking on a file opened with io.output will create an error
   else
      file,err = io.open( filename, "w" )
      if err then return _,err end
   end
   -- initiate variables for save procedure
   local tables,lookup = { tbl },{ [tbl] = 1 }
   file:write( "return {"..charE )
   for idx,t in ipairs( tables ) do
      if filename and filename ~= true and filename ~= 1 then
         file:write( "-- Table: {"..idx.."}"..charE )
      end
      file:write( "{"..charE )
      local thandled = {}
      for i,v in ipairs( t ) do
         thandled[i] = true
         -- escape functions and userdata
         if type( v ) ~= "userdata" then
            -- only handle value
            if type( v ) == "table" then
               if not lookup[v] then
                  table.insert( tables, v )
                  lookup[v] = #tables
               end
               file:write( charS.."{"..lookup[v].."},"..charE )
            elseif type( v ) == "function" then
               file:write( charS.."loadstring("..exportstring(string.dump( v )).."),"..charE )
            else
               local value =  ( type( v ) == "string" and exportstring( v ) ) or tostring( v )
               file:write(  charS..value..","..charE )
            end
         end
      end
      for i,v in pairs( t ) do
         -- escape functions and userdata
         if (not thandled[i]) and type( v ) ~= "userdata" then
            -- handle index
            if type( i ) == "table" then
               if not lookup[i] then
                  table.insert( tables,i )
                  lookup[i] = #tables
               end
               file:write( charS.."[{"..lookup[i].."}]=" )
            else
               local index = ( type( i ) == "string" and "["..exportstring( i ).."]" ) or string.format( "[%d]",i )
               file:write( charS..index.."=" )
            end
            -- handle value
            if type( v ) == "table" then
               if not lookup[v] then
                  table.insert( tables,v )
                  lookup[v] = #tables
               end
               file:write( "{"..lookup[v].."},"..charE )
            elseif type( v ) == "function" then
               file:write( "loadstring("..exportstring(string.dump( v )).."),"..charE )
            else
               local value =  ( type( v ) == "string" and exportstring( v ) ) or tostring( v )
               file:write( value..","..charE )
            end
         end
      end
      file:write( "},"..charE )
   end
   file:write( "}" )
   -- Return Values
   -- return stringtable from string
   if not filename then
      -- set marker for stringtable
      return file.str.."--|"
   -- return stringttable from file
   elseif filename == true or filename == 1 then
      file:seek ( "set" )
      -- no need to close file, it gets closed and removed automatically
      -- set marker for stringtable
      return file:read( "*a" ).."--|"
   -- close file and return 1
   else
      file:close()
      return 1
   end
end

--// The Load Function
function load( sfile )
   local tables,err
   -- catch marker for stringtable
   if string.sub( sfile,-3,-1 ) == "--|" then
      tables,err = loadstring( sfile )
   else
      tables,err = loadfile( sfile )
   end
   if err then return _,err
   end
   tables = tables()
   for idx = 1,#tables do
      local tolinkv,tolinki = {},{}
      for i,v in pairs( tables[idx] ) do
         if type( v ) == "table" and tables[v[1]] then
            table.insert( tolinkv,{ i,tables[v[1]] } )
         end
         if type( i ) == "table" and tables[i[1]] then
            table.insert( tolinki,{ i,tables[i[1]] } )
         end
      end
      -- link values, first due to possible changes of indices
      for _,v in ipairs( tolinkv ) do
         tables[idx][v[1]] = v[2]
      end
      -- link indices
      for _,v in ipairs( tolinki ) do
         tables[idx][v[2]],tables[idx][v[1]] =  tables[idx][v[1]],nil
      end
   end
   return tables[1]
end

------------------------------------------------------ End Table Load Save

-- import overloads fh functions into table
function import()
	for strIndex, anyValue in pairs(fh) do
		if type(anyValue) == 'function' and strIndex ~= "import" then
			table[strIndex] = anyValue
		end
	end
end -- function import

return fh

end -- local function tablex_v1

--[[
@Title:			+fh+encoder_v2
@Author:			Mike Tate
@LastUpdated:	29 Oct 2013
@Version:			2.2
@Description:	Text encoder module for HTML XHTML XML URI UTF8 ISO CP1252 character codings.
@V2.0:				StrUTF8_Encode() replaced by StrUTF_CP1252() for entire UTF-8 range, plus new StrCP1252_ISO().
@V1.0:				Initial version.
]]

local function encoder_v2(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh) 													-- All public names are added to local fh table

function ReportVersion()
	local strMessage = "This is +fh+encoder_v2"
	print(strMessage)
	return strMessage
end

local br_Tag = "<br />"										-- Markup language break tag default
local br_Lua = "<br ?/?>"										-- Lua pattern for break tag recognition

local tblCodePage = {}											-- Code Page to XML/XHTML/HTML/URI/UTF8 encodings: http://en.wikipedia.org/wiki/Windows-1252 & 1250 & etc

-- Control characters "\000" to "\031" for URI & Markup "[%c]" encodings are disallowed except for "\t" to "\r"

	tblCodePage["\000"] = ""	-- NUL
	tblCodePage["\001"] = ""	-- SOH
	tblCodePage["\002"] = ""	-- STX
	tblCodePage["\003"] = ""	-- ETX
	tblCodePage["\004"] = ""	-- EOT
	tblCodePage["\005"] = ""	-- ENQ
	tblCodePage["\006"] = ""	-- ACK
	tblCodePage["\a"] = ""		-- BEL
	tblCodePage["\b"] = ""		-- BS
	tblCodePage["\t"] = "+"	-- HT	space  in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["\n"] = "%0A"	-- LF	br_Tag in Markup
	tblCodePage["\v"] = "%0A"	-- VT	br_Tag in Markup
	tblCodePage["\f"] = "%0A"	-- FF	br_Tag in Markup
	tblCodePage["\r"] = "%0D"	-- CR	br_Tag in Markup
	tblCodePage["\014"] = ""	-- SO
	tblCodePage["\015"] = ""	-- SI
	tblCodePage["\016"] = ""	-- DLE
	tblCodePage["\017"] = ""	-- DC1
	tblCodePage["\018"] = ""	-- DC2
	tblCodePage["\019"] = ""	-- DC3
	tblCodePage["\020"] = ""	-- DC4
	tblCodePage["\021"] = ""	-- NAK
	tblCodePage["\022"] = ""	-- SYN
	tblCodePage["\023"] = ""	-- ETB
	tblCodePage["\024"] = ""	-- CAN
	tblCodePage["\025"] = ""	-- EM
	tblCodePage["\026"] = ""	-- SUB
	tblCodePage["\027"] = ""	-- ESC
	tblCodePage["\028"] = ""	-- FS
	tblCodePage["\029"] = ""	-- GS
	tblCodePage["\030"] = ""	-- RS
	tblCodePage["\031"] = ""	-- US

-- ASCII characters "\032" to "\127" for URI "[%s%p]" encodings: http://en.wikipedia.org/wiki/URL and http://en.wikipedia.org/wiki/Percent-encoding

	tblCodePage[" "] = "+"		-- or "%20"	Space
	tblCodePage["!"] = "%21"	-- Reserved character
	tblCodePage['"'] = "%22"								--	"&quot;" in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["#"] = "%23"	-- Reserved character
	tblCodePage["$"] = "%24"	-- Reserved character
	tblCodePage["%"] = "%25"	-- Must be encoded
	tblCodePage["&"] = "%26"	-- Reserved character	-- "&amp;"  in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["'"] = "%27"	-- Reserved character	-- "&apos;" in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["("] = "%28"	-- Reserved character
	tblCodePage[")"] = "%29"	-- Reserved character
	tblCodePage["*"] = "%2A"	-- Reserved character
	tblCodePage["+"] = "%2B"	-- Reserved character
	tblCodePage[","] = "%2C"	-- Reserved character
--	tblCodePage["-"] = "%2D"	-- Unreserved character not encoded
--	tblCodePage["."] = "%2E"	-- Unreserved character not encoded
	tblCodePage["/"] = "%2F"	-- Reserved character
--	Digits 0 to 9				-- Unreserved characters not encoded
	tblCodePage[":"] = "%3A"	-- Reserved character
	tblCodePage[";"] = "%3B"	-- Reserved character
	tblCodePage["<"] = "%3C"								-- "&lt;"  in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["="] = "%3D"	-- Reserved character
	tblCodePage[">"] = "%3E"								-- "&gt;"  in Markup	see setURIEncodings() and setMarkupEncodings() below
	tblCodePage["?"] = "%3F"	-- Reserved character
	tblCodePage["@"] = "%40"	-- Reserved character
--	Letters A to Z				-- Unreserved characters not encoded
	tblCodePage["["] = "%5B"	-- Reserved character
	tblCodePage["\\"]= "%5C"
	tblCodePage["]"] = "%5D"	-- Reserved character
	tblCodePage["^"] = "%5E"
--	tblCodePage["_"] = "%5F"	-- Unreserved character not encoded
	tblCodePage["`"] = "%60"
--	Letters a to z				-- Unreserved characters not encoded
	tblCodePage["{"] = "%7B"
	tblCodePage["|"] = "%7C"
	tblCodePage["}"] = "%7D"
--	tblCodePage["~"] = "%7E"	-- Unreserved character not encoded
	tblCodePage["\127"] = ""	-- DEL

-- Code Page 1252 Unicode characters "\128" to "\255" for UTF-8 scheme "[Ä-ˇ]" encodings: http://en.wikipedia.org/wiki/UTF-8

	tblCodePage["Ä"] = string.char(0xE2,0x82,0xAC)	-- "&euro;"
	tblCodePage["\129"] = ""  -- Undefined
	tblCodePage["Ç"] = string.char(0xE2,0x80,0x9A)
	tblCodePage["É"] = string.char(0xC6,0x92)
	tblCodePage["Ñ"] = string.char(0xE2,0x80,0x9E)
	tblCodePage["Ö"] = string.char(0xE2,0x80,0xA6)
	tblCodePage["Ü"] = string.char(0xE2,0x80,0xA0)
	tblCodePage["á"] = string.char(0xE2,0x80,0xA1)
	tblCodePage["à"] = string.char(0xCB,0x86)
	tblCodePage["â"] = string.char(0xE2,0x80,0xB0)
	tblCodePage["ä"] = string.char(0xC5,0xA0)
	tblCodePage["ã"] = string.char(0xE2,0x80,0xB9)
	tblCodePage["å"] = string.char(0xC5,0x92)
	tblCodePage["\141"] = ""  -- Undefined
	tblCodePage["é"] = string.char(0xC5,0xBD)
	tblCodePage["\143"] = ""  -- Undefined
	tblCodePage["\144"] = ""  -- Undefined
	tblCodePage["ë"] = string.char(0xE2,0x80,0x98)
	tblCodePage["í"] = string.char(0xE2,0x80,0x99)
	tblCodePage["ì"] = string.char(0xE2,0x80,0x9C)
	tblCodePage["î"] = string.char(0xE2,0x80,0x9D)
	tblCodePage["ï"] = string.char(0xE2,0x80,0xA2)
	tblCodePage["ñ"] = string.char(0xE2,0x80,0x93)
	tblCodePage["ó"] = string.char(0xE2,0x80,0x94)
	tblCodePage["\152"] = string.char(0xCB,0x9C)	-- Small Tilde
	tblCodePage["ô"] = string.char(0xE2,0x84,0xA2)
	tblCodePage["ö"] = string.char(0xC5,0xA1)
	tblCodePage["õ"] = string.char(0xE2,0x80,0xBA)
	tblCodePage["ú"] = string.char(0xC5,0x93)
	tblCodePage["\157"] = ""  -- Undefined
	tblCodePage["û"] = string.char(0xC5,0xBE)
	tblCodePage["ü"] = string.char(0xC5,0xB8)
	tblCodePage["\160"] = string.char(0xC2,0xA0)	-- "&nbsp;"	No Break Space
	tblCodePage["°"] = string.char(0xC2,0xA1)		-- "&iexcl;"
	tblCodePage["¢"] = string.char(0xC2,0xA2)		-- "&cent;"
	tblCodePage["£"] = string.char(0xC2,0xA3)		-- "&pound;"
	tblCodePage["§"] = string.char(0xC2,0xA4)		-- "&curren;"
	tblCodePage["•"] = string.char(0xC2,0xA5)		-- "&yen;"
	tblCodePage["¶"] = string.char(0xC2,0xA6)
	tblCodePage["ß"] = string.char(0xC2,0xA7)
	tblCodePage["®"] = string.char(0xC2,0xA8)
	tblCodePage["©"] = string.char(0xC2,0xA9)
	tblCodePage["™"] = string.char(0xC2,0xAA)
	tblCodePage["´"] = string.char(0xC2,0xAB)
	tblCodePage["¨"] = string.char(0xC2,0xAC)
	tblCodePage["≠"] = string.char(0xC2,0xAD)		-- "&shy;"	Soft Hyphen
	tblCodePage["Æ"] = string.char(0xC2,0xAE)
	tblCodePage["Ø"] = string.char(0xC2,0xAF)
	tblCodePage["∞"] = string.char(0xC2,0xB0)
	tblCodePage["±"] = string.char(0xC2,0xB1)
	tblCodePage["≤"] = string.char(0xC2,0xB2)
	tblCodePage["≥"] = string.char(0xC2,0xB3)
	tblCodePage["¥"] = string.char(0xC2,0xB4)
	tblCodePage["µ"] = string.char(0xC2,0xB5)
	tblCodePage["∂"] = string.char(0xC2,0xB6)
	tblCodePage["∑"] = string.char(0xC2,0xB7)
	tblCodePage["∏"] = string.char(0xC2,0xB8)
	tblCodePage["π"] = string.char(0xC2,0xB9)
	tblCodePage["∫"] = string.char(0xC2,0xBA)
	tblCodePage["ª"] = string.char(0xC2,0xBB)
	tblCodePage["º"] = string.char(0xC2,0xBC)
	tblCodePage["Ω"] = string.char(0xC2,0xBD)
	tblCodePage["æ"] = string.char(0xC2,0xBE)
	tblCodePage["ø"] = string.char(0xC2,0xBF)
	tblCodePage["¿"] = string.char(0xC3,0x80)
	tblCodePage["¡"] = string.char(0xC3,0x81)
	tblCodePage["¬"] = string.char(0xC3,0x82)
	tblCodePage["√"] = string.char(0xC3,0x83)
	tblCodePage["ƒ"] = string.char(0xC3,0x84)
	tblCodePage["≈"] = string.char(0xC3,0x85)
	tblCodePage["∆"] = string.char(0xC3,0x86)
	tblCodePage["«"] = string.char(0xC3,0x87)
	tblCodePage["»"] = string.char(0xC3,0x88)
	tblCodePage["…"] = string.char(0xC3,0x89)
	tblCodePage[" "] = string.char(0xC3,0x8A)
	tblCodePage["À"] = string.char(0xC3,0x8B)
	tblCodePage["Ã"] = string.char(0xC3,0x8C)
	tblCodePage["Õ"] = string.char(0xC3,0x8D)
	tblCodePage["Œ"] = string.char(0xC3,0x8E)
	tblCodePage["œ"] = string.char(0xC3,0x8F)
	tblCodePage["–"] = string.char(0xC3,0x90)
	tblCodePage["—"] = string.char(0xC3,0x91)
	tblCodePage["“"] = string.char(0xC3,0x92)
	tblCodePage["”"] = string.char(0xC3,0x93)
	tblCodePage["‘"] = string.char(0xC3,0x94)
	tblCodePage["’"] = string.char(0xC3,0x95)
	tblCodePage["÷"] = string.char(0xC3,0x96)
	tblCodePage["◊"] = string.char(0xC3,0x97)
	tblCodePage["ÿ"] = string.char(0xC3,0x98)
	tblCodePage["Ÿ"] = string.char(0xC3,0x99)
	tblCodePage["⁄"] = string.char(0xC3,0x9A)
	tblCodePage["€"] = string.char(0xC3,0x9B)
	tblCodePage["‹"] = string.char(0xC3,0x9C)
	tblCodePage["›"] = string.char(0xC3,0x9D)
	tblCodePage["ﬁ"] = string.char(0xC3,0x9E)
	tblCodePage["ﬂ"] = string.char(0xC3,0x9F)
	tblCodePage["‡"] = string.char(0xC3,0xA0)
	tblCodePage["·"] = string.char(0xC3,0xA1)
	tblCodePage["‚"] = string.char(0xC3,0xA2)
	tblCodePage["„"] = string.char(0xC3,0xA3)
	tblCodePage["‰"] = string.char(0xC3,0xA4)
	tblCodePage["Â"] = string.char(0xC3,0xA5)
	tblCodePage["Ê"] = string.char(0xC3,0xA6)
	tblCodePage["Á"] = string.char(0xC3,0xA7)
	tblCodePage["Ë"] = string.char(0xC3,0xA8)
	tblCodePage["È"] = string.char(0xC3,0xA9)
	tblCodePage["Í"] = string.char(0xC3,0xAA)
	tblCodePage["Î"] = string.char(0xC3,0xAB)
	tblCodePage["Ï"] = string.char(0xC3,0xAC)
	tblCodePage["Ì"] = string.char(0xC3,0xAD)
	tblCodePage["Ó"] = string.char(0xC3,0xAE)
	tblCodePage["Ô"] = string.char(0xC3,0xAF)
	tblCodePage[""] = string.char(0xC3,0xB0)
	tblCodePage["Ò"] = string.char(0xC3,0xB1)
	tblCodePage["Ú"] = string.char(0xC3,0xB2)
	tblCodePage["Û"] = string.char(0xC3,0xB3)
	tblCodePage["Ù"] = string.char(0xC3,0xB4)
	tblCodePage["ı"] = string.char(0xC3,0xB5)
	tblCodePage["ˆ"] = string.char(0xC3,0xB6)
	tblCodePage["˜"] = string.char(0xC3,0xB7)
	tblCodePage["¯"] = string.char(0xC3,0xB8)
	tblCodePage["˘"] = string.char(0xC3,0xB9)
	tblCodePage["˙"] = string.char(0xC3,0xBA)
	tblCodePage["˚"] = string.char(0xC3,0xBB)
	tblCodePage["¸"] = string.char(0xC3,0xBC)
	tblCodePage["˝"] = string.char(0xC3,0xBD)
	tblCodePage["˛"] = string.char(0xC3,0xBE)
	tblCodePage["ˇ"] = string.char(0xC3,0xBF)

-- Code Page 1250 Unicode characters "\128" to "\255" for UTF-8 scheme "[Ä-ˇ]" encodings: http://en.wikipedia.org/wiki/UTF-8

	tblCodePage["1250"] = {}
	tblCodePage["1250"]["\131"] = ""  -- Undefined
	tblCodePage["1250"]["\136"] = ""  -- Undefined
	tblCodePage["1250"]["å"] = string.char(0xC5,0x9A)
	tblCodePage["1250"]["ç"] = string.char(0xC5,0xA4)
	tblCodePage["1250"]["é"] = string.char(0xC5,0xBD)
	tblCodePage["1250"]["è"] = string.char(0xC5,0xB9)
	tblCodePage["1250"]["\152"] = ""  -- Undefined
	tblCodePage["1250"]["ú"] = string.char(0xC5,0x9B)
	tblCodePage["1250"]["ù"] = string.char(0xC5,0xA5)
	tblCodePage["1250"]["û"] = string.char(0xC5,0xBE)
	tblCodePage["1250"]["ü"] = string.char(0xC5,0xBA)
	tblCodePage["1250"]["°"] = string.char(0xCB,0x87)
	tblCodePage["1250"]["¢"] = string.char(0xCB,0x98)
	tblCodePage["1250"]["£"] = string.char(0xC5,0x81)
	tblCodePage["1250"]["•"] = string.char(0xC4,0x84)
	tblCodePage["1250"]["™"] = string.char(0xC5,0x9E)
	tblCodePage["1250"]["Ø"] = string.char(0xC5,0xBB)
	tblCodePage["1250"]["≤"] = string.char(0xCB,0x9B)
	tblCodePage["1250"]["≥"] = string.char(0xC5,0x82)
	tblCodePage["1250"]["π"] = string.char(0xC4,0x85)
	tblCodePage["1250"]["∫"] = string.char(0xC5,0x9F)
	tblCodePage["1250"]["º"] = string.char(0xC5,0x7D)
	tblCodePage["1250"]["Ω"] = string.char(0xCB,0x9D)
	tblCodePage["1250"]["æ"] = string.char(0xC5,0x7E)
	tblCodePage["1250"]["ø"] = string.char(0xC5,0xBC)
-- needs more 1250 codes hereon...
	tblCodePage["1250"]["∆"] = string.char(0xC4,0x86)

	tblCodePage["1250"]["»"] = string.char(0xC4,0x8C)

	tblCodePage["1250"]["Ê"] = string.char(0xC4,0x87)

	tblCodePage["1250"]["Ë"] = string.char(0xC4,0x8D)


-- Set XML/XHTML/HTML "[%c\"&'<>]" Markup encodings: http://en.wikipedia.org/wiki/XML and http://en.wikipedia.org/wiki/HTML
local function setMarkupEncodings()
	tblCodePage["\t"] = " "		-- HT	"\t" to "\r" are treated as white space in Markup Languages by default
	tblCodePage["\n"] = br_Tag	-- LF	
	tblCodePage["\v"] = br_Tag	-- VT	line break tag	"<br>" or "<br >" or "<br/>" or "<br />" is better
	tblCodePage["\f"] = br_Tag	-- FF
	tblCodePage["\r"] = br_Tag	-- CR
	tblCodePage['"']  = "&quot;"
	tblCodePage["&"]  = "&amp;"
	tblCodePage["'"]  = "&apos;"
	tblCodePage["<"]  = "&lt;"
	tblCodePage[">"]  = "&gt;"
end -- local function setMarkupEncodings

-- Set URI/URL/URN "[%s%p]" encodings: http://en.wikipedia.org/wiki/URL and http://en.wikipedia.org/wiki/Percent-encoding
local function setURIEncodings()
	tblCodePage["\t"] = "+"		-- HT	space
	tblCodePage["\n"] = "%0A" 	-- LF	newline
	tblCodePage["\v"] = "%0A" 	-- VT	newline
	tblCodePage["\f"] = "%0A" 	-- FF	newline
	tblCodePage["\r"] = "%0D" 	-- CR	return
	tblCodePage['"']  = "%22"
	tblCodePage["&"]  = "%26"
	tblCodePage["'"]  = "%27"
	tblCodePage["<"]  = "%3C"
	tblCodePage[">"]  = "%3E"
end -- local function setURIEncodings

-- Encode characters according to gsub pattern & lookup table --
local function strEncode(strText,strPattern,tblPattern)
	strText = (strText or ""):gsub(strPattern,tblPattern)
	return strText
end -- local function strEncode

-- Encode CP characters into UTF8 codes --
function StrCP_UTF(strText)
	strText = strEncode(strText,"[\127-ˇ]",tblCodePage)
	return strText
end -- function StrCP_UTF

function StrCP1252_UTF(strText)
	return StrCP_UTF(strText)
end -- function StrCP1252_UTF

-- Encode CP characters into XML/XHTML/HTML/UTF8 codes --
function StrCP_XML(strText)
	setMarkupEncodings()
	strText = (strText or ""):gsub(br_Lua,"\n")		-- Convert <br> & <br > & <br/> & <br /> to \n that becomes br_Tag
	strText = strEncode(strText,"[%c\"&'<>\127-ˇ]",tblCodePage)
	return strText
end -- function StrCP_XML

function StrCP1252_XML(strText)
	return StrCP_XML(strText)
end -- function StrCP1252_XML

-- Encode Item Text characters into XML/HTML/UTF8 codes --
function StrGetItem_XML(ptrItem,strTags)
	return StrCP_XML(fhGetItemText(ptrItem,strTags))
end -- function StrGetItem_XML

-- Encode CP characters into URI codes --
function StrCP_URI(strText)
	setURIEncodings()
	strText = (strText or ""):gsub(br_Lua,"\n")		-- Convert <br> & <br > & <br/> & <br /> to \n that becomes %0A
	strText = strEncode(strText,"[%c%s%p\127-ˇ]",tblCodePage)
	return strText
end -- function StrCP_URI

function StrCP1252_URI(strText)
	return StrCP_URI(strText)
end -- function StrCP1252_URI

-- Encode UTF-8 bytes into single CP character -- Legacy from V1.0
function StrUTF8_Encode(strText)
	return StrUTF_CP(strText)
end -- function StrUTF8_Encode

-- Encode UTF-8 bytes into single CP character V2.0 upvalues --
local strByteRange = "["..string.char(0xC0).."-"..string.char(0xFF).."]"
local tblBytePoint = {0xC0,0xE0,0xF0,0xF8,0xFC}		-- Byte codes for 2-byte, 3-byte, 4-byte, 5-byte, 6-byte UTF-8
local tblUTF8 = {}
for strByte = string.byte("Ä"), string.byte("ˇ") do
	local strChar = string.char(strByte)				-- Use CodePage to UTF-8 table to populate UTF-8 to CodePage table
	local strCode = tblCodePage[strChar]
	tblUTF8[strCode] = strChar
end

-- Encode UTF-8 bytes into single CP character --
function StrUTF_CP(strText)
	strText = strText or ""
	if strText:match(strByteRange) then					-- If text contains characters that need translating then
		local intChar = 0									-- Input character index
		local strChar = ""									-- Current character
		local strCode = ""									-- UTF-8 multi-byte code
		local tblLine = {}									-- Translated output line
		repeat
			intChar = intChar + 1							-- Step through each character in text
			strChar = strText:sub(intChar,intChar)
			if strChar:match(strByteRange) then			-- Convert UTF-8 bytes into CP character
				strCode = strChar							-- First UTF-8 byte code, whose top bits say how many bytes to append
				for intByte, strByte in ipairs(tblBytePoint) do
					if string.byte(strChar) >= strByte then
						intChar = intChar + 1				-- Append next UTF-8 byte code character
						strCode = strCode..strText:sub(intChar,intChar)
					else
						break
					end 
				end
				strChar = tblUTF8[strCode] or "ø"		-- Translate UTF-8 code into CP character
			end
			table.insert(tblLine,strChar)				-- Accumulate output char by char
		until intChar >= #strText
		strText = table.concat(tblLine)
	end
	return strText
end -- function StrUTF_CP

function StrUTF_CP1252(strText)
	return StrUTF_CP(strText)
end -- function StrUTF_CP1252

-- Encode CP characters into ISO-8859-1 codes --
function StrCP_ISO(strText)
	-- Set ISO-8859-1 "[\127-ü]" encodings: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
	local tblCodePage = { }
	tblCodePage["\127"] = ""  -- DEL
	tblCodePage["Ä"] = "EUR"	
	tblCodePage["\129"] = ""  -- Undefined
	tblCodePage["Ç"] = "∏"
	tblCodePage["É"]  = "f"
	tblCodePage["Ñ"] = "∏∏"
	tblCodePage["Ö"] = "..."
	tblCodePage["Ü"] = "+"
	tblCodePage["á"] = "±"
	tblCodePage["à"]  = "^"
	tblCodePage["â"] = "%"
	tblCodePage["ä"] = "S"
	tblCodePage["ã"] = "<"
	tblCodePage["å"] = "OE"
	tblCodePage["\141"] = ""  -- Undefined
	tblCodePage["é"] = "Z"
	tblCodePage["\143"] = ""  -- Undefined
	tblCodePage["\144"] = ""  -- Undefined
	tblCodePage["ë"] = "'"
	tblCodePage["í"] = "'"
	tblCodePage["ì"] = '"'
	tblCodePage["î"] = '"'
	tblCodePage["ï"] = "∫"
	tblCodePage["ñ"] = "-"
	tblCodePage["ó"] = "-"
	tblCodePage["\152"] = "~" -- Small Tilde
	tblCodePage["ô"] = "TM"
	tblCodePage["ö"] = "s"
	tblCodePage["õ"] = ">"
	tblCodePage["ú"] = "oe"
	tblCodePage["\157"] = ""  -- Undefined
	tblCodePage["û"] = "z"
	tblCodePage["ü"] = "Y"
	strText = strEncode(strText,"[\127-ü]",tblCodePage)
	return strText
end -- local function StrCP_ISO

function StrCP1252_ISO(strText)
	return StrCP_ISO(strText)
end -- local function StrCP1252_ISO

-- Set markup language break tag --
function SetBreakTag(br_New)
	if not (br_New or ""):match(br_Lua) then			-- Ensure new break tag is "<br>" or "<br >" or "<br/>" or "<br />"
		br_New = "<br />"
	end
	br_Tag = br_New
end -- function SetBreakTag

require "luacom"
local function getRegKey(strKey)
	local luaShell = luacom.CreateObject "WScript.Shell"
	local strValue 
	if pcall( function() strValue = luaShell:RegRead(strKey) end ) then
		return strValue, false
	else
		return nil, true
	end
end -- local function getRegKey

local strCodePage, isError = getRegKey("HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage\\ACP")
if isError then
	error("\nCode Page ACP Registry Key Not Found.\n")
end

if strCodePage == "1252" then
	-- do nothing as this is default
elseif tblCodePage[strCodePage] then
	for strByte = string.byte("Ä"), string.byte("ˇ") do
		local strChar = string.char(strByte)				-- Use CodePage to UTF-8 table to populate UTF-8 to CodePage table
		tblCodePage[strChar] = tblCodePage[strCodePage][strChar] or tblCodePage[strChar]
	end
else
	error("\nCode Page "..strCodePage.." is not supported\n")
end

return fh

end -- local function encoder_v2

--[[
@Title:			+fh+general_v1
@Author:			Mike Tate
@LastUpdated:	19 Oct 2013
@Version:			1.1
@Description:	A general functions module to supplement LUA functions.
@V1.0:				Initial version.
]]

local function general_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

require "lfs"													-- To access LUA filing system

-- Check if file exists --
function FlgFileExists(strFileName)
--	return pl.path.isfile(strFileName)
---[=[
	if lfs.attributes(strFileName,"mode") == "file" then
		return true
	else
		return false
	end
--]=]
end -- function FlgFileExists

-- Check if folder exists --
function FlgFolderExists(strFolderName)
--	return pl.path.isdir(strFolderName)
---[=[
	if lfs.attributes(strFolderName:gsub("\\$",""),"mode") == "directory" then
		return true
	else
		return false
	end
--]=]
end -- function FlgFolderExists

-- Check if folder writable --
function FlgFolderWrite(strFolderName)
	if FlgFolderExists(strFolderName) then
		local fileHandle, strError = io.open(strFolderName.."\\xyz.xyz","w")
		if fileHandle ~= nil then
			fileHandle:close()
			os.remove(strFolderName.."\\xyz.xyz")
			return true
		end
	end
	return false
end -- function FlgFolderWrite

-- Open File and return Handle --
function OpenFile(strFileName,strMode)
	local fileHandle, strError = io.open(strFileName,strMode)
	if fileHandle == nil then
		error("\n Unable to open file in \""..strMode.."\" mode. \n "..strFileName.." \n "..strError.." \n")
	end
	return fileHandle
end -- function OpenFile

-- Save string to file --
function SaveStringToFile(strString,strFileName)
	local fileHandle = OpenFile(strFileName,"w")
	fileHandle:write(strString)
	assert(fileHandle:close())
end -- function SaveStringToFile

-- Load string from file --
function StrLoadFromFile(strFileName)
	local fileHandle = OpenFile(strFileName,"r")
	local strString = fileHandle:read("*all")
	assert(fileHandle:close())
	return strString
end -- function StrLoadFromFile

-- Return the Path, Filename, and extension as 3 values
function SplitFilename(strFilename)
	return strFilename:match("(.-)([^\\]-([^\\%.]+))$")
end -- function SplitFilename

-- Return a Directory Tree entry & attributes on each iteration --
function DirTree(strDir)
	assert(strDir and strDir ~= "", "directory parameter is missing or empty")
	if strDir:sub(-1) == "/" then
		strDir = strDir:sub(1,-2)								-- Remove trailing "/"
	end
    
	local function doYieldTree(strDir)
--!		for strEntry in pl.path.dir(strDir) do
		for strEntry in lfs.dir(strDir) do
			if strEntry ~= "." and strEntry ~= ".." then
				strEntry = strDir.."\\"..strEntry
				local tblAttr, strError = lfs.attributes(strEntry)
				if not tblAttr then tblAttr = { mode="attrfail", error=strError } end 
				coroutine.yield(strEntry,tblAttr)
				if tblAttr.mode == "directory" then
					doYieldTree(strEntry)
				end
			end
		end
	end -- local function doYieldTree

	return coroutine.wrap(function() doYieldTree(strDir) end)
end -- function DirTree

local function strErrorText(strError,strFileName,intRepeat)
	return strError:gsub(strFileName:match("(.+\\).+"),"Del#"..tostring(intRepeat)..":")
end -- local function strErrorText

-- Delete file if it exists --
function DeleteFile(strFileName,errFunction)
	if FlgFileExists(strFileName) then
		local fileHandle, strError = os.remove(strFileName)
		if fileHandle == nil then
			local intRepeat = 1
			repeat
				if intRepeat > 1 and type(errFunction) == "function" then
					errFunction(strErrorText(strError,strFileName,intRepeat))
				end
				fhSleep(300,100)
				if FlgFileExists(strFileName) then
					fileHandle, strError = os.remove(strFileName)
				end
				intRepeat = intRepeat + 1
			until fileHandle ~= nil or intRepeat > 10
			if intRepeat > 10 then error(strErrorText(strError,strFileName,intRepeat)) end
		end
	end
end -- function DeleteFile

-- Invoke FH Shell Execute API --
function DoExecute(strExecutable,...)
	local errFunction = fhMessageBox
	if type(arg[#arg]) == 'function' then
		errFunction = arg[#arg]
		table.remove(arg)
	end
	local isOK, intErrorCode, strErrorText = fhShellExecute(strExecutable,unpack(arg))
	if not isOK then
		errFunction(tostring(strErrorText).." ("..tostring(intErrorCode)..")")
	end
	return isOK
end -- function DoExecute

--[[
@function:		BuildDataRef
@description:	Get Full Data Reference for Pointer
@parameters:		Item Pointer
@returns:			Data Reference String, Record Id Integer, Record Type Tag String
@requires:		None
]]
function BuildDataRef(ptrRef)

	local strDataRef = ""										-- Data Reference with instance indices e.g. INDI.RESI[2].ADDR
	local intRecId   = 0										-- Record Id for associated Record
	local strRecTag  = ""										-- Record Tag of associated Record type i.e. INDI, FAM, NOTE, SOUR, etc

	-- getDataRef() is called recursively per level of the Data Ref
	-- ptrRef points to the upper Data Ref levels yet to be analysed
	-- strRef compiles the lower Data Ref levels including instances

	local function getDataRef(ptrRef,strRef)
		local ptrTag = ptrRef:Clone()
		local strTag = fhGetTag(ptrTag)						-- Current level Tag
		ptrTag:MoveToParentItem(ptrTag)
		if ptrTag:IsNotNull() then							-- Parent level exists
			local intSib = 1
			local ptrSib = ptrRef:Clone()					-- Pointer to siblings with same Tag
			ptrSib:MovePrev("SAME_TAG")
			while ptrSib:IsNotNull() do						-- Count previous siblings with same Tag
				intSib = intSib + 1
				ptrSib:MovePrev("SAME_TAG")
			end
			if intSib > 1 then 	strTag = strTag.."["..intSib.."]" end
			getDataRef(ptrTag,"."..strTag..strRef)			-- Now analyse the parent level
		else
			strDataRef = strTag..strRef						-- Record level reached, so set return values
			intRecId   = fhGetRecordId(ptrRef)
			strRecTag  = strTag
			if not fhIsValidDataRef(strDataRef) then print("BuildDataRef: "..strDataRef.." is Invalid") end
		end
	end -- local function getDataRef

	if type(ptrRef) == "userdata" then getDataRef(ptrRef,"") end

	return strDataRef, intRecId, strRecTag

end -- function BuildDataRef

--[[
@function:		GetDataRefPtr
@description:	Get Pointer for Full Data Reference
@parameters:		Data Reference String, Record Id Integer, Record Type Tag String (optional)
@returns:			Item Pointer which IsNull() if any parameters are invalid
@requires:		None
]]
function GetDataRefPtr(strDataRef,intRecId,strRecTag)
	strDataRef = strDataRef or ""
	if not strRecTag then
		strRecTag = strDataRef:gsub("^(%u+).*$","%1")	-- Extract Record Tag from Data Ref
	end
	local ptrRef = fhNewItemPtr()
	ptrRef:MoveToRecordById(strRecTag,intRecId or 0)	-- Lookup the Record by Id
	ptrRef:MoveTo(ptrRef,strDataRef)						-- Move to the Data Ref
	return ptrRef
end -- function GetDataRefPtr

function TblDataRef(ptrRef)
	local tblRef = {}
	tblRef.DataRef, tblRef.RecId, tblRef.RecTag = BuildDataRef(ptrRef)
	return tblRef
end -- function TblDataRef

function PtrDataRef(tblRef)
	local tblRef = tblRef or {}								-- Ensure table and its fields exist
	return GetDataRefPtr(tblRef.DataRef or "",tblRef.RecId or 0,tblRef.RecTag or "")
end -- function PtrDataRef

return fh

end -- local function general_v1

--[[
@Module:			fh.iterate_v1
@Author:			Mike Tate
@LastUpdated:	19 Oct 2013
@Version:			1.1
@Description:	An iterater functions module to supplement LUA functions.
@V1.0:				Initial version.
]]

local function iterate_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

-- Iterator for all records of one chosen type --
function Records(strType)
	local ptrAll = fhNewItemPtr()							-- Pointer to all records in turn
	local ptrRec = fhNewItemPtr()							-- Pointer to record returned to user
	ptrAll:MoveToFirstRecord(strType)
	return function ()
		ptrRec:MoveTo(ptrAll)
		ptrAll:MoveNext()
		if ptrRec:IsNotNull() then return ptrRec end
	end
end -- function Records

-- Iterator for all the record types --
function RecordTypes()
	local intNext = 0											-- Next record type number
	local intLast = fhGetRecordTypeCount()					-- Last record type number
	return function()
		intNext = intNext + 1
		if intNext <= intLast then
			return fhGetRecordTypeTag(intNext)				-- Return record type tag
		end
	end
end -- function RecordTypes

-- Iterator for all items in all records of chosen types --
function Items(...)
	local intType = 1											-- Integer record type number
	local tblType = {}											-- Table of record type tags
	local ptrNext = fhNewItemPtr()							-- Pointer to next item in turn
	local ptrItem = fhNewItemPtr()							-- Pointer to item returned to user

	if #arg == 0 then
		for intType = 1, fhGetRecordTypeCount() do		-- No parameters so use all record types
			tblType[intType] = fhGetRecordTypeTag(intType)
		end
	else
		tblType = arg											-- Got parameters so use them instead
	end
--	print(tblType[intType],intType)
	ptrNext:MoveToFirstRecord(tblType[intType])			-- Get first record of first type

	return function()
		repeat
			while ptrNext:IsNotNull() do						-- Loop through all items
				ptrItem:MoveTo(ptrNext)
				ptrNext:MoveNextSpecial()
				if ptrItem:IsNotNull() then return ptrItem end
			end
			intType = intType + 1								-- Loop through each record type
			if intType <= #tblType then
				ptrNext:MoveToFirstRecord(tblType[intType])
			end
		until intType > #tblType
	end
end -- function Items

-- Iterator for all facts of an individual --
function Facts(ptrIndi)
	local ptrItem = fhNewItemPtr()							-- Pointer to each item at level 1
	local ptrFact = fhNewItemPtr()							-- Pointer to each fact returned to user
	ptrItem:MoveToFirstChildItem(ptrIndi)
	return function ()
		while ptrItem:IsNotNull() do
			ptrFact:MoveTo(ptrItem)
			ptrItem:MoveNext()
			if fhIsFact(ptrFact) then return ptrFact end
		end
	end
end -- function Facts

return fh

end -- local function iterate_v1

--[[
@Module:			fh.progbar_v1
@Author:			Mike Tate
@LastUpdated:	30 Oct 2013
@Version:			1.1
@Description:	Progress Bar library module.
@V1.0:				Initial version.
]]

local function progbar_v1(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}													-- Local environment table
package.seeall(fh)												-- Enable all globals
module(...,package.seeall)									-- Create matching module name
setfenv(1,fh)													-- All public names are added to local fh table

require "iuplua"												-- To access GUI window builder

local tblBars = {}												-- Table for optional external attributes
local strFont = nil												-- Font dialogue default is current font
local strStop = "255 0 0"										-- Stop button colour default is red
local strBack = "255 255 255"								-- Background colour default is white
local intPosX = iup.CENTER									-- Show window default position is central
local intPosY = iup.CENTER
local intMax, intVal, intPercent, intStart, intDelta, intScale, strClock, isBarStop
local lblText, barGauge, lblDelta, btnStop, dlgGauge

local function doFocus()										-- Bring the Progress Bar window into Focus
	dlgGauge.BringFront="YES"									-- If used too often, inhibits other windows scroll bars, etc
end -- local function doFocus

local function doUpdate()										-- Update the Progress Gauge and the Delta % with clock
	barGauge.Value = intVal
	lblDelta.Title = string.format("%4d %%      %s ",intPercent,strClock)
end -- local function doUpdate

local function doReset()										-- Reset all dialogue variables and Update display
	intVal		= 0													-- Current value of Progress Bar
	intPercent= 0.01											-- Percentage of progress
	intStart	= os.time()										-- Start time of progress
	intDelta	= 0													-- Delta time of progress
	intScale	= math.ceil( intMax / 1000 )					-- Scale of percentage per second of progress (initial guess is corrected in Step function)
	strClock	= "00 : 00 : 00"								-- Clock delta time display
	isBarStop	= false											-- Stop button pressed signal
	doUpdate()
	doFocus()
end -- local function doReset

function Start(strTitle,intMaximum)							-- Create & start Progress Bar window
	if not dlgGauge then
		strTitle	= strTitle or ""							-- Dialogue and button title
		intMax		= intMaximum or 100							-- Maximun range of Progress Bar, default is 100
		local strSize = tostring( math.max( 100, string.len(" Stop "..strTitle) * 8 ) ).."x30"			-- Adjust Stop button size to Title
		lblText	= iup.label	{ Title=" ", Expand="YES", Alignment="ACENTER", Tip="Progress Message" }
		barGauge	= iup.progressbar { RasterSize="400x30", Value=0, Max=intMax, Tip="Progress Bar" }
		lblDelta	= iup.label	{ Title=" ", Expand="YES", Alignment="ACENTER", Tip="Percentage and Elapsed Time" }
		btnStop	= iup.button	{ Title=" Stop "..strTitle, RasterSize=strSize, FgColor=strStop, Tip="Stop Progress Button", action=function() isBarStop = true end }	-- Signal Stop button pressed	return iup.CLOSE -- Often caused main GUI to close !!!
		dlgGauge	= iup.dialog	{ Title=strTitle.." Progress ", Font=strFont, Background=strBack, DialogFrame="YES",	-- Remove Windows minimize/maximize menu
							iup.vbox{ Alignment="ACENTER", Gap="10", Margin="10x10",
								lblText,
								barGauge,
								lblDelta,
								btnStop,
							},
							move_cb	= function(self,x,y) tblBars.X = x tblBars.Y = y end,
							close_cb	= btnStop.action,		-- Windows Close button = Stop button
						}
		if type(tblBars.GUI) == "table"
		and type(tblBars.GUI.ShowDialogue) == "function" then
			dlgGauge.move_cb = nil								-- Use GUI library to show & move window
			tblBars.GUI.ShowDialogue("Bars",dlgGauge,btnStop,"showxy")
		else
			dlgGauge:showxy(intPosX,intPosY)				-- Show the Progress Bar window
		end
		doReset()													-- Reset the Progress Bar display
	end
end -- function Start

function Message(strText)										-- Show the Progress Bar message
	if dlgGauge then lblText.Title = strText end
end -- function Message

function Step(intStep)											-- Step the Progress Bar forward
	if dlgGauge then
		intVal = intVal + ( intStep or 1 )					-- Default step is 1
		local intNew = math.ceil( intVal / intMax * 100 * intScale ) / intScale
		if intPercent ~= intNew then							-- Update progress once per percent or per second, whichever is smaller
			intPercent = math.max( 0.1, intNew )			-- Ensure percentage is greater than zero
			if intVal > intMax then intVal = intMax intPercent = 100 end		-- Ensure values do not exceed maximum
			intNew = os.difftime(os.time(),intStart)
			if intDelta < intNew then							-- Update clock of elapsed time
				intDelta = intNew
				intScale = math.ceil( intDelta / intPercent )	-- Scale of seconds per percentage step
				local intHour = math.floor( intDelta / 3600 )
				local intMins = math.floor( intDelta / 60 - intHour * 60 )
				local intSecs = intDelta - intMins * 60 - intHour * 3600
				strClock = string.format("%02d : %02d : %02d",intHour,intMins,intSecs)
			end
			doUpdate()											-- Update the Progress Bar display
		end
		iup.LoopStep()
	end
end -- function Step

function Focus()												-- Bring the Progress Bar window to front
	if dlgGauge then doFocus() end
end -- function Focus

function Reset()												-- Reset the Progress Bar display
	if dlgGauge then doReset() end
end -- function Reset

function Stop()													-- Check if Stop button pressed
	iup.LoopStep()
	return isBarStop
end -- function Stop

function Close()												-- Close the Progress Bar window
	isBarStop = false
	if dlgGauge then dlgGauge:destroy() dlgGauge = nil end
end -- function Close

function Setup(tblSetup)										-- Setup optional table of external attributes
	if tblSetup then
		tblBars = tblSetup
		strFont = tblBars.Font or strFont					-- Font dialogue
		strStop = tblBars.Stop or strStop					-- Stop button colour
		strBack = tblBars.Back or strBack					-- Background colour
		intPosX = tblBars.X or intPosX						-- Window position
		intPosY = tblBars.Y or intPosY
	end
end -- function Setup

return fh

end -- local function progbar_v1

--[[
@Title:			+fh+iup_gui_v2
@Author:			Mike Tate
@Version:			2.7
@LastUpdated:	15 Feb 2014
@Description:	Graphical User Interface Library Module
@V2.0:				Second version with Plugin Data scope, new FontDialogue, RefreshDialogue, AssignAttributes, httpRequest handler.
@V1.0:				Initial version.
]]

local function iup_gui_v2(...) -- if not ... then error("\n\nThis is a Library Module, and so it can not be executed on its own.") end

local fh = {}																		-- Local environment table
package.seeall(fh)																	-- Enable all globals
module(...,package.seeall)														-- Create matching module name
setfenv(1,fh)																		-- All public names are added to local fh table

require "iuplua"																	-- To access GUI window builder
require "iupluacontrols"															-- To access GUI window controls
require "lfs"																		-- To access LUA filing system
require "iupluaole"																	-- To access OLE subsystem
require "luacom"																	-- To access COM subsystem

local general = general_v1														-- To access FH general module
local stringx = stringx_v2														-- To access FH stringx module but cannot import

function ReportVersion()
	local strMessage = "This is +fh+iup_gui_v2"
	print(strMessage)
	return strMessage
end

-- Shared Interface Attributes & Functions --

Plugin		= fhGetContextInfo("CI_PLUGIN_NAME")								-- Plugin Name
Version	= " "																		-- Plugin Version
History	= Version																	-- Version History

Red			= "255 0 0"																-- Color attributes (must exclude leading zeros & spaces to allow value comparisons)
Maroon		= "128 0 0"
Amber		= "250 160 0"
Orange		= "255 165 0"
Yellow		= "255 255 0"
Olive		= "128 128 0"
Lime		= "0 255 0"
Green		= "0 128 0"
Cyan		= "0 255 255"
Teal		= "0 128 128"
Blue		= "0 0 255"
Navy		= "0 0 128"
Magenta	= "255 0 255"
Purple		= "128 0 128"
Black		= "0 0 0"
Gray		= "128 128 128"
Silver		= "192 192 192"
Smoke		= "240 240 240"
White		= "255 255 255"
Risk		= Red																		-- Risk colour for hazardous controls such as Close/Delete buttons
Warn		= Magenta																	-- Warn colour for caution controls and warnings
Safe		= Green																	-- Safe colour for active controls such as most buttons
Info		= Black																	-- Info colour for text controls such as labels/tabs
Head		= Black																	-- Head colour for headings
Body		= Black																	-- Body colour for body text
Back		= White																	-- Background colour for all windows

Gap			= "8"																		-- Layout attributes Gap was "10"
Border		= "8x8"																	-- 	was BigMargin="10x10"
Margin		= "1x1"																	--	was MinMargin
Balloon	= "NO"																		-- Tooltip balloon mode

FontSet	=	0																		-- Legacy GUI font set assigned by FontAssignment but used globally
FontHead	= ""
FontBody	= ""

local GUI = { }																		-- Sub-table for GUI Dialogue attributes to allow any "Name"

--[[
GUI.Name					table of dialogue attributes, where Name is Font, Help, Main, Memo, Bars, etc
GUI.Name.CoordX			x co-ordinate	( Loaded & Saved by default )
GUI.Name.CoordY			y co-ordinate	( Loaded & Saved by default )
GUI.Name.Dialog			dialogue handle
GUI.Name.Focus			focus button handle
GUI.Name.Frame			dialogframe mode, "normal" = dialogframe="NO" else "YES", "showxy" = showxy(), "popup" or "keep" = popup(), default is "normal & showxy"
GUI.Name.Height			height
GUI.Name.Raster			rastersize		( Loaded & Saved by default )
GUI.Name.Width			width
GUI.Name.Back			ProgressBar background colour
GUI.Name.Font			ProgressBar font style
GUI.Name.Stop			ProgressBar Stop button colour
GUI.Name.GUI				Module table usable by other modules e.g. progbar.Setup
							Help dialogue Window attributes :-
GUI.Help.GetHelp 		Parent dialogue GetHelp button
GUI.Help.RootURL 		Wiki Help & Advice root URL
GUI.Help.TblAttr		Table of button attributes
GUI.Help[n]				Help dialogue nth button :-
GUI.Help[n].Name		Name for title attribute
GUI.Help[n].Tip 		Tooltip for tip attribute
GUI.Help[n].URL 		Page URL to append to root URL 
GUI.Help[n].Page		Page order for intTabPosn
--]]

-- tblScrn[1] = origin x, tblScrn[2] = origin y, tblScrn[3] = width, tblScrn[4] = height
local tblScrn = stringx.splitnumbers(iup.GetGlobal("VIRTUALSCREEN"))	-- Used by CustomDialogue() and CheckWindowPosition() and ShowDialogue() below
local intMaxW = tblScrn[3]
local intMaxH = tblScrn[4]

local function tblOfNames(...)													-- Get table of dialogue Names including "Font","Help","Main" by default
	local tblNames = {"Font","Help","Main"}
	for intName, strName in ipairs(arg) do
		if type(strName) == "string"
		and strName ~= "Font"
		and strName ~= "Help"
		and strName ~= "Main" then
			table.insert(tblNames,strName)
		end
	end
	return tblNames
end -- local function tblOfNames

local function tblNameFor(strName)												-- Get table of parameters for chosen dialogue Name
	strName = tostring(strName)
	if not GUI[strName] then														-- Need new table with default minimum & raster size, and X & Y co-ordinates
		GUI[strName] = { }
		local tblName = GUI[strName]
		tblName.Raster = "x"
		tblName.CoordX = iup.CENTER
		tblName.CoordY = iup.CENTER
	end
	return GUI[strName]
end -- local function tblNameFor

local function intDimension(intMin,intVal,intMax)							-- Return a number bounded by intMin and intMax
	if not intVal then return 0 end												-- Except if no value then return 0
	intVal = tonumber(intVal) or (intMin+intMax)/2
	return math.max(intMin,math.min(intVal,intMax))
end -- local function intDimension

function CustomDialogue(strName,strRas,intX,intY)							-- GUI custom window raster size, and X & Y co-ordinates
	-- strRas  nil = old size, "x" or "0x0" = min size, "999x999" = new size
	-- intX/Y  nil = central, "99" = co-ordinate position
	local tblName = tblNameFor(strName)
	local tblSize = {}
	local intWide = 0
	local intHigh = 0
	strRas = strRas or tblName.Raster
	if strRas then																	-- Ensure raster size is between minimum and screen size
		tblSize = stringx.splitnumbers(strRas)
		intWide = intDimension(intWide,tblSize[1],intMaxW)
		intHigh = intDimension(intHigh,tblSize[2],intMaxH)
		strRas = tostring(intWide.."x"..intHigh)
	end
	if intX then intX = intDimension(0,intX,intMaxW-intWide) end			-- Ensure X & Y co-ordinates position window on screen
	if intY then intY = intDimension(0,intY,intMaxH-intHigh) end
	tblName.Raster  = strRas	or "x"
	tblName.CoordX  = tonumber(intX) or iup.CENTER
	tblName.CoordY  = tonumber(intY) or iup.CENTER
end -- function CustomDialogue

function DefaultDialogue(...)													-- GUI default window minimum & raster size, and X & Y co-ordinates
	for intName, strName in ipairs(tblOfNames(...)) do
		CustomDialogue(strName)
	end
end -- function DefaultDialogue

function DialogueAttributes(strName)											-- Provide named Dialogue Attributes
	local tblName = tblNameFor(strName)											-- tblName.Dialog = dialog handle, so any other attributes could be retrieved
	local tblSize = stringx.splitnumbers(tblName.Raster or "x")			-- Split Raster Size into width=tblSize[1] and height=tblSize[2]
	tblName.Width  = tblSize[1]
	tblName.Height = tblSize[2]
	tblName.Font = FontBody														-- Following only needed for NewProgressBar
	tblName.Back = Back
	tblName.Stop = Risk
	tblName.GUI  = fh																-- Module table
	return tblName
end -- function DialogueAttributes

local strDefaultScope = "Project"												-- Default scope for Load/Save data is per Project/User/Machine as set by PluginDataScope()

local tblLoadProj = {}
local tblLoadUser = {}
local tblLoadMach = {}

local function doLoadData(strParam,strDefault,strScope)					-- Load sticky data for Plugin Data scope
	strScope = tostring(strScope or strDefaultScope):lower()
	local tblLoadData = tblLoadProj
	if     strScope:match("user") then tblLoadData = tblLoadUser
	elseif strScope:match("mach") then tblLoadData = tblLoadMach
	end
	return tblLoadData[strParam] or strDefault
end -- local function doLoadData

function LoadLocal(strParam,strDefault,strScope)							-- Load Local Parameter for this PC
	return doLoadData(ComputerName.."-"..strParam,strDefault,strScope)
end -- function LoadLocal

function LoadGlobal(strParam,strDefault,strScope)							-- Load Global Parameter for all PC
	return doLoadData(strParam,strDefault,strScope)
end -- function LoadGlobal

function LoadDialogue(...)														-- Load Dialogue Parameters for "Font","Help","Main" by default
	for intName, strName in ipairs(tblOfNames(...)) do
		local tblName = tblNameFor(strName)
		tblName.Raster = tostring(LoadLocal(strName.."S",tblName.Raster))  -- Legacy of "S" becomes "R"
		tblName.Raster = tostring(LoadLocal(strName.."R",tblName.Raster))
		tblName.CoordX = tonumber(LoadLocal(strName.."X",tblName.CoordX))
		tblName.CoordY = tonumber(LoadLocal(strName.."Y",tblName.CoordY))
		CheckWindowPosition(tblName)
	end
end -- function LoadDialogue

function LoadSettings(...)														-- Load Sticky Settings from File
	for strFileName, tblLoadData in pairs ({ ProjectFile=tblLoadProj, PerUserFile=tblLoadUser, MachineFile=tblLoadMach }) do
		strFileName = fh[strFileName]
		if general.FlgFileExists(strFileName) then							-- Load Settings File in table lines with key & val fields
			local tblField = {}
			for strLine in io.lines(strFileName) do
				if strLine == "return {"											-- Unless entire Sticky Data table was saved
				and type(table.load) == "function" then
					local tblLoad, strErr = table.load(strFileName)			-- Load Settings File table
					for i,j in pairs (tblLoad) do
						tblLoadData[i] = tblLoad[i]
					end
					break
				end
				tblField = stringx.split(strLine,"=")
				tblLoadData[tblField[1]] = tblField[2]
			end
		end
	end
	Safe    = tostring(LoadGlobal("SafeColor",Safe))
	Warn    = tostring(LoadGlobal("WarnColor",Warn))
	Risk    = tostring(LoadGlobal("RiskColor",Risk))
	Head    = tostring(LoadGlobal("HeadColor",Head))
	Body    = tostring(LoadGlobal("BodyColor",Body))
	FontHead= tostring(LoadGlobal("FontHead",FontHead))
	FontBody= tostring(LoadGlobal("FontBody",FontBody))
	FontSet = tonumber(LoadGlobal("Fonts",FontSet))							-- Legacy only
	FontSet = tonumber(LoadGlobal("FontSet",FontSet))						-- Legacy only
	History = tostring(LoadGlobal("History",History))
	LoadDialogue(...)
	if FontSet > 0 then FontAssignment(FontSet) end							-- Legacy only
end -- function LoadSettings

local tblSaveProj = {}
local tblSaveUser = {}
local tblSaveMach = {}

local function doSaveData(strParam,anyValue,strScope)						-- Save sticky data for Plugin Data scope
	strScope = tostring(strScope or strDefaultScope):lower()
	local tblSaveData = tblSaveProj
	if     strScope:match("user") then tblSaveData = tblSaveUser
	elseif strScope:match("mach") then tblSaveData = tblSaveMach
	end
	tblSaveData[strParam] = anyValue
end -- local function doSaveData

function SaveLocal(strParam,anyValue,strScope)								-- Save Local Parameter for this PC
	doSaveData(ComputerName.."-"..strParam,anyValue,strScope)
end -- function SaveLocal

function SaveGlobal(strParam,anyValue,strScope)								-- Save Global Parameter for all PC
	doSaveData(strParam,anyValue,strScope)
end -- function SaveGlobal

function SaveDialogue(...)														-- Save Dialogue Parameters for "Font","Help","Main" by default
	for intName, strName in ipairs(tblOfNames(...)) do
		local tblName = tblNameFor(strName)
		SaveLocal(strName.."R",tblName.Raster)
		SaveLocal(strName.."X",tblName.CoordX)
		SaveLocal(strName.."Y",tblName.CoordY)
	end
end -- function SaveDialogue

function SaveSettings(...)														-- Save Sticky Settings to File
	SaveDialogue(...)
	SaveGlobal("SafeColor",Safe)
	SaveGlobal("WarnColor",Warn)
	SaveGlobal("RiskColor",Risk)
	SaveGlobal("HeadColor",Head)
	SaveGlobal("BodyColor",Body)
	SaveGlobal("FontHead",FontHead)
	SaveGlobal("FontBody",FontBody)
	SaveGlobal("History",History)
	for strFileName, tblSaveData in pairs ({ ProjectFile=tblSaveProj, PerUserFile=tblSaveUser, MachineFile=tblSaveMach }) do
		for i,j in pairs (tblSaveData) do										-- Check if table has any entries
			strFileName = fh[strFileName]
			if type(table.save) == "function" then								-- Save entire Settings File table per Project/User/Machine
				table.save(tblSaveData,strFileName)
			else
				local fileHandle = general.OpenFile(strFileName,"w")		-- Else save Settings File lines with key & val fields
				for strKey,strVal in pairs(tblSaveData) do
					fileHandle:write(strKey.."="..strVal.."\n")
				end
				fileHandle:close()
			end
			break
		end
	end
end -- function SaveSettings

function CheckWindowPosition(tblName)											-- Ensure dialogue window coordinates are on Screen
	if tonumber(tblName.CoordX) == nil
	or tonumber(tblName.CoordX) > intMaxW then
		tblName.CoordX = iup.CENTER
	end
	if tonumber(tblName.CoordY) == nil
	or tonumber(tblName.CoordY) > intMaxH then
		tblName.CoordY = iup.CENTER
	end
end -- function CheckWindowPosition

function IsNormalWindow(iupDialog)												-- Check dialogue window is not Maximised or Minimised
	-- tblPosn[1] = origin x, tblPosn[2] = origin y, tblPosn[3] = width, tblPosn[4] = height
	local tblPosn = stringx.splitnumbers(iupDialog.screenposition)
	local intPosX = tblPosn[1]
	local intPosY = tblPosn[2]
	if intPosX < 0 and intPosY < 0 then											-- If origin is negative (-8, -8 = Maximised, -3200, -3200 = Minimised)
		return false																	-- then is Maximised or Minimised
	end
	return true
end -- function IsNormalWindow

function ShowDialogue(strName,iupDialog,btnFocus,strFrame)				-- Set standard frame attributes and display dialogue window
	local tblName = tblNameFor(strName)
	iupDialog = iupDialog or tblName.Dialog									-- Retrieve previous parameters if needed
	btnFocus  = btnFocus  or tblName.Focus
	strFrame  = strFrame  or tblName.Frame
	strFrame  = strFrame  or "show norm"										-- Default frame mode is dialog:showxy(X,Y) with dialogframe="NO" ("normal" to vary size, otherwise fixed size)
	strFrame  = strFrame:lower()													-- Other modes are "show", "popup" & "keep" with dialogframe="YES", or with "normal" for dialogframe="NO" ("show" for active windows, "popup"/"keep" for modal windows)
	if strFrame:gsub("%s-%a-map%a*[%s%p]*","") == "" then					-- May be prefixed with "map" mode to just map dialogue initially
		strFrame = "map show norm"												-- If only "map" mode then default to "map show norm"
	end
	if type(iupDialog) == "userdata" then
		tblName.Dialog = iupDialog
		tblName.Focus  = btnFocus													-- Preserve parameters
		tblName.Frame  = strFrame
		iupDialog.Background = Back												-- Background colour
		iupDialog.Shrink = "YES"													-- Sometimes needed to shrink controls to raster size
		if type(btnFocus) == "userdata" then									-- Set button as focus for Esc and Enter keys
			iupDialog.StartFocus   = iupDialog.StartFocus   or btnFocus
			iupDialog.DefaultEsc   = iupDialog.DefaultEsc   or btnFocus
			iupDialog.DefaultEnter = iupDialog.DefaultEnter or btnFocus
		end
		iupDialog.MaxSize = intMaxW.."x"..intMaxH								-- Maximum size is screen size
		iupDialog.MinSize = "x"													-- Minimum size (default "x" becomes nil)
		iupDialog.RasterSize = tblName.Raster or "x"							-- Raster size  (default "x" becomes nil)
		if strFrame:match("norm") then											-- The dialogframe mode is "NO" by default
			if not ( strFrame:match("pop") or strFrame:match("keep") ) then 
				strFrame = strFrame.." show"										-- If not "popup" nor "keep" then use "showxy" mode
			end
		else
			iupDialog.DialogFrame = "YES"										-- Define dialogframe mode for fixed size window
		end
		iupDialog.close_cb  = iupDialog.close_cb  or function() return iup.CLOSE end	-- Define default window X close, move, and resize actions
		iupDialog.move_cb   = iupDialog.move_cb   or function(self,x,y) if IsNormalWindow(self) then tblName.CoordX=x tblName.CoordY=y end end
		iupDialog.resize_cb = iupDialog.resize_cb or function(self)     if IsNormalWindow(self) then tblName.Raster=self.RasterSize end end
		if strFrame:match("map") then											-- Only dialogue mapping is required
			iupDialog:map()
--!			tblName.Frame = strFrame:gsub("map","")							-- Remove "map" from frame mode ready for subsequent call
			tblName.Frame = strFrame:gsub("%s-%a-map%a*[%s%p]*","")		-- Remove "map" from frame mode ready for subsequent call
			return
		end
		RefreshDialogue(strName)													-- Refresh to set Natural Size as Minimum Size
		if iup.MainLoopLevel() == 0												-- Called from outside Main GUI, so must use showxy() and not popup()
		or strFrame:match("sho") then											-- Use showxy() to dispay dialogue window for "showxy" mode
			iupDialog:showxy(tblName.CoordX,tblName.CoordY)
			if History ~= Version then											-- Initially show new Version History Help
				if type(HelpDialogue) == "function" then
					History = Version
					HelpDialogue(Version)											-- But only after Help dialogue exists
					iupDialog.BringFront = "YES"
				end
			end
			if strName ~= "Help" and iup.MainLoopLevel() == 0 then iup.MainLoop() end
		else
			iupDialog:popup(tblName.CoordX,tblName.CoordY)					-- Use popup() to display dialogue window for "popup" or "keep" modes
		end
		if strFrame:match("pop") then
			tblName.Dialog = nil													-- When popup closed, clear key parameters, but not for "keep" mode
			tblName.Raster = nil
			tblName.CoordX = nil -- iup.CENTER
			tblName.CoordY = nil -- iup.CENTER
		end
	end
end -- function ShowDialogue

local function strDialogueArgs(strArgA,strArgB,comp)						-- Compare two argument pairs and return matching pair
	local tblArgA = stringx.splitnumbers(strArgA)
	local tblArgB = stringx.splitnumbers(strArgB)
	local strArgX = tostring(comp(tblArgA[1] or 100,tblArgB[1] or 100))
	local strArgY = tostring(comp(tblArgA[2] or 100,tblArgB[2] or 100))
	return strArgX.."x"..strArgY
end -- local function strDialogueArgs

function RefreshDialogue(strName)												-- Refresh dialogue window size after Font change, etc
	local tblName = tblNameFor(strName)
	local iupDialog = tblName.Dialog											-- Retrieve the dialogue handle
	if type(iupDialog) == "userdata" then
		iupDialog.Size = iup.NULL
		iup.Refresh(iupDialog)														-- Refresh window to Natural Size and set as Minimum Size
		if not iupDialog.RasterSize then
			iupDialog:map()
			iup.Refresh(iupDialog)
		end
		iupDialog.MinSize = strDialogueArgs(iupDialog.MaxSize,iupDialog.RasterSize,math.min)	-- Set Minimum Size to smaller of Maximm Size or Natural Size
		iupDialog.RasterSize = strDialogueArgs(tblName.Raster,iupDialog.RasterSize,math.max)	-- Set Current Size to larger of Current Size or Natural Size
		iup.Refresh(iupDialog)
		tblName.Raster = iupDialog.RasterSize
		if iupDialog.Visible == "YES" then										-- Ensure visible dialogue origin is on screen
			tblName.CoordX = math.max(tblName.CoordX,10)
			tblName.CoordY = math.max(tblName.CoordY,10)						-- Set both coordinates to larger of current value or 10 pixels
			if iupDialog.Modal == "NO" then
				iupDialog.ZOrder = "BOTTOM"										-- Ensure dialogue is subservient to any popup
				iupDialog:showxy(tblName.CoordX,tblName.CoordY)				-- Use showxy() to reposition main window
			else
				iupDialog:popup(tblName.CoordX,tblName.CoordY)				-- Use popup() to reposition modal window
			end
		else
			iupDialog.BringFront="YES"
		end
	end
end -- function RefreshDialogue

function AssignAttributes(tblControls)											-- Assign the attributes of all controls supplied
	local anyFunction = nil
	for iupName, tblAttr in pairs ( tblControls or {} ) do
		if type(iupName) == "userdata" and type(tblAttr) == "table" then-- Loop through each iup control
			for intAttr, anyName in ipairs ( tblControls[1] or {} ) do	-- Loop through each iup attribute
				local strName = nil
				local strAttr = nil
				local strType = type(anyName)
				if strType == "string" then										-- Attribute is different for each control in tblControls
					strName = anyName
					strAttr = tblAttr[intAttr]
				elseif strType == "table" then									-- Attribute is same for all controls as per tblControls[1] 
					strName = anyName[1]
					strAttr = anyName[2]
				elseif strType == "function" then
					anyFunction = anyName
					break
				end
				if type(strName) == "string" and ( type(strAttr) == "string" or type(strAttr) == "function" ) then
					local anyRawGet = rawget(fh,strAttr)						-- Use rawget() to stop require("pl.strict") complaining
					if type(anyRawGet) == "string" then
						strAttr = anyRawGet											-- Use internal module attribute such as Head or FontBody
					end
					iupName[strName] = strAttr									-- Assign attribute to control
				end
			end
		end
	end
	if anyFunction then anyFunction() end										-- Perform any control assignment function
end -- function AssignAttributes

-- Font Dialogue Attributes and Functions --

FontBody = iup.GetGlobal("DEFAULTFONT")										-- Set default font for Body and Head text
FontHead = FontBody:gsub(", B?o?l?d?",", Bold ")

---[=[
local intFontPlain  = 1															-- Font Face & Style values for legacy FontSet setting
local intFontBold   = 2
local intArialPlain = 3
local intArialBold  = 4
local intTahomaPlain= 5
local intTahomaBold = 6
local strFontFace = FontBody:gsub(",.*","")
local tblFontSet = {}																-- Lookup table for FontHead and FontBody
tblFontSet[intFontPlain]		=	{ Head=strFontFace..", Bold -16",	Body=strFontFace..",      -16", }
tblFontSet[intFontBold]		=	{ Head=strFontFace..", Bold -16",	Body=strFontFace..", Bold -15", }
tblFontSet[intArialPlain]		=	{ Head="Arial,         Bold -16",	Body="Arial,              -16", }
tblFontSet[intArialBold]		=	{ Head="Arial,         Bold -16",	Body="Arial,         Bold -15", }
tblFontSet[intTahomaPlain]	=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,             -16", }
tblFontSet[intTahomaBold]		=	{ Head="Tahoma,        Bold -15",	Body="Tahoma,        Bold -14", }

function FontAssignment(intFontSet)												-- Assign Font Face & Style GUI values for legacy FontSet setting
	if 	intFontSet then
		intFontSet = math.max(intFontSet,1)
		intFontSet = math.min(intFontSet,#tblFontSet)
		FontHead = tblFontSet[intFontSet]["Head"]								-- Legacy Font for all GUI dialog header text
		FontBody = tblFontSet[intFontSet]["Body"]								-- Legacy Font for all GUI dialog body text
	end
end -- function FontAssignment
--]=]

function FontDialogue(tblAttr,strName)											-- GUI Font Face & Style Dialogue
	tblAttr = tblAttr or {}
	strName = strName or "Main"
	local isFontChosen = false
	local btnFontHead = iup.button { Title="Choose Headings Font and default Colour" }
	local btnFontBody = iup.button { Title="Choose Body text Font and default Colour" }
	local btnCol_Safe = iup.button { Title=" Safe Colour " }
	local btnCol_Warn = iup.button { Title=" Warning Colour " }
	local btnCol_Risk = iup.button { Title=" Risky Colour " }
	local btnDefault  = iup.button { Title=" Default Fonts " }
	local btnMinimum  = iup.button { Title=" Minimum Size " }
	local btnDestroy  = iup.button { Title=" Close Dialogue " }
	local frmSetFonts = iup.frame  { Title=" Set Window Fonts & Colours ",
								iup.vbox { Alignment="ACENTER", Margin=Margin, Homogeneous="YES",
									btnFontHead,
									btnFontBody,
									iup.hbox { btnCol_Safe, btnCol_Warn, btnCol_Risk, Homogeneous="YES" },
									iup.hbox { btnDefault , btnMinimum , btnDestroy , Homogeneous="YES" },
								} -- iup.vbox end
							} -- iup.frame end

	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local dialogFont  = iup.dialog { Title=" Set Window Fonts & Colours ", Gap=Gap, Margin=Border, frmSetFonts }

	local tblButtons = { }

	local function setDialogues()												-- Refresh the Main and Help dialogues
		local tblHelp = tblNameFor("Help")
		if type(tblHelp.Dialog) == "userdata" then							-- Help dialogue exists
			AssignAttributes(tblHelp.TblAttr)									-- Assign the Help dialogue attributes
			RefreshDialogue("Help")												-- Refresh the Help window size & position
		end
		AssignAttributes(tblAttr)													-- Assign parent dialogue attributes
		RefreshDialogue(strName)													-- Refresh parent window size & position and bring infront of Help window
		RefreshDialogue("Font")													-- Refresh Font window size & position and bring infront of parent window
	end -- local function setDialogues

	local function getFont(strColor)											-- Set font button function
		local strTitle = " Choose font style & default colour for "..strColor:gsub("Head","Heading").." text "
		local strValue = "Font"..strColor										-- The font codes below are not recognised by iupFontDlg and result in empty font face!
		local strFont  = rawget(fh,strValue):gsub(" Black,",","):gsub(" Light, Bold",","):gsub(" Extra Bold,",","):gsub(" Semibold,",",")
		local iupFontDlg = iup.fontdlg { Title=strTitle, Color=rawget(fh,strColor), Value=strFont }
		iupFontDlg:popup()															-- Popup predefined font dialogue
		if iupFontDlg.Status == "1" then
			if iupFontDlg.Value:match("^,") then								-- Font face missing so revert to original font
				iupFontDlg.Value = rawget(fh,strValue)
			end
			fh[strColor] = iupFontDlg.Color										-- Set Head or Body color attribute
			fh[strValue] = iupFontDlg.Value										-- Set FontHead or FontBody font style
			AssignAttributes(tblButtons)											-- Assign the button & frame attributes
			setDialogues()
			isFontChosen = true
		end
	end -- local function getFont

	local function getColor(strColor)											-- Set colour button function
		local strTitle = " Choose colour for "..strColor:gsub("Warn","Warning"):gsub("Risk","Risky").." button & message text "
		local iupColorDlg = iup.colordlg { Title=strTitle, Value=rawget(fh,strColor), ShowColorTable="YES" }
		iupColorDlg:popup()															-- Popup predefined color dialogue
		if iupColorDlg.Status == "1" then
			fh[strColor] = iupColorDlg.Value									-- Set Safe or Warn or Risk color attribute
			AssignAttributes(tblButtons)											-- Assign the button & frame attributes
			setDialogues()
			isFontChosen = true
		end
	end -- local function getColor

	local function setDefault()													-- Action for Default Fonts button
		Safe = Green
		Warn = Magenta
		Risk = Red																	-- Set default colours
		Body = Black
		Head = Black
		FontBody = iup.GetGlobal("DEFAULTFONT")								-- Set default fonts for Body and Head text
		FontHead = FontBody:gsub(", B?o?l?d?",", Bold")
		AssignAttributes(tblButtons)												-- Assign the button & frame attributes
		setDialogues()
		isFontChosen = true
	end -- local function setDefault

	local function setMinimum()													-- Action for Minimum Size button
		local tblName = tblNameFor(strName)
		local iupDialog = tblName.Dialog										-- Retrieve the parent dialogue handle
		if type(iupDialog) == "userdata" then
			tblName.Raster = "10x10"												-- Refresh parent window to Minimum Size & adjust position
			RefreshDialogue(strName)
		end
		local tblFont = tblNameFor("Font")
		tblFont.Raster = "10x10"													-- Refresh Font window to Minimum Size & adjust position
		RefreshDialogue("Font")
	end -- local function setMinimum

	tblButtons  =  {  {  "Font" , "FgColor" , "Tip" , "action" , {"TipBalloon";"Balloon"} , {"Expand";"YES"} },
		[btnFontHead] = { "FontHead", "Head", "Choose the Heading text Font Face, Style, Size, Effects, and default Colour", function() getFont("Head") end },
		[btnFontBody] = { "FontBody", "Body", "Choose the Body text Font Face, Style, Size, Effects, and default Colour"   , function() getFont("Body") end },
		[btnCol_Safe] = { "FontBody", "Safe", "Choose the colour for Safe operations"   , function() getColor("Safe") end },
		[btnCol_Warn] = { "FontBody", "Warn", "Choose the colour for Warning operations", function() getColor("Warn") end },
		[btnCol_Risk] = { "FontBody", "Risk", "Choose the colour for Risky operations"  , function() getColor("Risk") end },
		[btnDefault ] = { "FontBody", "Safe", "Restore default Fonts and Colours", function() setDefault() end },
		[btnMinimum ] = { "FontBody", "Safe", "Reduce window to its minimum size", function() setMinimum() end },
		[btnDestroy ] = { "FontBody", "Risk", "Close this dialogue ", function() return iup.CLOSE end },
		[frmSetFonts] = { "FontHead", "Head" },
		} 

	AssignAttributes(tblButtons)													-- Assign the button & frame attributes
	ShowDialogue("Font",dialogFont,btnDestroy,"keep normal")				-- Popup the Set Window Fonts dialogue: "keep normal"  : vary size & posn, and remember size & posn
--	ShowDialogue("Font",dialogFont,btnDestroy,"popup normal")				-- Popup the Set Window Fonts dialogue: "popup normal" : vary size & posn, but redisplayed centred
--	ShowDialogue("Font",dialogFont,btnDestroy,"keep")						-- Popup the Set Window Fonts dialogue: "keep" : fixed size, vary posn, and only remember posn
--	ShowDialogue("Font",dialogFont,btnDestroy,"popup")						-- Popup the Set Window Fonts dialogue: "popup": fixed size, vary posn, but redisplayed centred
	dialogFont:destroy()
	return isFontChosen

end -- function FontDialogue

-- Help Dialogue Attributes and Functions

HelpDialogue = ""																	-- HelpDialogue must be declared for ShowDialogue

local strHelpButtonActive = nil  -- defaults to "YES"						-- Help button active attribute mode used only in NewHelpDialogue

function NewHelpDialogue(btnGetHelp,strRootURL)								-- Prototype for GUI Help Dialogue, with parent Help button, and web page root/namespace URL
	local tblHelp = tblNameFor("Help")
	local oleControl, btnDestroy, hboxHelp, dialogHelp						-- Dialogue component upvalues
	if type(btnGetHelp) == "userdata" then
		btnGetHelp.Active = strHelpButtonActive
		if btnGetHelp.Active == "NO" then										-- Help button inactive, so Help dialogue exists, so just update parent button
			tblHelp.GetHelp = btnGetHelp											-- Allows successive parent GUI to share one Help dialogue
			return
		end
	end
	tblHelp.GetHelp = btnGetHelp
	strRootURL = strRootURL or Plugin:gsub(" ","_"):lower()				-- Default to Plugin name as Wiki namespace
	if strRootURL:match("^[%w_]+$") then										-- Append Wiki namespace to Wiki root URL
		strRootURL = "http://www.fhug.org.uk/wiki/doku.php?id=plugins:help:"..strRootURL..":"
	end
	tblHelp.RootURL = strRootURL
	local intURL = 1																-- Index to Version History help page URL
	local tblURL = { }																-- List of help page URL
	local tblAttr = { { "Font", "FgColor" } }									-- Attribute table primarily for FontDialogue()
	tblHelp.TblAttr = tblAttr

	local function doCommonAction()												-- Common action when creating/destroying Help dialogue
		local strMode = "NO"
		if tblHelp.Dialog then
			tblHelp.Dialog = nil													-- Clear dialog handle
			strMode = nil															-- Defaults to "YES" but more efficient to test
		end 
		if type(tblHelp.GetHelp) == "userdata" then							-- Set parent dialogue Help button active mode
			tblHelp.GetHelp.Active = strMode
		end
		strHelpButtonActive = strMode
	end -- local function doCommonAction										-- Save global Help button active mode

	function HelpDialogue(anyPage)												-- GUI Help Dialogue for chosen web page
		--[=[
			Parameter anyPage can be one of several values:
			1. Page number from 0 to index tblURL, often equal to intTabPosn.
			2. Version to display Version History page for version chosen.
			3. String with " "="_" and lowercase substring of a page name in tblURL.
		--]=]

		if not tblHelp.Dialog then
			doCommonAction()
			-- Create the WebBrowser based on its ProgID and connect it to LuaCOM
			oleControl = iup.olecontrol{ "Shell.Explorer.1", designmode="NO", }
			oleControl:CreateLuaCOM()
			btnDestroy = iup.button { Title="Close Window", Tip="Close this Help and Advice window", TipBalloon=Balloon, Expand="HORIZONTAL", Size="x10", FgColor=Risk, action=function() dialogHelp:destroy() doCommonAction() end }
			hboxHelp = iup.hbox { margin=Margin, homogeneous="NO" }
			-- Create each GUI button with title, tooltip, color, action, etc, and table of web page URL
			for intButton, tblButton in ipairs(tblHelp) do
				local intPage = tblButton.Page or intButton
				local strURL  = tblButton.URL
				if strURL:match("ver.-hist") then intURL = intPage end
				tblURL[intPage] = strURL
				local btnName = iup.button { Title=tblButton.Name, Tip=tblButton.Tip, TipBalloon=Balloon, Expand=btnDestroy.Expand, Size=btnDestroy.Size, FgColor=Safe, action=function() oleControl.com:Navigate(tblHelp.RootURL..strURL) end }
				iup.Append(hboxHelp,btnName)
				tblAttr[btnName] = { "FontBody", "Safe" }
			end
			iup.Append(hboxHelp,btnDestroy)
			tblAttr[btnDestroy] = { "FontBody", "Risk" }
			dialogHelp = iup.dialog { Title=Plugin.." Help & Advice", Font=FontBody,
								iup.vbox { Alignment="ACENTER", Gap=Gap, Margin=Border, ExpandChildren="YES",
									oleControl,
									hboxHelp,
								},
								close_cb = function() doCommonAction() end,
							}
			ShowDialogue("Help",dialogHelp,btnDestroy)						-- Show Help dialogue window and set tblHelp.Dialog = dialogHelp
		end
		anyPage = anyPage or 0
		if type(anyPage) == "number" then										-- Select page by Tab = Button = Help page index
			anyPage = math.max(1,math.min(#tblURL,anyPage+1))
			anyPage = tblURL[anyPage] or ""
		elseif anyPage == Version then											-- Select the Version History features section
			anyPage = anyPage:gsub("[%s%p]","")
			anyPage = anyPage:gsub("^(%d)","V%1")
			anyPage = tblURL[intURL].."#features_of_"..anyPage
		elseif type(anyPage) == "string" then									-- Select page by matching name text
			local strPage = anyPage:gsub(" ","_"):lower()
			anyPage = tblURL[1] or ""												-- Default to first web page
			for intURL = 1, #tblURL do
				local strURL = tblURL[intURL]
				if strURL:match(strPage) then
					anyPage = strURL
					break
				end
			end
		else
			anyPage = tblURL[1] or ""												-- Default to first web page
		end
		oleControl.com:Navigate(tblHelp.RootURL..anyPage)					-- Navigate to chosen web page
	end -- function HelpDialogue

end -- function NewHelpDialogue

function AddHelpButton(strName,strTip,strURL,intPage)						-- Add button to GUI Help Dialogue
	local tblHelp = tblNameFor("Help")
	if tblHelp and not strHelpButtonActive then
		for intHelp, tblHelp in ipairs(tblHelp) do							-- Check button does not already exist
			if tblHelp.Name == strName then return end
		end
		if tonumber(intPage) then intPage = intPage + 1 end					-- Optional external intPage number matches intTabPosn
		table.insert( tblHelp, { Name=strName or "?", Tip=strTip or "?", URL=strURL or "", Page=intPage } )
	end
end -- function AddHelpButton

local function anyMemoControl(anyName,fgColor)								-- Compose any control Title and FgColor
	local strName = tostring(anyName)											-- anyName may be a string, and fgColor is default FgColor
	local tipText = nil
	if type(anyName) == "table" then											-- anyName may be a table = { Title string , FgColor string , ToolTip string (optional) }
		strName = anyName[1]
		fgColor = anyName[2]:match("%d* %d* %d*") or fgColor
		tipText = anyName[3]
	end
	return strName, fgColor, tipText
end -- local function anyMemoControl

local function anyMemoDialogue(strHead,anyHead,strMemo,anyMemo,...)		-- Display framed memo dialogue with buttons
	local intButt = 0																-- Returned value if "X Close" button is used
	local tblButt = { [0]="X Close" }											-- Button names lookup table
	local strHead, fgcHead, tipHead = anyMemoControl(anyHead or "",strHead)
	local strMemo, fgcMemo, tipMemo = anyMemoControl(anyMemo or "",strMemo)
	-- Create the GUI labels and buttons
	local lblMemo = iup.label { Title=strMemo, FgColor=fgcMemo, Tip=tipMemo, TipBalloon=Balloon, Alignment="ACENTER", Padding=Margin, Expand="YES", WordWrap="YES" }
	local lblLine = iup.label { Separator="HORIZONTAL" }
	local iupHbox = iup.hbox  { Homogeneous="YES" }
	local btnButt = iup.button { }
	if #arg == 0 then arg[1] = "OK" end											-- If no buttons listed then default to an "OK" button
	for intArg, anyButt in ipairs(arg) do
		local strButt, fgcButt, tipButt = anyMemoControl(anyButt,Safe)
		tblButt[intArg] = strButt
		btnButt = iup.button { Title=strButt, FgColor=fgcButt, Tip=tipButt, TipBalloon=Balloon, Expand="NO", MinSize="80", Padding=Margin, action=function() intButt=intArg return iup.CLOSE end }
		iup.Append( iupHbox, btnButt )
	end
	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local iupMemo = iup.dialog { Title=Plugin..Version..strHead,
							iup.vbox { Alignment="ACENTER", Gap=Gap, Margin=Margin,
								iup.frame { Title=strHead, FgColor=fgcHead, Font=FontHead,
									iup.vbox { Alignment="ACENTER", Font=FontBody, lblMemo, lblLine, iupHbox },
								},
							},
						}
	ShowDialogue("Memo",iupMemo,btnButt,"popup")								-- Show popup Memo dialogue window with righthand button in focus
	iupMemo:destroy()
	return intButt, tblButt[intButt]
end -- local function anyMemoDialogue

function MemoDialogue(anyMemo,...)												-- Multi-Button GUI like iup.Alarm and fhMessageBox, with "Memo" in frame
	return anyMemoDialogue(Head,"Memo",Body,anyMemo,...)
end -- function MemoDialogue

function WarnDialogue(anyHead,anyMemo,...)									-- Multi-Button GUI like iup.Alarm and fhMessageBox, with heading in frame
	return anyMemoDialogue(Warn,anyHead,Warn,anyMemo,...)
end -- function WarnDialogue

local function httpRequest(strRequest)											-- Luacom http request protected by pcall() below
	local http = luacom.CreateObject("winhttp.winhttprequest.5.1")
	http:Open("GET",strRequest,false)
	http:Send()
	return http.Responsebody
end -- local function httpRequest

function VersionInStore(anyPlugin)												-- Obtain the Version in Plugin Store by Name or Id
	local strType = "name="
	if type(anyPlugin) == "number"
	or tonumber(anyPlugin) then strType = "id=" end
	if anyPlugin then
		local strFile = MachinePath.."\\VersionInStoreInternetError.dat"
		local strRequest ="http://www.family-historian.co.uk/lnk/checkpluginversion.php?"..strType..anyPlugin
		local isOK, strReturn = pcall(httpRequest,strRequest)
		if not isOK then															-- Problem with Internet access
			local intTime = os.time() - 36000									-- Time in seconds 10 hours ago
			local tblAttr, strError = lfs.attributes(strFile)				-- Obtain file attributes
			if not tblAttr or tblAttr.modification < intTime then			-- File does not exist or was modified long ago 
				fhMessageBox(strReturn.."\n The Internet appears to be inaccessible. ")
			end
			general.SaveStringToFile(strFile,strFile)							-- Update file modified time
			return "0"
		end
		general.DeleteFile(strFile)												-- Delete file if Internet is OK
		local strVersion = "0"
		if strReturn ~= nil then
			strVersion = strReturn:match("([%d%.]*),%d*")					-- Version digits & dots then comma and Id digits 
		end
		return strVersion or "0"
	else
		return "0"
	end
end -- function VersionInStore

local function intVersion(strVersion)											-- Convert version string to comparable integer
	local intVersion = 0
	local tblVersion = stringx.split(strVersion,".")
	for i=1,5 do
		intVersion = intVersion * 1000 + tonumber(tblVersion[i] or 0)
	end
	return intVersion
end -- local function intVersion

function CheckVersionInStore()													-- Check if later Version available in Plugin Store
	local strPlugin = fhGetContextInfo("CI_PLUGIN_NAME")
	local strNewVer = VersionInStore(strPlugin:gsub(" %- .*",""))
	local strOldVer = Version
	if intVersion(strNewVer) > intVersion(strOldVer:match("%D*([%d%.]*)")) then
		MemoDialogue("Later Version "..strNewVer.." of this Plugin is available from the Family Historian 'Plugin Store'.")
	end
end -- function CheckVersionInStore

function PluginDataScope(strScope)												-- Set default Plugin Data scope to per-Project, or per-User, or per-Machine
	strScope = tostring(strScope):lower()
	if strScope:match("mach") then												-- Per-Machine
		strDefaultScope = "Machine"
	elseif strScope:match("user") then											-- Per-User
		strDefaultScope = "User"
	end																					-- Per-Project is default
end -- function PluginDataScope

local function getDataFiles(strScope)											-- Compose the Plugin Data file & path & root names
	local strDataFile = fhGetPluginDataFileName(strScope)					-- Allow plugins with variant filenames to use same plugin data files
	strDataFile = strDataFile:gsub("\\"..Plugin:gsub(" ","_"):lower(),"\\"..Plugin)
	strDataFile = strDataFile:gsub("\\"..Plugin..".+%.[D,d][A,a][T,t]$","\\"..Plugin..".dat")
	if strDataFile == "" and strScope == "CURRENT_PROJECT" then			-- Use standalone GEDCOM path & filename..".fh_data\Plugin Data\" as the folder + the Plugin Filename..".dat"
		strDataFile = fhGetContextInfo("CI_GEDCOM_FILE")
		strDataFile = strDataFile:gsub("%.[G,g][E,e][D,d]",".fh_data")
		lfs.mkdir(strDataFile)
		strDataFile = strDataFile.."\\Plugin Data"
		lfs.mkdir(strDataFile)
		strDataFile = strDataFile.."\\"..Plugin..".dat"
	end
	local strDataPath = strDataFile:gsub("\\"..Plugin.."%.[D,d][A,a][T,t]$","")	-- Plugin data folder path name
	local strDataRoot = strDataPath.."\\"..Plugin										-- Plugin data file root name
	return strDataFile, strDataPath, strDataRoot
end -- local function getDataFiles

function Initialise(strVersion,strPlugin)											-- Initialise the GUI module with optional Version & Plugin name

	local strAppData = fhGetContextInfo("CI_APP_DATA_FOLDER")

	Plugin = fhGetContextInfo("CI_PLUGIN_NAME")									-- Plugin Name from file
	Version = strVersion or " "														-- Plugin Version
	if Version == " " then
		local strTitle = "\n@Title is missing"
		local strAuthor = "\n@Author is missing"
		local strVersion = "\n@Version is missing"
		local strPlugin = strAppData.."\\Plugins\\"..Plugin..".fh_lua"
		for strLine in io.lines(strPlugin) do										-- Read each line from the Plugin file
			strPlugin = strLine:match("^@Title:%s*(.*)")
			if strPlugin then
				strPlugin = strPlugin:gsub("&&","&")
				if Plugin:match("^"..strPlugin:gsub("(%W)","%%%1")) then
					Plugin = strPlugin													-- Prefer Title to Filename if it matches
					strTitle = nil
				else
					strTitle = "\n@Title differs from Filename"					-- Report abnormality
				end
			end
			if strLine:match("^@Author:%s*(.*)") then								-- Check @Author exists
				strAuthor = nil
			end 
			Version = strLine:gsub("^@Version:%D*([%d%.]*)%D*"," %1 ")
			if Version ~= strLine then												-- Obtain the @Version from Plugin file
				strVersion = nil
				break
			end
		end
		if strTitle or strAuthor or strVersion then								-- Report any header abnormalities
			fhMessageBox("\nScript Header: "..Plugin..(strTitle or "")..(strAuthor or "")..(strVersion or ""))
		end
	end
	History = Version																	-- Version History
	Plugin  = strPlugin or Plugin													-- Plugin Name from argument or default from file

	CustomDialogue("Help","1020x730")												-- Custom "Help" dialogue sizes

	DefaultDialogue()																	-- Default "Font","Help","Main" dialogues

	MachineFile,MachinePath,MachineRoot = getDataFiles("LOCAL_MACHINE")		-- Plugin data names per machine
	PerUserFile,PerUserPath,PerUserRoot = getDataFiles("CURRENT_USER")		-- Plugin data names per user
	ProjectFile,ProjectPath,ProjectRoot = getDataFiles("CURRENT_PROJECT")	-- Plugin data names per project

	PublicPath = fhGetContextInfo("CI_PROJECT_PUBLIC_FOLDER")					-- Public data folder path name
	if PublicPath == "" then PublicPath = ProjectPath end

	CalicoPie = strAppData:gsub("\\Calico Pie\\.*","\\Calico Pie")			-- Program Data Calico Pie path name

	ComputerName = os.getenv("COMPUTERNAME")										-- Local PC Computer Name

end -- function Initialise

local iupVersion = iup.GetGlobal("VERSION")

Initialise()		-- Initialise module with default values

return fh

end -- local function iup_gui_v2

stringx_v2 = stringx_v2("stringx")
tablex_v1  = tablex_v1 ("tablex")
encoder_v2 = encoder_v2("encoder")
general_v1 = general_v1("general")
iterate_v1 = iterate_v1("iterate")
progbar_v1 = progbar_v1("progbar")
iup_gui_v2 = iup_gui_v2("iup_gui")

-- All above should eventually become library modules as loaded below --

--]==]

--[==[
local fhLoadRequire = require("fhLoadRequire").fhLoadRequire				-- Interim fhLoadRequire() API

if not fhLoadRequire("pl","pl.init") then return end						-- Load required Penlight modules
require("pl.import_into")()
require("pl.strict")																-- Strict check for undeclared globals

if not fhLoadRequire("fh.library_v2") then return end 						-- Load required FH v2 modules
require("fh.modules_v2")()
--]==]
stringx_v2.import()																	-- To access FH string extension v2 module
tablex_v1.import()																	-- To access FH table extension v1 module
local encoder = encoder_v2														-- To access FH encoder of text v2 module
local general = general_v1														-- To access FH general useful v1 module
--local iterate = iterate_v1														-- To access FH iterate items v1 module
--local progbar = progbar_v1														-- To access FH progress bar v1 module including "iuplua"
local iup_gui = iup_gui_v2														-- To access FH GUI builder v2 module including "iuplua", "lfs", "fh.general_v1" & "fh.loadreq_v1", "fh.stringx_v2", etc

local StrButton = nil																-- Needed to stop require("pl.strict") crashing IUP

-- Global Data Definitions --
function PresetGlobalData()

	iup_gui.Margin = "4x4"
	iup_gui.Balloon = "YES"
																						-- Filename Global Constants
	StrPluginRoot = iup_gui.ProjectRoot											-- Project Plugin data file root name
	StrPublicPath = iup_gui.PublicPath											-- Public data folder path name
	StrCalicoPie  = iup_gui.CalicoPie											-- Program Data Calico Pie path name
	StrApplicPie  = os.getenv("APPDATA").."\\Calico Pie"					-- Application Data Calico Pie root to Plugin Data	--! 11 Feb 2014
	StrPublicPie  = os.getenv("PUBLIC") or os.getenv("ALLUSERSPROFILE")	-- Windows 8/7/Vista or Windows XP Public folder
	StrPublicPie  = StrPublicPie.."\\Documents\\Calico Pie"				-- Public Documents Calico Pie root to Tutorial Files
	StrProg_Data  = "\\Program Data"											-- Backup data Program Data subfolder
	StrUser_Data  = "\\Plugin Data"												-- Plugin Data subfolder	--! 11 Feb 2014
	StrTutorials  = "\\Tutorial Files"											-- Tutorial Files subfolder
	StrBatFile = iup_gui.MachineRoot..".bat"
	StrLogFile = iup_gui.MachineRoot..".log"									-- Batch job files use MachineRoot to avoid slow NAS drives
	StrRegFile = iup_gui.MachineRoot..".reg"
	StrRegName = StrRegFile:gsub(StrCalicoPie.."\\","")
	general.DeleteFile(StrBatFile)
	general.DeleteFile(StrLogFile)
	general.DeleteFile(StrRegFile)

	StrBackupDir = ""																-- Default Backup & Restore folder path
	IntBackupMod = 0																-- Backup Modified Date-Time

	StrBackupKey = ""																-- FH Preferences Backup folder path

	TblProgram = {}																	-- Family Historian Programs & Versions
	TblVersion = {}

end -- function PresetGlobalData

-- Reset Sticky Settings to Default Values --
function ResetDefaultSettings()
	iup_gui.CustomDialogue("Main","0x0")					-- GUI window minimum size and central position for "Main"
	iup_gui.DefaultDialogue("Mode")							-- GUI window RasterSize and X & Y co-ordinates for "Main","Font","Help" & "Mode" dialogues
	iup_gui.History = " "										-- Version History reset for initial Help
	StrRegistry = "OFF"											-- Allow RESTORE Registry Data: OFF
	StrDiagnose = "OFF"											-- Enable Diagnostic Mode: OFF
	StrDatedDir = "OFF"											-- Use Dated Sub-folders: OFF -- 19 July 2013
end -- function ResetDefaultSettings

-- Load Sticky Settings from File --
function LoadSettings()
	iup_gui.LoadSettings()										-- Includes "Main","Font","Help" dialogues and "FontSet" & "History"
	StrBackupDir = tostring(iup_gui.LoadLocal ("Backup", StrBackupDir))
	StrRegistry  = tostring(iup_gui.LoadGlobal("Registry",StrRegistry))
	StrDiagnose  = tostring(iup_gui.LoadGlobal("Diagnose",StrDiagnose))
	StrDatedDir  = tostring(iup_gui.LoadGlobal("DatedDir",StrDatedDir)) -- 19 July 2013
	SaveSettings()												-- Save sticky data settings
end -- function LoadSettings

-- Save Sticky Settings to File --
function SaveSettings()
	iup_gui.SaveLocal ("Backup", StrBackupDir)
	iup_gui.SaveGlobal("Registry",StrRegistry)
	iup_gui.SaveGlobal("Diagnose",StrDiagnose)
	iup_gui.SaveGlobal("DatedDir",StrDatedDir)			-- 19 July 2013
	iup_gui.SaveSettings()										-- Includes "Main","Font","Help" dialogues and "FontSet" & "History"
end -- function SaveSettings

-- Make New Help Dialogue from Prototype --
function MakeHelpDialogue(btnHelp)
	iup_gui.NewHelpDialogue(btnHelp)						-- Supply control Help button and pages in tab and alphabetical order
	iup_gui.AddHelpButton("Introduction"		,"Introduction Page for Help and Advice"	,"backup_and_restore_family_historian_settings"	)
	iup_gui.AddHelpButton("Backup tab"			,"Backup tab Help and Advice"				,"backup"				)
	iup_gui.AddHelpButton("Restore tab"			,"Restore tab Help and Advice"				,"restore"			)
	iup_gui.AddHelpButton("Options tab"			,"Options tab Help and Advice"				,"settings"			)
	iup_gui.AddHelpButton(" F. A. Q. "			,"Frequently Asked Questions"				,"the_faq"			)
	iup_gui.AddHelpButton("Version History"	,"Version History of Features"				,"version_history"	)
end -- function MakeHelpDialogue

-- Invoke FH Shell Execute API --
function DoExecute(strExecutable, strParameter)
	local function ReportError(strMessage)
		GUI_ModeDialogue(	"Shell Execute Error",
								"ERROR: "..strMessage.." :\n"..strExecutable.."\n"..strParameter.."\n\n",
								"OK"	)
	end -- local function ReportError
	return general.DoExecute(strExecutable, strParameter, ReportError)
end -- function DoExecute

-- GUI Mode Prompt Dialogue --
function GUI_ModeDialogue(strHead,strText,...)
	local strAnswer = ""										-- Name of Button pressed
	local btnAnswer = iup.button{}
	local iupHbox = iup.hbox{ Margin=iup_gui.Margin, Homogeneous="NO", Expand="YES", }
	for intButton, strButton in ipairs( arg ) do			-- Set or hide each GUI Button according to Button arguments
		local strVisible = "YES"
		local strActive = "YES"
		local strColor = iup_gui.Safe
		if strButton == "" then strVisible = "NO" strActive = "NO" end
		if strButton:match("Registry Data") and StrRegistry == "OFF" then strActive = "NO" end
		if strButton:match("Skip") or strButton:match("Cancel") then strColor = iup_gui.Risk end
		local btnButton = iup.button{ Title=strButton, Expand="YES", Size="x10", Visible=strVisible, Active=strActive, FgColor=strColor, action=function() strAnswer=strButton return iup.CLOSE end }
		iup.Append(iupHbox,btnButton)
		if intButton == #arg then
			btnAnswer = btnButton								-- Right-hand button gets focus and sets Default/Close strAnswer
			strAnswer = strButton
		end
	end
	for intArg = 1, 4 - #arg do								-- Pad with up to 4 hidden buttons to maintain a tidy layout
		local btnButton = iup.button{ Title="", Expand="YES", Size="x10", Visible="NO", Active="NO", }
		iup.Insert(iupHbox,nil,btnButton)
	end
	local strColor = iup_gui.Safe							-- Set text message colour appropriately
	if strText:match("WARNING: ") then strColor = iup_gui.Warn end
	if strText:match("ERROR: ")   then strColor = iup_gui.Risk end
	-- Create dialogue and turn off resize, maximize, minimize, and menubox except Close button
	local dialogMode = iup.dialog { Title=iup_gui.Plugin.."  "..strHead, TopMost="YES", -- was BringFront="YES", --! V2.0
								iup.vbox { Alignment="ACENTER", Gap=iup_gui.Gap, Margin=iup_gui.Margin,
									iup.frame { Font=iup_gui.FontHead, FgColor=strColor, Title=strHead,
										iup.vbox { Font=iup_gui.FontBody, FgColor=strColor,
											iup.label { Title=strText, Tip="Operational message",	TipBalloon=iup_gui.Balloon, WordWrap="YES", Expand="YES", },
											iupHbox,
										},
									},
								},
							}
	local tblAttr = iup_gui.DialogueAttributes("Main")	-- Mode GUI is Main GUI width and near bottom of Main GUI
	iup_gui.CustomDialogue( "Mode", tblAttr.Width, tblAttr.CoordX, tblAttr.CoordY + tblAttr.Height - 40 )
	iup_gui.ShowDialogue( "Mode", dialogMode, btnAnswer, "popup" )
	return strAnswer
end -- function GUI_ModeDialogue

-- GUI Main Dialogue --
function GUI_MainDialogue()

	local strButtonTitle = " all Family Historian Custom and Preference Settings "

	-- Create the Main Dialogue Common controls with title/value and tooltip, etc
	local btnBackup		= iup.button	{ Title="  BACKUP"..strButtonTitle }
	local btnRestore	= iup.button	{ Title=" RESTORE"..strButtonTitle }
	local lblBackup		= iup.label	{ Title="This lets you Backup your Family Historian Custom && Preference settings to a backup folder.\nRun it on old PC before moving to new PC, and get help from FHUG on how to use the data."		, WordWrap="YES" }
	local lblRestore	= iup.label	{ Title="This mode Restores the Family Historian Custom && Preference settings from a backup folder.\nAre you fully aware of the risks of a Restore?  Have you a Backup of the current settings data?"	, WordWrap="YES" }
	local lblOptions	= iup.label	{ Title="This mode allows various optional settings to be adjusted.", WordWrap="YES" }
	local btnDefault	= iup.button	{ Title="Restore Defaults" }
	local btnSetFont	= iup.button	{ Title="Set Window Fonts" }
	local btnFolder		= iup.button	{ Title="Choose Backup Folder" }
	local tglRegistry	= iup.toggle	{ Title=" Allow Restore Registry Data" }
	local tglDiagnose	= iup.toggle	{ Title=" Enable Diagnostic Mode" }
	local tglDatedDir	= iup.toggle	{ Title=" Utilise Dated Sub-folders" } -- 19 July 2013
	local labProgram	= iup.label	{ Title="FH Program:"		, Size="60" }
	local lblProgram	= iup.label	{ Title=" " }
	local labBackData	= iup.label	{ Title="Backup Data:"		, Size="60" }
	local lblBackData	= iup.label	{ Title=" " }
	local labProgData	= iup.label	{ Title="Program Data:"	, Size="60" }
	local lblProgData	= iup.label	{ Title=" " }
	local labFilename	= iup.label	{ Title="Data Filename:"	, Size="60" }
	local lblFilename	= iup.label	{ Title=" " }
	local labStatus		= iup.label	{ Title="Status:"			, Size="60" }
	local lblStatus		= iup.label	{ Title=" " }
	local btnGetHelp	= iup.button	{ Title="   Help && Advice" }
	local btnDestroy	= iup.button	{ Title="Close Plugin" }
	local timProgram	= iup.timer	{ time=1000, run="YES" }

	-- Create the Backup box
	local vboxBackup	=	iup.vbox { Gap=iup_gui.Gap, lblBackup,
									iup.hbox { iup.fill{}, btnBackup, iup.fill{}, },
								}

	-- Create the Restore box
	local vboxRestore	=	iup.vbox { Gap=iup_gui.Gap, lblRestore,
									iup.hbox { iup.fill{}, btnRestore, iup.fill{}, },
								}

	-- Create the Options box
	local vboxOptions	=	iup.vbox { Gap=iup_gui.Gap, lblOptions,
									iup.hbox { btnDefault , btnSetFont , btnFolder  , Homogeneous="YES", },
									iup.hbox { tglRegistry, tglDiagnose, tglDatedDir, Homogeneous="YES", },	-- was Gap="99" -- 19 July 2013
								}

	-- Create the Tab controls
	local tabControls	=	iup.tabs { Padding="8x4",
									vboxBackup , tabtitle0=" Backup  ",
									vboxRestore, tabtitle1=" Restore ",
									vboxOptions, tabtitle2=" Options ",
								}

	-- Create the Status frame
	local vboxStatus	=	iup.vbox { Gap=iup_gui.Gap,
									iup.hbox { labProgram , lblProgram , },
									iup.hbox { labBackData, lblBackData, },
									iup.hbox { labProgData, lblProgData, },
									iup.hbox { labFilename, lblFilename, },
									iup.hbox { labStatus  , lblStatus  , },
									iup.hbox { btnGetHelp , btnDestroy , Homogeneous="YES", },
								}
	local frameStatus	= 	iup.frame { Title=" Status ", vboxStatus, }

	-- Create the Main dialogue
	local vboxMain		=	iup.vbox { Margin=iup_gui.Margin,
									tabControls,
									frameStatus,
								}
	local dialogMain	=	iup.dialog { Title=iup_gui.Plugin..iup_gui.Version,
									vboxMain,
								}

	local function setControls()																	-- Set GUI control values
		tglRegistry.Value = StrRegistry
		tglDiagnose.Value = StrDiagnose
		tglDatedDir.Value = StrDatedDir															-- 19 July 2013
		lblProgram .Title = "Family Historian ..."
		lblBackData.Title = StrBackupDir
		lblProgData.Title = StrCalicoPie
		lblFilename.Title = " "
		lblStatus  .Title = " "
	end -- local function setControls

	local strToolTip = " all Program Data, Tutorial, and Registry custom settings, preferences, etc..."
	local strRight = "ARIGHT:ABOTTOM"

	-- Set other GUI control attributes
	local tblControls={ { "Font", "FgColor", "Alignment", "Expand", "Tip", {"TipBalloon";"Balloon"}, setControls },
		[vboxMain  ]  = { "FontHead", "Head", "ACENTER" },
		[frameStatus] = { "FontHead", "Head", false     },
		[tabControls] = { "FontHead", "Head", false,      false, "Choose between Backup, Restore, and Options" },
		[btnBackup ]  = { "FontHead", "Safe", false, "VERTICAL", "Backup" ..strToolTip },
		[btnRestore]  = { "FontHead", "Risk", false, "VERTICAL", "Restore"..strToolTip },
		[lblBackup ]  = { "FontBody", "Safe", "ACENTER",  "YES", "Backup" ..strToolTip },
		[lblRestore]  = { "FontBody", "Risk", "ACENTER",  "YES", "Restore"..strToolTip },
		[lblOptions]  = { "FontBody", "Body", "ACENTER",  "YES", "This mode allows various optional settings to be adjusted." },
		[btnDefault]  = { "FontBody", "Safe", false    ,  "YES", "Restore default Settings and Window positions and sizes" },
		[btnSetFont]  = { "FontBody", "Safe", false    ,  "YES", "Choose user interface window font styles" },
		[btnFolder ]  = { "FontBody", "Safe", false    ,  "YES", "Choose backup data folder path" },
		[tglRegistry] = { "FontBody", "Risk", false    ,  "YES", "Allow RESTORE of Windows Registry Data Keys settings" },
		[tglDiagnose] = { "FontBody", "Safe", false    ,  "YES", "Enable a Diagnostic mode to assist with debugging" },
		[tglDatedDir] = { "FontBody", "Safe", false    ,  "YES", "Utilise date stamped sub-folders for backups" }, -- 19 July 2013
		[labProgram ] = { "FontBody", "Body", strRight ,  false, "Family Historian program version" },
		[lblProgram ] = { "FontBody", "Safe", "ALEFT"  ,  "YES", "Family Historian program version" },
		[labBackData] = { "FontBody", "Body", strRight ,  false, "Backup data folder path" },
		[lblBackData] = { "FontBody", "Safe", "ALEFT"  ,  "YES", "Backup data folder path" },
		[labProgData] = { "FontBody", "Body", strRight ,  false, "Program data folder path" },
		[lblProgData] = { "FontBody", "Safe", "ALEFT"  ,  "YES", "Program data folder path" },
		[labFilename] = { "FontBody", "Body", strRight ,  false, "Current data filename" },
		[lblFilename] = { "FontBody", "Safe", "ALEFT"  ,  "YES", "Current data filename" },
		[labStatus ]  = { "FontBody", "Body", strRight ,  false, "Status and progress messages" },
		[lblStatus ]  = { "FontBody", "Safe", "ALEFT"  ,  "YES", "Status and progress messages" },
		[btnGetHelp]  = { "FontBody", "Safe", false    ,  "YES", "Obtain online Help and Advice from the FHUG Knowledge Base" },
		[btnDestroy]  = { "FontBody", "Risk", false    ,  "YES", "Close the Plugin" },
		}

	iup_gui.AssignAttributes(tblControls)														-- Assign GUI control attributes

	MakeHelpDialogue(btnGetHelp)																	-- Make the Help & Advice dialogue and supply control button

	-- Backup and Restore Data Functions

	function doMakeFolder(strFolder,strHeader)												-- Make a subfolder and report any errors
		if not general.FlgFolderExists(strFolder) then
			local isOK, strError = lfs.mkdir(strFolder)
			if not isOK then
				GUI_ModeDialogue(	"Cannot Make Folder",
										"ERROR: Cannot make "..strHeader..tostring(strError)..".\n"..strFolder.."\nOperation cancelled.\n",
										"OK"	)
				return false
			end
		end
		return true
	end -- function doMakeFolder

	local function doCopyFile(strSourceFile,strTargetFile,strFunction)					-- Conditionally copy a File and set its Date-Time-Stamps
		local tblSourceAttr = lfs.attributes(strSourceFile)									-- Get the Source file byte size and modified date-time
		local intSourceSize = tblSourceAttr.size or 0
		local intSourceTime = tblSourceAttr.modification or 0
		local intTargetSize = 1
		local intTargetTime = 1
		local tblTargetAttr = lfs.attributes(strTargetFile)									-- Get the Target file byte size and modified date-time
		if tblTargetAttr then
			intTargetSize = tblTargetAttr.size or 1
			intTargetTime = tblTargetAttr.modification or 1
		end
		local intDifferSize = math.abs( intSourceSize - intTargetSize )					-- Difference between Source and Target sizes & date-times
		local intDifferTime = math.abs( intSourceTime - intTargetTime )
		local intDifferHour = math.abs( intDifferTime - 3600 ) 
		if intDifferSize == 0 and intDifferHour <= 2											-- Same byte sizes but 1-hour (±2 sec) different date-times
		and intSourceTime < IntBackupMod and intTargetTime < IntBackupMod then			-- and both pre-date the Backup Data modified date-time
			intDifferTime = 0																		-- So ignore Daylight Saving Time (DST/GMT/BST) 1-hour offset
		end
--[==[
		if intSourceSize == intTargetSize
		and intSourceTime > intTargetTime then													-- Check if FH 5.0 Beta source exactly one hour later than FH V5.0 target (now unecessary with DST tolerance above)
			local intDifferTime = intSourceTime - intTargetTime	
			if ( intSourceTime - intTargetTime ) == 3600
			and strSourceFile:matches("\\Family Historian 5.0 Beta\\")
			and strTargetFile:matches("\\Calico Pie\\Family Historian\\") then
--				GUI_ModeDialogue(	"Migrate 1 Hour Different",
--										"ADVICE: Backup Data File modified "..os.date(nil,intSourceTime).." is 1 hour\nlater than Program Data File modified "..os.date(nil,intTargetTime)..".\nTherefore it will not be copied.",
--										"OK"	)
				return
			end
		end	
]==]
		if intDifferSize > 0 or intDifferTime > 2 then										-- Only need to copy file with different size or date-time > ±2 sec
			local strButton = "Copy"
			if intSourceTime < intTargetTime then
				if StrButton then
					strButton = StrButton
				else
					local strSourceData = "Program Data"										-- Adjust dialogue for Backup or Restore function
					local strTargetData = "Backup Data"
					if strFunction == "Restore" then
						strSourceData = "Backup Data"
						strTargetData = "Program Data"
					end
					strButton = GUI_ModeDialogue(	strFunction.." Old File : "..lblFilename.Title:gsub("&&","&"),
															"WARNING: "..strSourceData.." File modified "..os.date(nil,intSourceTime).."\nis older than "..strTargetData.." File modified "..os.date(nil,intTargetTime)..".\nEither copy old "..strSourceData.." File over newer "..strTargetData.." File, or keep the newer "..strTargetData.." File?",
															"Copy Old "..strSourceData.." File", "Keep New "..strTargetData.." File", "Copy All Old Files", "Keep All New Files"	)
					if strButton:match("All %u%l%l Files") then
						StrButton = strButton														-- Remember Copy/Keep All Files option 
					end
				end
			end
			if strButton:match("Copy") then
				local fileSource = assert(io.open(strSourceFile,"rb"))
				local fileTarget, strError = io.open(strTargetFile,"wb")					-- Try mode Write Binary (this sometimes asserts a failure, so try other modes)
				if not fileTarget then
					fileTarget, strError = io.open(strTargetFile,"w+b")						-- Try mode Write Update Binary
					if not fileTarget then
						fileTarget, strError = io.open(strTargetFile,"w+")					-- Try mode Write Update
						if not fileTarget then
							fileTarget, strError = io.open(strTargetFile,"w")				-- Try mode Write
							if not fileTarget then
								error("\n Copy File is unable to open target file in \"wb\" or \"w+b\" or \"w+\" or \"w\" mode. \n\n "..strTargetFile.." \n\n "..tostring(strError).." \n")
							end
						end
					end
				end
				fileTarget:write(fileSource:read("*all"))										-- Copy entire file contents
				assert(fileSource:close())
				assert(fileTarget:close())
				lfs.touch(strTargetFile,tblSourceAttr.access,intSourceTime)				-- Copy access & modified date-times
	--			print("Source later than Target or wants copy. Date: "..os.date(nil,intSourceTime).." Size: "..intSourceSize.." File: "..strSourceFile)	-- Diagnostic
			else
	--			print("Source older than Target so not copied. Date: "..os.date(nil,intSourceTime).." Size: "..intSourceSize.." File: "..strSourceFile)	-- Diagnostic
			end
		else
	--			print("Source same as Target so is not copied. Date: "..os.date(nil,intSourceTime).." Size: "..intSourceSize.." File: "..strSourceFile)	-- Diagnostic
		end
	end -- local function doCopyFile

	local function intCopyFiles(strSourceDir,strTargetDir,strProgName,strFunction,intMinimum)	-- Copy all Files from Source to Target folder for chosen Program
		local intFileCount = 0
		for strSourceFile, tblAttr in general.DirTree(strSourceDir) do
			if tblAttr.mode == "file" then
				intFileCount = intFileCount + 1													-- Count the Source files to be copied
			end
		end
		if intFileCount < intMinimum then
			GUI_ModeDialogue(	"Too Few Data Files",
									"ERROR: "..strFunction.." has NOT been performed because only "..intFileCount.." data files found in:\n"..strSourceDir.."\n",
									"OK"	)
			return 0
		end
		if not doMakeFolder(strTargetDir,strFunction.." "..strProgName.." folder. ") then return -1 end -- Ensure root folder exists
		intFileCount = 0
		lblStatus.Title = " "
		StrButton = nil																				-- Used to remember Copy/Keep All Files option within doCopyFile
		for strSourceFile, tblAttr in general.DirTree(strSourceDir) do
			local strTargetFile = strSourceFile:replace(strSourceDir,strTargetDir)
			lblFilename.Title = strSourceFile:replace(strSourceDir.."\\",""):gsub("&","&&")
			if tblAttr.mode == "directory" then													-- Must create any missing folders in Target folder
				if not doMakeFolder(strTargetFile,strFunction.." "..strProgName.." folder. ") then return -1 end
			else
				if tblAttr.mode == "file" then
					if not strSourceFile:match("~fh.*tmp$") then
						doCopyFile(strSourceFile,strTargetFile,strFunction)					-- Copy each valid Source file to Target file
						intFileCount = intFileCount + 1
						lblStatus.Title = strFunction.." performed for "..intFileCount.." data files..."
					end
				end
			end
		end
		StrButton = nil																				-- Used to remember Delete/Keep All Files option below
		for strTargetFile, tblAttr in general.DirTree(strTargetDir) do
			if tblAttr.mode == "file" then
				local strSourceFile = strTargetFile:replace(strTargetDir,strSourceDir)
				if not general.FlgFileExists(strSourceFile) then							-- If target file has no matching source file, should it be deleted?
					lblFilename.Title = strTargetFile:replace(strTargetDir.."\\",""):gsub("&","&&")
					local strButton = "Delete"
					if StrButton then
						strButton = StrButton
					else
						local strSourceData = "Program Data"									-- Adjust dialogue for Backup or Restore function
						local strTargetData = "Backup Data"
						if strFunction == "Restore" then
							strSourceData = "Backup Data"
							strTargetData = "Program Data"
						end
						local strModified = os.date(nil,tblAttr.modification)
						strButton = GUI_ModeDialogue(	"Delete File : "..lblFilename.Title:gsub("&&","&"),
																"WARNING: The file does not exist in the "..strSourceData.." folder.\nShould the file dated "..strModified.." be deleted from the "..strTargetData.." folder?",
																"Delete This File", "Keep This File", "Delete All Files", "Keep All Files"	)
						if strButton:match("All Files") then
							StrButton = strButton													-- Remember Delete/Keep All Files option
						end
					end
					if strButton:match("Delete") then
						general.DeleteFile(strTargetFile)										-- Delete any Target file that does not exist in Source (exclude root folder)
					else
						intFileCount = intFileCount + 1
						lblStatus.Title = strFunction.." performed for "..intFileCount.." data files..."
					end
				end
			end
		end
		return intFileCount
	end -- local function intCopyFiles

	local function doCheckUninstalledData()													-- Check for Uninstalled Data to Delete
		for strFolder in lfs.dir(StrBackupDir) do
			if strFolder ~= "." and strFolder ~= ".." then									-- Repeat for each folder in Backup Data folder
				local strProgName = strFolder
				local strProgPath = StrBackupDir.."\\"..strProgName
				if lfs.attributes(strProgPath,"mode") == "directory"
				and strProgName:match("^Family Historian") then								-- Folder name starts with Family Historian
					local intFolder = 0
					for strFolder in lfs.dir(StrCalicoPie.."\\Family Historian") do		-- Count standard Family Historian sub-folders
						if strFolder ~= "." and strFolder ~= ".."
						and ( lfs.attributes(strProgPath.."\\"..strFolder,"mode") == "directory"
							or lfs.attributes(strProgPath..StrProg_Data.."\\"..strFolder,"mode") == "directory" ) then
							intFolder = intFolder + 1
						end
					end
					if intFolder < 8 then															-- If too few then cannot be a Backup Data folder
						strProgName = nil
					else
						for intProgram = 1, #TblProgram do
							if TblProgram[intProgram] == strProgName then					-- Signal a match with an installed Program
								strProgName = nil
							end	
						end
					end
					if strProgName then
						lblProgram.Title = strProgName
						local strButton = GUI_ModeDialogue(	"Program Uninstalled",
																	"ADVICE: "..strProgName.." is not installed so should its Backup Data be deleted?",
																	"Yes - Delete", "No - Keep"	)
						if strButton:match("Delete") then
							repeat
								for strFile, tblAttr in general.DirTree(strProgPath) do
									if tblAttr.mode == "file" then
										local isOK, strError = os.remove(strFile)				-- Delete each leaf file
									end
									if tblAttr.mode == "directory" then
										local isOK, strError = lfs.rmdir(strFile)				-- Delete each leaf folder
									end
								end
							until lfs.rmdir(strProgPath)											-- Until the Family Historian folder is empty and can be deleted
						end
					end
				end
			end
		end
	end -- local function doCheckUninstalledData

	local strKeyHKCU = "HKCU\\Software\\Calico Pie"											-- HKEY_CURRENT_USER keys path for REG
	local strKeyHKLM = "HKLM\\SOFTWARE\\Calico Pie"											-- HKEY_LOCAL_MACHINE keys path for REG
	local strRegKeys = "Registry.keys"															-- Backup of Registry Keys filename
	local strVerData = "Version.data"															-- Backup of Version Data filename
	local strListTxt = "ImageList.txt"															-- List of External Images filename
	local strBetaName = "Family Historian 5.0 Beta"

	--[=[
	HKEY_CURRENT_USER\Software\Calico Pie\Family Historian...														-- Current User keys for Diagrams, etc.
	HKEY_USERS\S-1-5-21-4109675573-1409003035-2569323029-1002\Software\Calico Pie\Family Historian...	-- Default User keys for above, not for Backup
	HKEY_LOCAL_MACHINE\SOFTWARE{\WOW6432Node}\Calico Pie\Family Historian... 	(WOW6432Node optional)		-- Local PC keys for Preferences, etc.
	]=]

	local function runBatchFileOK(strScript)													-- Invoke a Batch Script	--! V2.0 variant
		local intCount = 45																			-- Allow up to 45 * 1000ms = 45 seconds for slow NAS drives
		if StrDiagnose == "ON" then
			intCount = intCount * 2
			strScript = strScript:replace("{Diag}","PAUSE")									-- PAUSE in Diagnose mode with double timeout to let user respond
		else
			strScript = strScript:replace("{Diag}","")
		end
		strScript = strScript:replace("{Log}",StrLogFile)									-- Script deletes log file to let Plugin continue
		strScript = strScript:replace("{Reg}",StrRegFile)									-- Registry keys output file
		general.DeleteFile(StrRegFile)
		general.DeleteFile(StrBatFile)
		general.SaveStringToFile(strScript,StrBatFile)
		general.SaveStringToFile(StrLogFile,StrLogFile)
		DoExecute(StrBatFile)
		while general.FlgFileExists(StrLogFile) and intCount >= 0 do						-- Let batch job run while log file and timeout exist
			lblStatus.Title = "Registry batch job timeout "..intCount.." seconds"
			fhSleep(1000,200)
			intCount = intCount - 1
		end
		lblStatus.Title = " "
		general.DeleteFile(StrLogFile)
		if strScript:match("CHOICE") then return true end									-- For ask CHOICE the REG IMPORT batch file must be kept
		general.DeleteFile(StrBatFile)
		if intCount >= 0 or general.FlgFileExists(StrRegFile) then return true end	-- If timeout unexpired or Registry keys output then OK
		return false
	end -- local function runBatchFileOK

	local function doSetProgramVersions()														-- Set FH Program Names & Versions from Calico Pie data -- V2.0 variant
		local strRegQuery = 																		-- Script to run REG QUERY on HKLM /Subkeys for all Family Historian programs
		[=[
		@ECHO OFF
		ECHO.
		ECHO REG QUERY "{HKLM}" /S
		ECHO.
		REG QUERY "{HKLM}" /S > "{Reg}"
		IF ERRORLEVEL 1 (
			ECHO.
			PAUSE
		)
		ECHO.
		{Diag}
		IF EXIST "{Log}" DEL "{Log}"
		EXIT
		]=]
		local strCurrent = fhGetContextInfo("CI_APP_DATA_FOLDER"):replace(StrCalicoPie.."\\","")
		local strProgram = ""
		local strVersion = ""
		lblFilename.Title = StrRegName
		strRegQuery = strRegQuery:replace("{HKLM}",strKeyHKLM)
		if runBatchFileOK(strRegQuery) then														-- Invoke the Batch Script file to REG QUERY HKLM keys
			for strLine in io.lines(StrRegFile) do
				local strProgKey = strLine:match(strKeyHKLM:gsub("HKLM","HKEY_LOCAL_MACHINE").."\\(.*)\\2.0$")
				if strProgKey and strProgKey:match("^Family Historian") then
					strProgram = strProgKey														-- Remember name of each Family Historian program in turn
					strVersion = " Version "
					if strProgram == strCurrent then
						table.insert(TblProgram,strProgram)										-- Add current running Family Historian program to end of table
					else
						table.insert(TblProgram,1,strProgram)									-- Add other installed Family Historian programs to top of table
					end
				end
				local strDigit = strLine:match("%s+Ver%d%s+REG_DWORD%s+0x(%d)")
				if strDigit then
					strVersion = strVersion..strDigit.."."										-- Compose the Version number digits of each program
				end
				local strBackups = strLine:match("%s+Backup Directory%s+REG_SZ%s+(.*)")
				if strBackups then
					strVersion = strVersion:gsub("%.$","")										-- Save the Version number of program minus trailing dot
					if strProgram == strCurrent then
						table.insert(TblVersion,strVersion)
						StrBackupKey = strBackups													-- Save the Backups folder of current program as default Backup Data folder
					else
						table.insert(TblVersion,1,strVersion)
					end
				end
			end
			general.DeleteFile(StrRegFile)
			lblFilename.Title = " "
		else
			local intSize = lfs.attributes(StrRegFile,"size") or "No"
			GUI_ModeDialogue(	"Registry Query Error",
									"ERROR: Registry Key data not saved by REG QUERY "..strKeyHKLM.."\n "..intSize.." bytes written to "..StrRegFile.."\n Plugin cannot proceed.  Plugin will be closed.\n\n",
									"OK"	)
			return false
		end
		return true
	end -- local function doSetProgramVersions

	local function doExportRegistry(strTargetDir,strProgName)								-- Invoke a Batch Script to Export the Registry Keys and find external image files -- V2.0 variant
		--[=[
			The FIND commands search for ":\" and "\\" to locate file paths like "C:\..." and "\\NAME\..." in Standard & Custom Diagram Type .fhd/fhdx files	--! "\\NAME\" supported 1 Feb 2014
			Windows 7 & Vista support REG QUERY "KeyPath" /V "Value" /S but on Windows XP /V and /S are mutually exclusive
			Thus the following script works on Windows 7 & Vista but not on Windows XP - the resulting side effect is that the output file is a bit bigger
			IF EXIST "{Targ}\Image.Icons" DEL "{Targ}\Image.Icons"
			REG QUERY "{HKCU}" /V "Icon" /S > "{Targ}\Image.Icons"
			IF EXIST "{Targ}\Image.Picts" DEL "{Targ}\Image.Picts"
			REG QUERY "{HKCU}" /V "Bkg Pic Path" /S > "{Targ}\Image.Picts"
		]=]
		local strRegExport =			 															-- Script to run FIND & REG QUERY / EXPORT on HKCU & HKLM keys for one Family Historian program
		[=[
		@ECHO OFF
		IF EXIST "{Targ}\Image.StandardDrive" DEL "{Targ}\Image.StandardDrive"
		IF EXIST "{Targ}\Image.StandardName" DEL "{Targ}\Image.StandardName"
		IF EXIST "{Targ}{Prog}\Diagrams\Standard\*.fhd*" (
		 FIND ":\" "{Targ}{Prog}\Diagrams\Standard\*.fhd*" > "{Targ}\Image.StandardDrive"
		 FIND "\\" "{Targ}{Prog}\Diagrams\Standard\*.fhd*" > "{Targ}\Image.StandardName"
		)
		IF EXIST "{Targ}\Image.CustomDrive" DEL "{Targ}\Image.CustomDrive"
		IF EXIST "{Targ}\Image.CustomName" DEL "{Targ}\Image.CustomName"
		IF EXIST "{Targ}{Prog}\Diagrams\Custom\*.fhd*" (
		 FIND ":\" "{Targ}{Prog}\Diagrams\Custom\*.fhd*" > "{Targ}\Image.CustomDrive"
		 FIND "\\" "{Targ}{Prog}\Diagrams\Custom\*.fhd*" > "{Targ}\Image.CustomName"
		)
		ECHO.
		ECHO REG QUERY "{HKCU}" /S
		ECHO.
		IF EXIST "{Targ}\Image.Query" DEL "{Targ}\Image.Query"
		REG QUERY "{HKCU}" /S > "{Targ}\Image.Query"
		ECHO.
		IF EXIST "{Reg}" DEL "{Reg}"
		IF EXIST "{Reg}-1" DEL "{Reg}-1"
		IF EXIST "{Reg}-2" DEL "{Reg}-2"
		ECHO.
		ECHO REG EXPORT "{HKCU}" "{Reg}-1"
		ECHO.
		REG EXPORT "{HKCU}" "{Reg}-1"
		IF ERRORLEVEL 1 (
			ECHO.
			PAUSE
		)
		ECHO.
		ECHO REG EXPORT "{HKLM}" "{Reg}-2"
		ECHO.
		REG EXPORT "{HKLM}" "{Reg}-2"
		IF ERRORLEVEL 1 (
			ECHO.
			PAUSE
		)
		TYPE "{Reg}-?" > "{Reg}"
		DEL "{Reg}-?"
		ECHO.
		{Diag}
		IF EXIST "{Log}" DEL "{Log}"
		EXIT
		]=]
		local flgKeyHKLM = false
		local tblRegFile = {}
		local strHKCU = strKeyHKCU.."\\"..strProgName
		local strHKLM = strKeyHKLM.."\\"..strProgName.."\\2.0\\Preferences"
		strRegExport = strRegExport:replace("{HKCU}",strHKCU)								-- Invoke the Batch Script file to FIND files & REG QUERY / EXPORT HKCU & HKLM keys 
		strRegExport = strRegExport:replace("{HKLM}",strHKLM)
		strRegExport = strRegExport:replace("{Targ}",strTargetDir)
		strRegExport = strRegExport:replace("{Prog}",StrProg_Data)
		lblFilename.Title = StrRegName
		if not runBatchFileOK(strRegExport) then
			GUI_ModeDialogue(	"Registry Export Error",
									"ERROR: Registry Key data not saved by REG EXPORT for\n"..strHKCU.."\n"..strHKLM.."\n"..StrRegFile.."\n",
									"OK"	)
		end
		for strLine in io.lines(StrRegFile) do
			if strLine:match("HKEY_LOCAL_MACHINE") then flgKeyHKLM = true end
			if not ( flgKeyHKLM and ( strLine:match("=\"%u:\\\\") or strLine:match("=\"\\\\\\\\.-\\\\") ) ) then
				table.insert(tblRegFile,strLine)												-- Copy Registry Keys excluding HKLM file references such as ="C:\\ or ="\\\\NAME\\
			end
		end
		general.DeleteFile(StrRegFile)
		general.SaveStringToFile(table.concat(tblRegFile,"\n"),strTargetDir.."\\"..strRegKeys)
	end -- local function doExportRegistry

	local function doImportRegistry(strSourceDir,strProgName)								-- Invoke a Batch Script to Import the Registry Keys -- V2.0 variant
		local strAskChoice = 																		-- Script to ask before continuing with the REG IMPORT script below
		[=[
		@ECHO OFF
		ECHO.
		ECHO REG IMPORT "{Keys}"
		ECHO.
		ECHO ~ Ensure the Family Historian program is closed before continuing ~ 
		ECHO.
		IF EXIST "{Log}" DEL "{Log}"
	:REPEAT
		ECHO.
		SET CHOICE=
		SET /P CHOICE=~ Do you want to continue and import Registry Data Keys [Y/N] ? 
		IF NOT "%CHOICE%" EQU "" SET CHOICE=%CHOICE:~0,1%
		IF /I "%CHOICE%" EQU "N" EXIT
		IF /I "%CHOICE%" NEQ "Y" GOTO REPEAT
		ECHO.
		]=]
		local strRegImport = 																		-- Script to run REG IMPORT on one Family Historian backup Registry.keys file
		[=[
		@ECHO OFF
		ECHO.
		ECHO REG IMPORT "{Keys}"
		ECHO.
		REG IMPORT "{Keys}"
		IF ERRORLEVEL 1 (
			ECHO.
			PAUSE
		)
		ECHO.
		{Diag}
		IF EXIST "{Log}" DEL "{Log}"
		EXIT
		]=]
		local strRegFile = strSourceDir.."\\"..strRegKeys
		lblFilename.Title = strRegKeys
		if general.FlgFileExists(strRegFile) then

			local function doBatchJob(strRegImport)											-- Invoke the Batch Script file to REG IMPORT registry keys
				strRegImport = strRegImport:replace("{Keys}",strRegFile)
				runBatchFileOK(strRegImport)
				lblStatus.Title = "Restore initialised for 1 Registry file"
				fhSleep(1000,200)
			end -- local function doBatchJob

			if strProgName == TblProgram[#TblProgram] then									-- Handle currently running program differently
				local strButton = GUI_ModeDialogue(	"Close Program",
															"WARNING: Ensure '"..strProgName.."' is closed before restoring its Registry Keys data.\nOtherwise the restored Registry Keys will be overwritten when the program is closed.\nSo after clicking 'OK - Quit Plugin' the Plugin will close to let you close the program.\nThe 'REG IMPORT' dialogue will remain open after '"..strProgName.."' is closed.",
															"OK - Quit Plugin", "No - Close Later"	)
				doBatchJob(strAskChoice..strRegImport)											-- Invoke the Batch Script file to ask to REG IMPORT registry keys
--[=[
				strRegImport = strAskChoice..strRegImport
				strRegImport = strRegImport:replace("{Keys}",strRegFile)
				runBatchFileOK(strRegImport)														-- Invoke the Batch Script file to ask to REG IMPORT registry keys
				lblStatus.Title = "Restore initialised for 1 Registry file"
				fhSleep(1000,200)
--]=]
				if strButton:match("OK") then
					return -1
				end
			else
				local strButton = GUI_ModeDialogue(	"Close Program",
															"WARNING: Ensure '"..strProgName.."' is closed before restoring its Registry Keys data.\nOtherwise the restored Registry Keys will be overwritten when the program is closed.\nThis is the last opportunity to quit restoring the Registry Keys data.",
															"OK - Program Closed", "Quit Restore Registry"	)
				if strButton:match("OK") then
					doBatchJob(strRegImport)														-- Invoke the Batch Script file to REG IMPORT registry keys
--[=[
					strRegImport = strRegImport:replace("{Keys}",strRegFile)
					runBatchFileOK(strRegImport)													-- Invoke the Batch Script file to REG IMPORT registry keys
					lblStatus.Title = "Restore completed for 1 Registry file"
					fhSleep(1000,200)
--]=]
				end
			end
		else
			GUI_ModeDialogue(	"Backup File Missing",
									"ERROR: Cannot restore from missing backup registry file:\n"..strRegFile.."\n",
									"OK"	)
		end
		return 0
	end -- local function doImportRegistry

	local function intBackupImageFiles(strProgramDir,strTargetDir)						-- Backup image files not located in Program Data folders
		local strFileList = ""
		local strFileDiag = nil
		local strFilePath = nil
		local tblFilePath = {}
		local intFilePath = 0
		local intFileCount = 0
		local strMatch = nil																		-- Search the Image.* files created by doExportRegistry() above
		for i, strFileType in ipairs( { "StandardDrive","StandardName","CustomDrive","CustomName","Query" } ) do	--! 1 Feb 2014 V2.0
			local strImageFile = strTargetDir.."\\Image."..strFileType
			if general.FlgFileExists(strImageFile) then										-- Cater for both C:\ and \\NAME\ style leading path names
				for strLine in io.lines(strImageFile) do
					strMatch = strLine:match("^---------- %u:\\.*\\(STANDARD\\.*)$")	-- Standard Diagram Type (.fhd/.fhdx) definition file
							or strLine:match("^---------- \\\\.-\\.*\\(STANDARD\\.*)$")
					if strMatch then strFileDiag = strMatch end
					strMatch = strLine:match("^---------- %u:\\.*\\(CUSTOM\\.*)$")		-- Custom Diagram Type (.fhd/.fhdx) definition file
							or strLine:match("^---------- \\\\.-\\.*\\(CUSTOM\\.*)$")
					if strMatch then strFileDiag = strMatch end
					strMatch = strLine:match("^Icon=(%u:\\.*)$")								-- Diagram Type (.fhd) Box Icon external image file
							or strLine:match("^Icon=(\\\\.-\\.*)$")
					if strMatch then strFilePath = strMatch end
					strMatch = strLine:match("^(%u:\\.-)[^%a]*$")							-- Diagram Type (.fhdx) Picture or Box Icon external image file
							or strLine:match("^(\\\\.-\\.-)[^%a]*$")
					if strMatch then strFilePath = strMatch end
					strMatch = strLine:match("%s*Bkg Pic Path%s*REG_SZ%s*(%u:\\.*)$")	-- Registry Diagram Picture external image file
							or strLine:match("%s*Bkg Pic Path%s*REG_SZ%s*(\\\\.-\\.*)$")
					if strMatch then strFileDiag = "REGISTRY DIAGRAM PICTURE" strFilePath = strMatch end
					strMatch = strLine:match("%s*Icon%s*REG_SZ%s*(%u:\\.*)$")				-- Registry Diagram Box Icon external image file
							or strLine:match("%s*Icon%s*REG_SZ%s*(\\\\.-\\.*)$")
					if strMatch then strFileDiag = "REGISTRY DIAGRAM BOX ICON" strFilePath = strMatch end
					if strFilePath and
					not strFilePath:match(strProgramDir..".-\\.-\\") then					-- Image file path not in any Program Data subfolder
						local intFileIndex = tblFilePath[strFilePath]
						if not intFileIndex then
							intFilePath = intFilePath + 1
							intFileIndex = intFilePath
							tblFilePath[strFilePath] = intFilePath
							if general.FlgFileExists(strFilePath) then
								intFileCount = intFileCount + 1
								local strFileName = "\\"..intFileIndex.."~"..( strFilePath:match("%u:\\.-([^\\]-[^%.]+)$") or strFilePath:match("\\\\.-\\.-([^\\]-[^%.]+)$") )
								doCopyFile(strFilePath,strTargetDir..strFileName,"Backup")
								tblFilePath[strFileName] = intFilePath
							end
						end
						local strFileText = "  references missing file  "
						if general.FlgFileExists(strFilePath) then
							strFileText = "  references file "..intFileIndex.."  ~  "
						end
						strFileList = strFileList..strFileDiag..strFileText..strFilePath.."\n"
						strFilePath = nil
					end
				end
				general.DeleteFile(strImageFile)
			end
		end
		for strEntry in lfs.dir(strTargetDir) do												-- Search backup folder for image files
			if strEntry ~= "." and strEntry ~= ".." then
				local strFileName = "\\"..strEntry
				local tblAttr = lfs.attributes(strTargetDir..strFileName)
				if tblAttr.mode == "file"
				and strFileName:match("^\\%d+~")
				and not tblFilePath[strFileName] then
					general.DeleteFile(strTargetDir..strFileName)							-- Delete redundant old image file backup
				end
			end
		end
		if strFileList ~= "" then
			local strImageList = strTargetDir.."\\"..strListTxt
			general.SaveStringToFile(strFileList,strImageList)
			lblFilename.Title = strListTxt:gsub("&","&&")
			local strMoveAdvice = ""
			if intFileCount > 0 then strMoveAdvice = "\nPreferably any Box Icon external images should be moved to the Program Data FH Program Icons folder." end
			local strMissAdvice = ""
			local intMissCount = intFilePath - intFileCount
			if intMissCount > 0 then strMissAdvice = "\nTake note that "..intMissCount.." of the referenced external image files cannot be found." end
			local strButton = GUI_ModeDialogue(	"External Image File",
														"ADVICE: Diagram Type Picture / Box Icon external image file references are listed in the "..strListTxt.." file."..strMoveAdvice..strMissAdvice,
														"View Image List", "OK - Continue"	)
			if strButton:match("View") then DoExecute( strImageList, " " ) end
		end
		return intFileCount
	end -- local function intBackupImageFiles

	local function intRestoreImageFiles(strSourceDir)										-- Restore image files not located in Program Data folders
		local intFileCount = 0
		local intFileIndex = 0
		local intFileError = 0
		local strTargetDir = ""
		local strImageList = strSourceDir.."\\"..strListTxt
		if general.FlgFileExists(strImageList) then
			lblFilename.Title = strListTxt:gsub("&","&&")
			for strLine in io.lines(strImageList) do											-- Look through the FileList.txt file to find image file paths with either C:\ or \\NAME\ style
				local intFilePath, strFilePath = strLine:match(".*  references file (%d*)  ~  (.*)$")
				if strFilePath then
					local strFileName = strSourceDir.."\\"..intFilePath.."~"..( strFilePath:match("%u:\\.-([^\\]-[^%.]+)$") or strFilePath:match("\\\\.-\\.-([^\\]-[^%.]+)$") )
					intFilePath = tonumber(intFilePath)
					if general.FlgFileExists(strFileName) and intFilePath > intFileIndex then
						intFileCount = intFileCount + 1
						intFileIndex = intFilePath
						strTargetDir = general.SplitFilename(strFilePath)
						if general.FlgFolderExists(strTargetDir) then
							doCopyFile(strFileName,strFilePath,"Restore")
						else
							if doMakeFolder(strTargetDir,"Restore Image folder path. ") then	-- Ensure the Target folder exists --! V2.0 variant
								doCopyFile(strFileName,strFilePath,"Restore")
							else
								intFileError = intFileError + 1
							end
						end
					end
				end
			end
			if intFileCount > 0 then
				local strButton = GUI_ModeDialogue(	"External Image File",
															"ADVICE: Diagram Type Picture / Box Icon external image file references are listed in the "..strListTxt.." file.\nPreferably any Box Icon external images should be moved to the Program Data FH Program Icons folder.",
															"View Image List", "OK - Continue"	)
				if strButton:match("View") then DoExecute( strImageList, " " ) end
			end
		end
		return intFileCount - intFileError
	end -- local function intRestoreImageFiles

	local function doRenameFolder(strSource,strTarget)										-- Rename folder from Source to Target if Source exists
		if general.FlgFolderExists(strSource) then
			general.DeleteFile(strTarget)
			local isOK, strErrorText = os.rename(strSource,strTarget)
			if not isOK then
				GUI_ModeDialogue(	"Rename Failed",
										"ERROR: Rename of folder failed for:\n"..strSource.."\n"..strTarget.."\n",
										"OK"	)
			end
		end
	end -- local function doRenameFolder

--[==[
	local function strRegeditExport(strFile,strKeys)										-- Run regedit to Export text Registry Keys and return as string
		general.DeleteFile(strFile)
		DoExecute( "regedit.exe", " /E:A \""..strFile.."\" \""..strKeys.."\" " )		-- /E:A means Export in ASCII text
		local intOldSize = -1
		local intNewSize = -1
		local intCounter = 60
		repeat
			if intNewSize > 1000 then intOldSize = intNewSize end
			fhSleep(500,200)																		-- Allow regedit to run and wait until file stops getting bigger
			intNewSize = lfs.attributes(strFile,"size") or 0
			intCounter = intCounter - 1
		until intOldSize == intNewSize or intCounter < 0
		if intCounter < 0 then
			GUI_ModeDialogue(	"Registry Export Error",
									"ERROR: Registry Key data not saved by regedit export:\n"..strFile.."\n"..strKeys,
									"OK"	)
		end
		return general.StrLoadFromFile(strFile)
	end -- local function strRegeditExport

	local function doRenameFile(strSource,strTarget)										-- Rename file from Source to Target if Source exists
		if general.FlgFileExists(strSource) then
			general.DeleteFile(strTarget)
			local isOK, strErrorText = os.rename(strSource,strTarget)
			if not isOK then
				GUI_ModeDialogue(	"Rename Failed",
										"ERROR: Rename of file failed for:\n"..strSource.."\n"..strTarget.."\n",
										"OK"	)
			end
		end
	end -- local function doRenameFile

	local function doMigrateToVersion5(strSourceDir,strVersion)							-- Migrate FH 5.0 Beta Backup Data to installed FH V5.0
		local strRegFile = strSourceDir.."\\"..strRegKeys
		local strVerFile = strSourceDir.."\\"..strVerData
		doRenameFile(strRegFile,strRegFile.."_beta")											-- Preserve current Registry.keys & Version.data Beta files
		doRenameFile(strVerFile,strVerFile.."_beta")
		local strKeyHKCU = strKeyHKCU:gsub("HKCU","HKEY_CURRENT_USER")					-- Obtain the FH 5.0 Beta regedit Registry keys for HKCU & HKLM
		local strKeyHKLM = strKeyHKLM:gsub("HKLM","HKEY_LOCAL_MACHINE")
		local tblRegKeys = {}
		table.insert(tblRegKeys,strRegeditExport(strRegFile,strKeyHKCU.."\\"..strBetaName))
		table.insert(tblRegKeys,strRegeditExport(strRegFile,strKeyHKLM.."\\"..strBetaName.."\\2.0\\Preferences"))
		local strRegKeys = table.concat(tblRegKeys):gsub("\\"..strBetaName,"\\Family Historian")
		general.SaveStringToFile(strRegKeys,strRegFile)										-- Create new Registry.keys file
		general.SaveStringToFile(strVersion,strVerFile)										-- Create new Version.data file
	end -- local function doMigrateToVersion5
]==]

	local strTodaysDate = os.date("%Y-%m-%d") -- Use %H%M for Hours & Mins				-- 19 July 2013

	local function strRemoveDatedDir(strBackupDir)											-- 19 July 2013
		strBackupDir = strBackupDir:gsub("\\FH Settings 2%d%d%d%-%d%d%-%d%d$","")
		return strBackupDir
	end -- local function strRemoveDatedDir

	local function strAppendDatedDir(strBackupDir)											-- 19 July 2013
		strBackupDir = strRemoveDatedDir(strBackupDir).."\\FH Settings "..strTodaysDate
		return strBackupDir
	end -- local function strAppendDatedDir

	local function setBackupFolderOK(strFunction,strBackupDir)							-- Choose Backup/Restore Folder Path

		local function makeSubFolder()															-- 19 July 2013
			if strFunction == "Backup" and StrDatedDir == "ON" then
				strBackupDir = strAppendDatedDir(strBackupDir)								-- Must create subfolder --! V2.0 variant
				if not doMakeFolder(strBackupDir,"Backup Date-Time subfolder. ") then return false end
			end
			StrBackupDir = strBackupDir
			SaveSettings()																			-- Save sticky data settings
			return true
		end -- local function makeSubFolder

		if strFunction == "Backup" then strBackupDir = strRemoveDatedDir(strBackupDir) end -- 19 July 2013
		if general.FlgFolderWrite(strBackupDir) then return makeSubFolder() end		-- If supplied folder writeable then dialogue not required
		if general.FlgFolderExists(StrBackupDir) then
			strBackupDir = StrBackupDir															-- Set initial directory to existing Plugin Backup Folder 
		else
			strBackupDir = StrBackupKey															-- Set initial directory to Program Preferences Backups Folder
		end
		if not general.FlgFolderWrite(strBackupDir) then
			strBackupDir = StrPublicPath															-- Set initial directory to Project Public folder
		end
		local filedlg = iup.filedlg{dialogtype="DIR", Title="The current Backup Data folder path is \n"..strBackupDir, directory=strBackupDir}
		filedlg:popup(iup.CENTER,iup.CENTER)
		if filedlg.status == "0" then
			strBackupDir = filedlg.value
			if general.FlgFolderWrite(strBackupDir) then										-- If chosen folder is writeable then all OK
				return makeSubFolder()																-- 19 July 2013
			else
				lblBackData.Title = strBackupDir:gsub("&","&&")
				GUI_ModeDialogue(	strFunction.." Cancelled",
										"ERROR: "..strFunction.." Operation has failed because Backup Data folder does not have write access.",
										"OK"	)
				lblBackData.Title = StrBackupDir:gsub("&","&&")
				return false
			end
		else
			GUI_ModeDialogue(	strFunction.." Cancelled",
									"ADVICE: "..strFunction.." Operation has been cancelled via the 'Browse For Folder' dialogue.",
									"OK"	)
		end
		return false		
	end -- local function setBackupFolderOK

	local function doCheckProgramDataFolder(strBackupDir)									-- Ensure backup Program Data subfolder exists
		local strTarget = strBackupDir..StrProg_Data
		if not general.FlgFolderExists(strTarget) then
			if not doMakeFolder(strTarget,"Program Data folder. ") then return false end
			for strFolder in lfs.dir(strBackupDir) do
				local strSource = strBackupDir.."\\"..strFolder								-- Move legacy backup folders into Program Data subfolder
				if strFolder ~= "." and strFolder ~= ".."
				and "\\"..strFolder ~= StrProg_Data
				and "\\"..strFolder ~= StrUser_Data
				and "\\"..strFolder ~= StrTutorials
				and lfs.attributes(strSource,"mode") == "directory" then
					doRenameFolder(strSource,strTarget.."\\"..strFolder)
				end
			end
		end
		return true
	end -- local function doCheckProgramDataFolder

	local function showFolderPaths(strBackData,strProgData)								-- Update status lblBackData.Title and lblProgData.Title		--! V2.0
		lblBackData.Title = strBackData:gsub("&","&&")
		lblProgData.Title = strProgData:gsub("&","&&")
	end -- local function showFolderPaths

	local function setMainControlsActive(strMode)											-- Enable/Disable controls during main tab actions		--! V2.0
		tabControls.Active = strMode
		btnDestroy.Active = strMode
	end -- local function setMainControlsActive

	-- GUI Backup Tab Functions --

	function btnBackup:action()																	-- Action for Backup Customisations button
		setMainControlsActive("NO")
		if setBackupFolderOK("Backup",StrBackupDir) then									-- Ensure the Backup Data folder is OK
			local intProgTotal = 0
			local intFileTotal = 0
			for intProgram = 1, #TblProgram do													-- Repeat for each installed Family Historian program Version
				showFolderPaths(StrBackupDir,StrCalicoPie)									--! V2.0
				local strProgName = TblProgram[intProgram]
				local strProgVers = TblVersion[intProgram]
				lblProgram.Title = strProgName..strProgVers
				lblFilename.Title = " "
				lblStatus.Title	= " "
				local strTargetDir = StrBackupDir.."\\"..strProgName						-- Backup target is Backup Data folder with same program name
				local strSourceDir = StrCalicoPie.."\\"..strProgName						-- Backup source is Calico Pie program name data folder
				local strApplicPie = StrApplicPie.."\\"..strProgName						-- Backup source is Calico Pie plugin data files folder	--! 11 Feb 2014
				local strPublicPie = StrPublicPie.."\\"..strProgName						-- Backup source is Calico Pie tutorial files folder
				local strButton = "Yes"
				IntBackupMod = 0
				if general.FlgFolderExists(strTargetDir) then
					if not doCheckProgramDataFolder(strTargetDir) then break end			-- Ensure Program Data subfolder exists
					local strModified = ""
					local strVerFile = strTargetDir.."\\"..strVerData
					if general.FlgFileExists(strVerFile) then
						IntBackupMod = lfs.attributes(strVerFile,"modification")			-- Backup Data modified date-time-stamp
						strModified = os.date(nil,IntBackupMod)
					end
					strButton = GUI_ModeDialogue(	"Backup Data Exists "..strModified,
															"WARNING: Backup folder already has "..strProgName.." backup data saved.\nIs it acceptable to update this old Backup Data with new Backup Data?",
															"Yes - Backup", "No - Skip"	)
				else
					strButton = GUI_ModeDialogue(	"Backup Data Request",
															"ADVICE: Is it acceptable to create new Backup Data for "..strProgName.."?",
															"Yes - Backup", "No - Skip"	)
				end
				if strButton:match("Yes") then													-- Backup all Program Data files from Calico Pie folder with Application Plugin Data and Tutorial Files
					showFolderPaths(strTargetDir..StrProg_Data,strSourceDir)				--! V2.0
					if not doMakeFolder(strTargetDir,"Backup "..strProgName.." folder. ") then break end	-- Must create backup folder -- V2.0 variant
					local intFileCount = intCopyFiles(strSourceDir,strTargetDir..StrProg_Data,strProgName,"Backup",150)
					if intFileCount < 0 then break end
					local intUser_Data = 0
					if general.FlgFolderExists(strApplicPie..StrUser_Data) then			--! V2.0
						showFolderPaths(strTargetDir..StrUser_Data,strApplicPie..StrUser_Data)
						intUser_Data = intCopyFiles(strApplicPie..StrUser_Data,strTargetDir..StrUser_Data,strProgName,"Backup",0)
					end
					if intUser_Data < 0 then break end
					showFolderPaths(strTargetDir..StrTutorials,strPublicPie..StrTutorials)		--! V2.0
					local intTutorials = intCopyFiles(strPublicPie..StrTutorials,strTargetDir..StrTutorials,strProgName,"Backup",12)
					if intTutorials < 0 then break end
					showFolderPaths(strTargetDir,strSourceDir)								--! V2.0
					intFileCount = intFileCount + intUser_Data + intTutorials
					if intFileCount > 0 then
						intProgTotal = intProgTotal + 1
						general.SaveStringToFile(strProgVers,strTargetDir.."\\"..strVerData)	-- Save the Program Version number
						doExportRegistry(strTargetDir,strProgName)							-- Export all Registry Keys for Program
						intFileCount = intFileCount + intBackupImageFiles(strSourceDir,strTargetDir)
						intFileTotal = intFileTotal + intFileCount
						lblFilename.Title = " "
						lblStatus.Title = "Backup completed for "..intFileCount.." data files and 1 registry file"
						fhSleep(1000,200)
					end
				end
			end -- per installed Program loop
			showFolderPaths(StrBackupDir,StrCalicoPie)										--! V2.0
			doCheckUninstalledData()																-- Check if any Backup Data folder exists for an uninstalled program
			lblProgram.Title = "Family Historian ..."
			local strPrograms = " programs"
			if intProgTotal == 1 then strPrograms = " program" end
			lblStatus.Title = "Backup completed for "..intFileTotal.." files for "..intProgTotal..strPrograms
		end
		setMainControlsActive("YES")
	end -- function btnBackup:action

	-- GUI Restore Tab Functions --

	function btnRestore:action()																	-- Action for Restore Customisations button
		setMainControlsActive("NO")
		if setBackupFolderOK("Restore",StrBackupDir) then									-- Ensure the Backup Data folder is OK
			local intProgTotal	= 0
			local intFileTotal	= 0
			local strBetaVers	= ""
			for intProgram = 1, #TblProgram do
				showFolderPaths(StrBackupDir,StrCalicoPie)									-- V2.0
				local strProgName = TblProgram[intProgram]									-- Repeat for each installed Family Historian program Version
				local strProgVers = TblVersion[intProgram]
				lblProgram.Title = strProgName..strProgVers
				if strProgName == strBetaName then strBetaVers = strProgVers end
				local strSourceDir = StrBackupDir.."\\"..strProgName						-- Restore source is Backup Data program name folder
				local strTargetDir = StrCalicoPie.."\\"..strProgName						-- Restore target is Calico Pie program name data folder
				local strApplicPie = StrApplicPie.."\\"..strProgName						-- Restore target is Calico Pie plugin data files folder	--! 11 Feb 2014
				local strPublicPie = StrPublicPie.."\\"..strProgName						-- Restore target is Calico Pie tutorial files folder
				local strProgram	= "Program Data Files"
				local strTutorial	= "Tutorial Files"
				local strRegistry	= "Registry Data Keys"
				local intFileCount	= 0
				if general.FlgFolderExists(strSourceDir) then
					if not doCheckProgramDataFolder(strSourceDir) then break end			-- Ensure Program Data subfolder exists
					repeat
						showFolderPaths(strSourceDir,strTargetDir)							-- V2.0
						lblFilename.Title = " "
						lblStatus.Title	= " "
						local strButton = ""
						local strRegFile = strSourceDir.."\\"..strRegKeys
						local strVerFile = strSourceDir.."\\"..strVerData
						if not general.FlgFileExists(strVerFile) then
							GUI_ModeDialogue(	"Version Data Missing",
													"ERROR: Cannot find the "..strProgName.." program Version of the Backup Data.\n"..strVerFile.." is missing.\n",
													"OK"	)
							break
						end
						local strBackVers = general.StrLoadFromFile(strVerFile)
						if strBackVers then
							if strBackVers ~= strProgVers then
								if strBackVers:match(" Version (%d)%.") == strProgVers:match(" Version (%d)%.") then
									GUI_ModeDialogue(	"Minor Version Mismatch",
															"ERROR: "..strProgName.." backup"..strBackVers.." does not match"..strProgVers.." installed.\nInstall a free upgrade to bring the older program version upto date and make the backups compatible.",
															"OK"	)
								else
									GUI_ModeDialogue(	"Major Version Mismatch",
															"ERROR: "..strProgName.." backup"..strBackVers.." does not match"..strProgVers.." installed.\nThe program settings for different Family Historian program Versions are NOT compatible.",
															"OK"	)
								end
								break
							end
							local strOption = ""
--[==[
							if strProgName == "Family Historian"								-- Check for Migrate Beta option
							and strProgName == TblProgram[#TblProgram]
							and strProgVers:match(" Version (%d%.%d)%.") == "5.0"
							and strBetaVers:match(" Version (.*)") == "5.0.0.7" then		-- FH V5.0 is current and FH Beta V5.0.0.7 is installed
								strOption = "Migrate Beta to V"..strProgVers:match(" Version (%d%.%d)%.")
							end
]==]
							IntBackupMod = lfs.attributes(strVerFile,"modification")		-- Backup Data modified date-time-stamp
							local strModified = os.date(nil,IntBackupMod)
							strButton = GUI_ModeDialogue(	"Restore Data "..strModified,
																	"WARNING: Use 'Skip Operation' unless certain of the consequences of using Restore.\nHas a Backup been performed (by another PC or User or Project) for the current Program Settings?\nDo you want to Restore the Program Data Files or Tutorial Files or Registry Data Keys?",
																	strOption, strProgram, strTutorial, strRegistry, "Skip Operation"	)
--[==[
							if strButton:match("Migrate") then
								lblProgram.Title = strBetaName..strBetaVers.. " to "..strProgName..strProgVers  
								GUI_ModeDialogue(	"Migrate Beta Backup",
														"ADVICE: This will CONVERT "..strBetaName.." settings to Family Historian"..strProgVers.." settings.\nIf running in an Administrator account there may be two 'User Account Control' popups for 'Registry Editor'.\nThe usual 'Program Data Files' button and 'Registry Data Keys' button will MIGRATE the data settings.",
														"OK"	)
								strSourceDir = StrBackupDir.."\\"..strBetaName				-- Restore source is Backup FH 5.0 Beta data folder
								doMigrateToVersion5(strSourceDir,strProgVers)
								strBetaVers = ""													-- Inhibit the Migrate option
							end
]==]
							if strButton == strProgram then										-- Restore all Program Data files to Calico Pie folder and also Application Plugin Data
								strProgram = ""
								local intImages = intRestoreImageFiles(strSourceDir)
								showFolderPaths(strSourceDir..StrProg_Data,strTargetDir)	--! V2.0
								local intFiles = intCopyFiles(strSourceDir..StrProg_Data,strTargetDir,strProgName,"Restore",150)
								if intFiles < 0 then break end
								local intApps = 0
								if  general.FlgFolderExists(strSourceDir..StrUser_Data)	--! V2.0
								and general.FlgFolderExists(strApplicPie..StrUser_Data) then
									showFolderPaths(strSourceDir..StrUser_Data,strApplicPie..StrUser_Data)
									intApps = intCopyFiles(strSourceDir..StrUser_Data,strApplicPie..StrUser_Data,strProgName,"Restore",0)
								end
								if intApps < 0 then break end
								showFolderPaths(strSourceDir,strTargetDir)					--! V2.0
								intFiles = intFiles + intApps + intImages
								if intFiles > 0 then
									intFileCount = intFileCount + intFiles
									lblStatus.Title = "Restore completed for "..intFiles.." data files"
									lblFilename.Title = " "
									fhSleep(1000,200)
								end
							elseif strButton == strTutorial then								-- Restore all Public Tutorial Files to Calico Pie folder
								strTutorial = ""
								showFolderPaths(strSourceDir..StrTutorials,strPublicPie..StrTutorials)		--! V2.0
								local intFiles = intCopyFiles(strSourceDir..StrTutorials,strPublicPie..StrTutorials,strProgName,"Restore",12)
								if intFiles < 0 then break end
								if intFiles > 0 then
									intFileCount = intFileCount + intFiles
									lblStatus.Title = "Restore completed for "..intFiles.." tutorial files"
									lblFilename.Title = " "
									fhSleep(1000,200)
								end
							elseif strButton == strRegistry then								-- Import all Registry Data Keys for Program
								strRegistry = ""
								if doImportRegistry(strSourceDir,strProgName) < 0 then return iup.CLOSE end
								lblFilename.Title = " "
								fhSleep(1000,200)
							end
						else
							strButton = "Skip Operation"
						end
					until strButton:match("Skip") or ( strProgram == "" and strTutorial == "" and ( strRegistry == "" or StrRegistry == "OFF" ) )
				else
					GUI_ModeDialogue(	"Backup Data Missing",
											"ERROR: Backup Data folder has no "..strProgName.." backup data saved.",
											"OK"	)
				end
				if intFileCount > 0 then
					intFileTotal = intFileTotal + intFileCount
	 				intProgTotal = intProgTotal + 1
				end
			end -- per installed Program loop
			showFolderPaths(StrBackupDir,StrCalicoPie)										--! V2.0
			doCheckUninstalledData()																-- Check if any Backup Data folder exists for an uninstalled program
			lblProgram.Title = "Family Historian ..."
			local strPrograms = " programs"
			if intProgTotal == 1 then strPrograms = " program" end
			lblStatus.Title = "Restore completed for "..intFileTotal.." files for "..intProgTotal..strPrograms
		end
		setMainControlsActive("YES")
	end -- function btnRestore:action

	-- GUI Options Tab Functions --

	function btnDefault:action()																	-- Action for Restore Defaults button
		ResetDefaultSettings()
		iup_gui.ShowDialogue("Help")
		setControls()
		iup_gui.ShowDialogue("Main")
		SaveSettings()																				-- Save sticky data settings
	end -- function btnDefault:action

	function btnSetFont:action()																	-- Action for User Interface Font button
		btnSetFont.Active= "NO"
		iup_gui.FontDialogue(tblControls)
		SaveSettings()																				-- Save sticky data settings
		btnSetFont.Active= "YES"
	end -- function btnSetFont:action

	function btnFolder:action()																	-- Action for Set Backup Folder button
		if setBackupFolderOK("Choose","") then
			lblBackData.Title = StrBackupDir:gsub("&","&&")
		end
	end -- function btnFolder:action

	function tglRegistry:action(intState)														-- Action for Allow RESTORE Registry Data toggle
		if intState == 0 then StrRegistry = "OFF" end
		if intState == 1 then StrRegistry = "ON" end
		SaveSettings()																				-- Save sticky data settings
	end -- function tglRegistry:action

	function tglDiagnose:action(intState)														-- Action for Enable Diagnostic Mode toggle
		if intState == 0 then StrDiagnose = "OFF" end
		if intState == 1 then StrDiagnose = "ON" end
		SaveSettings()																				-- Save sticky data settings
	end -- function tglDiagnose:action

	function tglDatedDir:action(intState)														-- Action for Use Dated Sub-folders toggle
		if intState == 0 then StrDatedDir = "OFF" end										-- 19 July 2013
		if intState == 1 then StrDatedDir = "ON" end
		if StrDatedDir == "OFF" then
			StrBackupDir = strRemoveDatedDir(StrBackupDir)
			lblBackData.Title = StrBackupDir
			iup_gui.RefreshDialogue("Main")
		end
		SaveSettings()																				-- Save sticky data settings
	end -- function tglDatedDir:action

	-- GUI Main Dialogue Global Functions --

	local intTabPosn = 0																			-- 0 means not chosen, otherwise tab posn number + 1	29 July 2013

	function tabControls:tabchangepos_cb(intNew,intOld)										-- Call back when Main tab position is changed
		setControls()
		intTabPosn = intNew + 1																	-- 29 July 2013
		if intNew == 0 and StrDatedDir == "ON" then											-- Opening Backup tab with dated sub-folders
			lblBackData.Title = strAppendDatedDir(StrBackupDir)								-- 19 July 2013
			iup_gui.RefreshDialogue("Main")
		end
		SaveSettings()																				-- Save sticky data settings
	end -- function tabControls:tabchangepos_cb

	function btnGetHelp:action()																	-- Action for Help & Advice button
		iup_gui.HelpDialogue(intTabPosn)														-- Tab dependent Help Page -- 31 July 2013
	end -- function btnGetHelp:action

	function btnDestroy:action()																	-- Action for Close Plugin button
		return iup.CLOSE 
	end -- function btnDestroy:action

	function dialogMain:close_cb()																-- Call back when GUI window Close pressed
		return iup.CLOSE
	end -- function dialogMain:close_cb

	function timProgram:action_cb()																-- Call back when Program Versions one-shot timer expires --! V2.0
		timProgram.run = "NO"
		if not doSetProgramVersions() then return iup.CLOSE end							-- Establish the installed Family Historian program Versions
		setMainControlsActive("YES")
	end -- function timProgram:action_cb

	-- GUI Main Dialogue Initialisation --

	setMainControlsActive("NO")																	--! V2.0

--[==[
	local strMigrate = StrBackupDir.."\\"..strBetaName										-- Retrieve original Registry.keys & Version.data after Beta Migrate operation on previous run of Plugin
	local strRegFile = strMigrate.."\\"..strRegKeys
	local strVerFile = strMigrate.."\\"..strVerData
	doRenameFile(strRegFile.."_beta",strRegFile)
	doRenameFile(strVerFile.."_beta",strVerFile)
]==]
	if StrDatedDir == "ON" then
		lblBackData.Title = strAppendDatedDir(StrBackupDir)									-- 19 July 2013
	end

	iup_gui.ShowDialogue("Main",dialogMain,btnDestroy)

end -- function GUI_MainDialogue

-- Main body of Plugin script starts here --

	fhInitialise(5,0,8,"save_recommended")														-- 5.0.8 for Project/User/Machine Plugin Data	--! V2.0

	PresetGlobalData()																				-- Preset global data definitions

	ResetDefaultSettings()																			-- Preset default sticky settings

	LoadSettings()																					-- Load sticky data settings

	MakeHelpDialogue()																				-- Create Help with no associated button for Version History when Version changes

	StrInitialMessage = [[
		 of this Plugin from the Family Historian Plugin Store.

		Ensure you digest the Help && Advice before using the Plugin, especially regarding RESTORE operations.

		This Plugin can change your Windows Registry (low-level PC settings) if you use the RESTORE option.
		However, this 'RESTORE Registry Data' feature is initially disabled by default on the Options tab.
		You are strongly advised to backup the Windows Registry before making any changes to it.

		If you have any questions about this Plugin, or if you encounter any problems as a consequence of using it,
		please contact the Plugin's author, Mike Tate, via the FHUG at www.fhug.org.uk or on the FHU Mailing List.

		Please do NOT contact Calico Pie, who are not responsible for this Plugin.          Thank you.
	]]
	StrInitialMessage = StrInitialMessage:gsub("\t","")										-- gsub needed for XP

	StrInStore = iup_gui.VersionInStore(223)

	if StrInStore <= iup_gui.Version:match("[^%d]*([%d%.]*)") then
		StrInitialMessage = "\nYou are currently running the latest Version "..iup_gui.Version..StrInitialMessage
	else
		StrInitialMessage = "\nPlease download the latest Version "..StrInStore..StrInitialMessage
	end

	if iup_gui.WarnDialogue({" ~  IMPORTANT  PLEASE  READ  ~ ",iup_gui.Risk},{StrInitialMessage,iup_gui.Risk},{"OK  Continue",iup_gui.Safe},{"Cancel  Plugin",iup_gui.Risk}) == 1 then

		GUI_MainDialogue()

	end

	SaveSettings()																					-- Save sticky data settings

--[=[
Windows Registry Management Notes

1)	Virtualisation for HKLM on Windows 7 & Vista (but not XP) allows Standard User to 'write' to HKLM keys.
	See http://msdn.microsoft.com/en-us/library/windows/desktop/aa965884%28v=vs.85%29.aspx

2)	Migrating 64/32 bit using %WinDir%\SysWOW64\reg.exe to avoid "HKLM\Software\wow6432node\..." problem.
	See http://csi-windows.com/blog/all/27-csi-news-general/266-scripting-migrating-and-managing-registry-data-in-64-bit-windows
	In following command %WinDir%\SysWOW64\REG.EXE actually exports from "HKLM\Software\Wow6432Node\Calico Pie\Family Historian" but hides \Wow6432Node\
	IF EXIST	%WinDir%\SysWOW64\REG.EXE (
				%WinDir%\SysWOW64\REG.EXE EXPORT "HKLM\Software\Calico Pie\..." "HKLM.reg"	/Y
	) ELSE (
											REG	 EXPORT "HKLM\Software\Calico Pie\..." "HKLM.reg"	/Y
	)

3)	Actual testing suggests none of the above is necessary. Plain REG works OK and \Wow6432Node\ disregarded. The /Y option is not allowed on XP.
	The HKEY_LOCAL_MACHINE\SOFTWARE\[Wow6432Node]\Calico Pie\Family Historian... keys grant Everyone permission for Full Control.
	This explains why any user account can write to those keys. 
]=]

--[=[
@V2.0:				Include os.getenv("PUBLIC")/os.getenv("ALLUSERSPROFILE")\Calico Pie\Family Historian\Tutorial Files\ in Backup & Restore.
@V2.0:				Include os.getenv("APPDATA")\Calico Pie\Family Historian\Plugin Data\ in Backup & Restore, new fh library modules, general code updates.
@V2.0:				Change the Batch jobs to use mostly local files, and modified completion method, to improve NAS device support.
@V2.0:				Inhibit main parent window while Backup or Restore is running, and report clearly when the operation has failed.
@V1.9:				Add NewGUI library, revised Version History help - must delete FHUG '...help:backup_and_restore_family_historian_settings:history' page.
@V1.8:				Update to FlgFolderExists(), cater for \\NAME\ in place of C:\, adjust runBatchFileOK() timeout counter, add Diagnose mode,
					optionally use date stamped backup sub-folders to allow multiple backups, Version History help, and new plain string snippets.
@V1.7:				Allow 1-hour DST (GMT/BST) offsets, fix StrVersionInStore, add StrWhite GUI background, and minor revisions.
@V1.6:				New disallow RESTORE Registry Data Keys option, migrate FH 5.0 Beta option removed,
					allow RESTORE to create folders & report failures, omit file paths from HKLM Registry Keys,
					introductory IMPORTANT PLEASE READ message, convert filename "&" to "&&" in GUI titles,
					function doCopyFile 'Restore Old File' WARNING adapted for 'Backup Old File' too,
					delete redundant image file backups.
@V1.5:				Migrate adapted for disabled FH 5.0 Beta.
@V1.4:				Added FHUG Help and Advice pages.
@V1.3:				Handles 1 hour time difference on Migrate Beta to Full V5, hides Restore Data buttons as they are used.
@V1.2:				REG QUERY /V /S reduced to REG QUERY /S for XP, Batch script timeout longer, Copy File tries all Write modes,
					also saves duplicate external images only once, and skips those in Program Data folders.
@V1.1:				Migrate FH 5.0 Beta Backup to FH V5.0, backup external image files, plus other minor updates. 
@V1.0:				First version.
]=]
